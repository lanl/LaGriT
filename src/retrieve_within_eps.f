*dk,retrieve_within_eps
      subroutine retrieve_within_eps(xq,yq,zq,linkt,sbox,
     &   eps,nefound,iefound,ierr)
c
c #####################################################################
c
c     purpose -
c
c     RETRIEVE_WITHIN_EPS uses the k-D tree structure
c     (generated by the KDTREE command) to accelerate finding all 
c     elements with EPS of the query point (XQ,YQ,ZQ).
c     What is actually returned is a small subset of leaves
c     (i.e., elements) that feasibly could be within EPS of 
c     the query point.  The user must then do exact geometric tests on this
c     small subset to actually determine which elements are
c     a distance EPS from the query point.
c
c     input arguments -
c
c         xq,yq,zq,  -   coordinates of query point
c         linkt,sbox -   k-D tree arrays.
c         eps  -         epsilon for length comparisons.
c
c     output arguments -
c         nefound -      no. of leaves (elements) returned
c         iefound -      array of elements returned
c         ierr -         error return.
c
c     change history -
c
c         $Log:   /pvcs.config/t3d/src/retrieve_within_eps.f_a  $
CPVCS    
CPVCS       Rev 1.0   Tue May 19 01:18:36 1998   kuprat
CPVCS    Initial revision.
 
      implicit none
      include 'consts.h'
 
      real*8 xq,yq,zq,sbox(2,3,1000000),eps
      integer linkt(1000000),nefound,iefound(1000000),ierr
 
      integer istack(100)
 
      integer itop,node,ind,k
      real*8 dist
 
      nefound=0
 
c.... Check distance of query point from root box.  
c.... If greater than EPS, there can be no elements within
c.... EPS of query point.
 
      dist=sqrt((max(zero,sbox(1,1,1)-xq,xq-sbox(2,1,1)))**2+
     &   (max(zero,sbox(1,2,1)-yq,yq-sbox(2,2,1)))**2+
     &   (max(zero,sbox(1,3,1)-zq,zq-sbox(2,3,1)))**2)

      if (dist.gt.eps) goto 9999
 
c.... If root node is a leaf, return leaf.
 
      if (linkt(1).lt.0) then
         nefound=1
         iefound(1)=-linkt(1)
         goto 9999
      endif
 
      itop=1
      istack(itop)=1
 
c.... Traverse (relevant part of) k-D tree using stack
 
      do while (itop.gt.0)
 
c.... pop node off of stack
 
         node=istack(itop)
         itop=itop-1
 
         ind=linkt(node)
 
c.... process both children of NODE
 
         do k=0,1
 
c.... Check distance of query point from bounding box of child. 
c.... Only process this child further if distance is less than
c.... or equal to EPS.

            dist=sqrt(
     &         (max(zero,sbox(1,1,ind+k)-xq,xq-sbox(2,1,ind+k)))**2
     &         +(max(zero,sbox(1,2,ind+k)-yq,yq-sbox(2,2,ind+k)))**2
     &         +(max(zero,sbox(1,3,ind+k)-zq,zq-sbox(2,3,ind+k)))**2)

            if (dist.le.eps) then

c.... If child is a leaf, add triangle to triangle list
 
               if (linkt(ind+k).lt.0) then

                  nefound=nefound+1
                  iefound(nefound)=-linkt(ind+k)

               else
 
c.... Put non-leaf child on stack.

                  itop=itop+1
                  istack(itop)=ind+k
 
               endif

            endif

         enddo
      enddo
 
 9999 continue
      return
      end
