var tipuesearch = {"pages": [{
    "title": "ADDMESH",
    "text": "ADDMESH This routine joins two meshes together at their common interface to produce a third mesh. Some operations may only work with tet meshes. NOTE: Care must be taken when using these commands because nothing is done to clean up the point type (itp) array after the addmesh operation. The user must often use the commands resetpts/itp and filter SYNTAX addmesh / add / mesh3 / mesh1 / mesh2 / [refine_factor] / [tet edge] addmesh / amr / mesh3 / mesh1 / mesh2 / addmesh / append / mesh3 / mesh1 / mesh2 / addmesh / delete / mesh3 / mesh1 / mesh2 / addmesh / glue / mesh3 / mesh1 / mesh2 / addmesh / intersect / pset_name / mesh1 / mesh2 / addmesh / match / mesh3 / mesh1 / mesh2 / i1 12 i3 i4 i5 i6/ addmesh / match / mesh3 / mesh1 / mesh2 /rx1 ry1 rz1/rx2 ry2 rz2/rx3 ry3 rz3/rx4 ry4 rz4/rx5 ry5 rz5/rx6/ry6/rz6/ addmesh / merge / mesh3 / mesh1 / mesh2 / addmesh / pyramid / mesh3 / mesh1 / mesh2 / addmesh / excavate / mesh3 / mesh1 / mesh2 / [bfs] / [connect] / add - Find the intersection of mesh1 and mesh2. Refine mesh1 where it overlaps mesh2 using the following criteria. refine_factor specifies the number of times that the background mesh will be refined. If this number is negative, or if it does not appear, then the it will use the default. The default method determines the number of refinement iterations based on the volumes of the tets. It continues to refine until the elements on the interface boundary of the background mesh object are within a given factor (5.0) of the volume of the elements on the border of the incoming mesh object. This factor is a parameter constant called size_difference in the code continue_refinement.f. For example, if size_difference is set to 5.0, then the background mesh will be refined until the maximum volume element on the boundary with the incoming mesh object is no bigger than 5 times the volume of the maximum volume element on the border of the incoming mesh. refine_type is the type of refinement that is executed. If the string tet appears, then tetrahedral refinement is performed. Otherwise, edge based refinement is performed. After the above refine steps have been done, the intersection of mesh1 and mesh2 is found, elements that overlap are deleted from mesh1 and mesh2 is appended to mesh1 to create mesh3. merge - Append mesh2 to to mesh1 and create mesh3. Essentially this just concatenates two mesh objects. glue - Synonym for merge. append - Append mesh2 to mesh1 and create mesh3. Similar to merge except imt, icr, itetclr of mesh2 have the value max(imt(mesh1)) added to mesh2. delete - Create mesh3 which is mesh1 with elements that intersect mesh2 deleted. intersect - Create a pset called pset_name that contains all nodes in mesh1 which intersect elements of mesh2. amr - Use Adaptive mesh refinement to connect background mesh1 with submesh mesh2 and create mesh3. match - Same as merge except the second mesh can be moved, rotated and translated. The first mesh does not move scale or rotate. If the interface needs to be scaled, translated and rotated that is accomplished by specifing 3 node numbers in each mesh or 3 node coordinates from each mesh that are to become coincident. If nodes are given match i1-i4, i2-i5, i3-i6. If coordinates are given match (x1,y1,z1)-(x4,y4,z4), etc. pyramid - join a hex mesh to a tet mesh. The common surface must have matching nodes (i.e. there must be exactly two triangle faces on the tet grid that fit into one quad face of the hex grid). Pyramid elements will be constructed in the region where the two meshes join. excavate - The circumscribed sphere of each triangle of mesh2 is computed and any node in mesh1 that falls inside one of the circumscribed spheres is marked as a dudded node, along with any cells of mesh1 associated with these nodes. mesh1 must be a 3D mesh (of any geometry) and mesh2 must be a 2D triangular mesh. This then excavates an area in mesh1 around mesh2, such that the surface could then be inserted into the 3D mesh (such as to insert a fault into a background terrain mesh). The background mesh, minus the excavated/removed nodes, is put into mesh3. The following options are available: [bfs] will use a breadth-first search algorithm to find nodes to remove, as opposed to the default KD-tree algorithm. This will find candidate nodes for deletion within the maximum circumradius of the surface. Then a breadth-first search across the surface will be searched for an element large enough to contain the candidate node. [connect] after excavation the following commands will be executed: addmesh/append and then connect. This will produce a fully connected mesh with the surface (mesh2) inserted into the background (mesh1). Click here for demos",
    "tags": "addmesh merge amr append glue excavate",
    "url": "/pages/docs/commands/ADDMESH.html"
  },{
    "title": "ASSIGN",
    "text": "ASSIGN Assign a value to a global variable.  The set of global variables includes: incycle, ttime, monitor, hextotet_remove_volume, hextotet_check_imt, hextotet_radavg, hextotet_remove_duplicates. Use cmo/setatt to assign values to mesh object attributes. See Mesh Object Definition for all mesh object variables and attributes. SYNTAX assign/category_name/column/variable_name/value. GLOBALS DEFAULTS incycle 0 ttime 0 monitor no hextotet_remove_volume yes hextotet_check_imt no hextotet_radavg no hextotet_remove_duplicates no EXAMPLES assign/time / 3.2 assign/hextotet_remove_duplicates / yes",
    "tags": "ok",
    "url": "/pages/docs/commands/ASSIGN.html"
  },{
    "title": "BOUNDARY",
    "text": "BOUNDARY The boundary routine operates on the current mesh object. For the nodes lying on the specified surface(s), it sets the specified node based attribute to the specified value. Optionally boundary will call the user supplied subroutine set_user_bounds. See this page SYNTAX boundary/dirichlet/ attr_name / [ value identifier ] / surface_list dirichlet is currently unused but must be specified attr_name is the name of the attribute to be set value is a constant, and is the value to which the attribute is set identifier is a character string that will be passed to subroutine set_user_bounds surface_list is one of: -all- (all boundary nodes) surface_name/inclusive (all bndry nodes on surface) surface_name/exclusive (all bndry nodes ONLY on surface) surface_name/` (same as exclusive) surface_name1 /surface_name2/inclusive (all bndry nodes on the union of the surfaces) surface_name1/surface_name2/exclusive (default) (all bndry nodes ONLY on the intersection of the surfaces) surface_name1/surface_name2/surface_name3/... (same as exclusive) EXAMPLES: boundary/dirichlet/ vd_v / 7.0/-all-/ sets the attribute vd_v for all boundary nodes to be 7.0. boundary/dirichlet/vi_s/8.0/pbot/ boundary/dirichlet/vd_v/9.0/pbot/inclusive/ sets the attribute vd_v for the nodes that are on the surface pbot to be 9.0. boundary/dirichlet/vd_s/13.0/pfrt sets the attribute vd_s for the nodes that are on the union of the surfaces pfrt and prgt to 13.0. boundary/dirichlet/vi_t/12.0/prgt/ boundary/dirichlet/bconds/top_plane/s1,s2,s3/ will pass the set of nodes on the intersection of surfaces s1,s2, and s3 along with the string top-plane to subroutine set_user_bounds.",
    "tags": "boundary dirichlet",
    "url": "/pages/docs/commands/BOUNDAR1.html"
  },{
    "title": "BOUNDARY_COMPONENTS",
    "text": "BOUNDARY_COMPONENTS Calculate the number of connected components of a mesh. This is useful for looking for holes in a mesh or as a diagnostic when looking at a single material (itetclr, imt) and determining if the material is contiguous or broken into multiple pieces. SYNTAX boundary_components boundary_components / node / [reset noreset] boundary_components / node / material_id_number / [reset noreset] boundary_components / element / [reset noreset] boundary_components / element / material_id_number / [reset noreset] node adds node attribute numbnd and id_numb to which is written a representative node of each outside boundary component. node/connected means that a set of nodes of type ‘outside’ (itp = 10 or 12) can be traversed via element edges that have both vertices of type ‘outside’. This method is not really fool proof in detecting holes in a mesh since one can traverse from the exterior of a mesh to an interior hole in the mesh via an edge that is not really a boundary edge. More coding could deal with this situation. In addition, the number of connected boundary components and a representative node number from each boundary component is assigned to the numbnd array. The number of nodes in each boundary set is printed. Non-boundary nodes are assigned numbnd = 0. If the itp array is not current, it must be updated first, with the command resetpts/itp. By default, resetpts/itp is called when the node option is invoked so the reset/noreset is optional. The node array id_numb is similar to numbnd in that nodes associate with the same boundary component have the same integer value, however id_numb is assigned values starting with 1 and going up to the number of boundary components in sequential order. node / material_id_number means the distinction of boundary nodes as defined by itp array value is ignored. Instead, all nodes with imt = material_id_number are examined and the number of edge connected components is determined for just that material. Nodes with imt material_id_number are assigned numbnd = 0. element adds element attribute numbnd_e with the element number of a representative element of a connected set. The number of connected components of the mesh is computed where ‘connected’ means sets of elements can be traversed via the element faces. The attribute numbnd_e is filled with the element number of a representitive element of a connected set. In addition, the number of connected components and a representative element number from each connected component and the number of elements in each connected component set is printed.  When the material_id_number option is invoked, only elements with tetclr = material_id_number are examined. Elements with itetclr material_id_number are assigned numbnd_e = 0. EXAMPLES boundary_components boundary_components / element / 3 DEMO for NODE and ELEMENT Boundary components node Note that the interior nodes have numbnd=0 and the nodes of the upper hole have the same value as the outside boundary since the upper hole can be reached by traversing an edge that is connected to the exterior. Boundary components element Note that the two pieces are have different values for numbnd_e even though element 15 is touching element 6. This is because one cannot traverse from the blue mesh (numbnd_e = 15) to the red mesh (numbnd_e = 24) through faces of the mesh.",
    "tags": "boundary_components, numbnd, numbnd_e",
    "url": "/pages/docs/commands/BOUNDARY_C.html"
  },{
    "title": "CMO",
    "text": "CMO These Current Mesh Object commands operate on the selected Mesh Object. There can be many Mesh Objects in the code for a given problem. Only one Mesh Object at a time is the Current and Active Mesh Object. (There is also one Default Mesh Object which is used as the template for generating new Mesh Objects). Each Mesh Object is has both default and user added attributes. The following are CMO (Current Mesh Object) options, click to see more details. CMO Options    Short Description    Brief Syntax addatt    Add an attribute to cmo    cmo/addatt/mo/att_name/type/rank/length addatt    Create new cmo attributes    cmo/addatt/mo/keyword/keyword_options attribute_derive    Derive attributes from another cmo cmo/attribute_derive/sink_mo/src_mo attribute_union Combine attributes of two mesh objects cmo/attribute_union/mo_1/mo_2 compress Compress cmo arrays to actual lengths cmo/compress/mo_name constraint Get surface constraints from cmo to another cmo/constraint/cmo_sink/cmo_src copy Copy a cmo to new cmo cmo/copy/mo_new/mo_master copyatt Copy attribute values to another attribute cmo/copyatt/mo mosrc/att att_src create Create a new cmo cmo/create/mo_name [/// mesh_type] delatt Delete a cmo attribute cmo/delatt/mo_name/att_name DELATT Force Delete a cmo attribute cmo/DELATT/mo_name/att_name delete Delete an existing cmo cmo/delete/mo_name derive Copy cmo to new cmo with empty data cmo/derive/mo_name/master_mo geometry Give geometry to cmo from another cmo cmo/geometry/mo_name/geometry_name length Print memory length for cmo attributes cmo/length/mo_name/att_name list List all mesh objects cmo/list memory Set length for cmo memory cmo/memory/mo_name/num_nodes/num_elements modatt Modify cmo attribute parameters cmo/modatt/mo/att_name/parameter/value move Change the name of a cmo cmo/move/mo_new/mo_old newlen Adjust attribute lengths cmo/newlen/mo_name printatt Print attribute values cmo/printatt/mo/att_name/[minmax] [1,0,0] readatt Read attribute values from file cmo/readatt/mo/att1,att2,[…] /1,0,0/file release Delete an existing mesh object cmo/release/mo_name select Make cmo current and active cmo/select/mo_name setatt Set values in cmo attributes cmo/setatt/mo/att_name/[1,0,0]/value set_id Create attribute with id numbers cmo/set_id/mo/node or element/att_name status Print mesh object status cmo/status/mo_name/ [brief] verify Verify memory for cmo cmo/verify/mo_name Active CMO A mesh object is made current or active: As a result of any command that generates a new mesh object As a result of any command that changes a mesh object (e.g. copyatt) Use cmo/select to explicitly specify the current active mesh object. RESERVED NAMES The following names are reserved and used in the various cmo commands: -default- : the default template for the LaGriT mesh object -def- : the default value for command options -cmo- : the Current Mesh Object -all-: all Mesh Objects or Attributes -xyz-: Mesh Object Attributes xic, yic, and zic CMO Parameters Attribute Possible Values (type character) default in bold mo_name   att_name   mesh_type tet, hex, pri, pyr, tri, triplane, quad, hyb, line, pnt type VDOUBLE, VINT, VCHAR, INT, REAL, CHARACTER rank scalar, vector, tensor, or any INT attribute length nnodes or any INT attribute   interpolate   linear copy, sequence, log, asinh, max, min, user, and,or,incmax ioflag a g, f, l – for output of avs, gmv, fehm, LaGriT EXAMPLES cmo/create/motet cmo/status/motet/ brief Create and print a brief status of the mesh object named motet: The current-mesh-object(CMO) is: motet 2 Mesh Object name: motet number of nodes = 0 number of elements = 0 dimensions geometry = 3 element type = tet dimensions topology = 3 4 nodes 4 faces 6 edges boundary flag = 16000000 status = active cmo/addatt/moquad/zsave/VDOUBLE/scalar/nnodes/linear/permanent/gxaf/0.0 cmo/copyatt/moquad moquad/zsave zic cmo/printatt/moquad/-all- minmax Add the attribute zsave to the mesh object and copy zic attribute values into zsave attribute: ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH -def- 0.000000000E+00 0.000000000E+00 0.000000000E+00 14241 scalar 1 1 0 1 vector 3 3 0 1 nnodes 14241 14241 0 1 nedges 0 0 0 1 nfaces 0 0 0 1 nelements 14000 14000 0 1 mbndry 16000000 16000000 0 1 ndimensions_topo 2 2 0 1 ndimensions_geom 3 3 0 1 nodes_per_element 4 4 0 1 edges_per_element 4 4 0 1 faces_per_element 4 4 0 1 isetwd 0 0 0 14241 ialias 0 0 0 14241 imt1 1 1 0 14241 itp1 0 10 10 14241 icr1 0 0 0 14241 isn1 0 0 0 14241 xic 4.980000000E+05 5.005000000E+05 2.500000000E+03 14241 yic 5.370000000E+05 5.405000000E+05 3.500000000E+03 14241 zic 1.638043335E+03 1.856468628E+03 2.184252930E+02 14241 xtetwd 0 0 0 14000 itetclr 1 1 0 14000 itettyp 4 4 0 14000 itetoff 0 55996 55996 14000 jtetoff 0 55996 55996 14000 itet 1 14241 14240 14000x4 jtet 2 16000000 15999998 14000x4 epsilon 1.000000004E-15 1.000000004E-15 0.000000000E+00 1 epsilonl 9.562806528E-10 9.562806528E-10 0.000000000E+00 1 epsilona 4.118418852E-06 4.118418852E-06 0.000000000E+00 1 epsilonv 4.243763815E-04 4.243763815E-04 0.000000000E+00 1 ipointi 1 1 0 1 ipointj 14241 14241 0 1 idebug 0 0 0 1 itypconv_sm 1 1 0 1 maxiter_sm 25 25 0 1 tolconv_sm 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 nnfreq 1 1 0 1 ivoronoi 1 1 0 1 iopt2to2 2 2 0 1 xmin 4.980000000E+05 4.980000000E+05 0.000000000E+00 1 ymin 5.370000000E+05 5.370000000E+05 0.000000000E+00 1 zmin 1.638043335E+03 1.638043335E+03 0.000000000E+00 1 xmax 5.005000000E+05 5.005000000E+05 0.000000000E+00 1 ymax 5.405000000E+05 5.405000000E+05 0.000000000E+00 1 zmax 1.856468628E+03 1.856468628E+03 0.000000000E+00 1 kdtree_level 0 0 0 1 max_number_sets 64 64 0 1 number_of_psets 0 0 0 1 number_of_eltsets 0 0 0 1 number_of_fsets 0 0 0 1 zsave 1.638043335E+03 1.856468628E+03 2.184252930E+02 14241",
    "tags": "cmo operations options",
    "url": "/pages/docs/commands/CMO2.html"
  },{
    "title": "COLORMAP",
    "text": "COLORMAP This command builds the colormap.  In reality it only builds the material adjacency graph, from with the colormap can be quickly generated when needed. SYNTAX colormap/ [add or create or delete] /[cmo_name] add – The material adjacency characteristics of the specified mesh object is added to the existing material adjacency graph, which is created if it didn’t exist.  This is the default action. create – The existing material adjacency graph is deleted and a new one created from the specified mesh object. delete – The material adjacency graph is deleted if it exists.  Any specified mesh object is ignored.   EXAMPLES colormap/create/ mesh1 colormap/mesh2 colormap/delete",
    "tags": "colormap",
    "url": "/pages/docs/commands/COLORMAP.html"
  },{
    "title": "COMPUTE",
    "text": "COMPUTE This command contains modules that compute various attributes and functions based on one or more mesh objects. This operation will (often) result in new attributes being added to the mesh objects. The action of the command will be controled by the keyword in the second argument position. SYNTAX compute/distance_field/mo_sink/mo_source/distance_field_attribute compute/signed_distance_field/mo_sink/mo_source/distance_field_attribute compute/linear_transform/mo_main/mo_surface/[direction/att_name] distance_field is the keyword for distance field calculation. Determine the minimum distance from any node in mo_source to every node in mo_sink and place the result in the node based floating point attribute, distance_field_attribute in mo_sink. The computation is accelerated by using the kdtree search algorithm. signed_distance_field is the keyword for signed distance field calculation. Determine the minimum distance     from any node in mo_source to every node in mo_sink and place the result in the node based floating         point attribute, distance_field_attribute in mo_sink. The computation is accelerated by using the       kdtree search algorithm. This option requires the mo_source MUST be either a triangle or quad surface mesh object. If the surfaces form a topologically closed volume then positive, ‘above’ distance is in the     direction of the surface normal vector. Negative is ‘below’ the surface. If the surface is not a closed     volume, then the assumptions described in the surface command are used to determine what is above and what is below the surface. linear_transform is the keyword for an extrapolation from an attribute value in a surface onto every node of a 3D mesh. Given a 3D mesh and a 2D surface, this command will extrapolate a scalar value from that surface onto every point of the mesh. This can be used to (for example): Propagate head values from a surface onto all nodes of a mesh. Expand a mesh to fit a surface, by propogating the appropriate spatial coordinate. Compute the depth relative to a topographic surface to each node of a mesh. This is highly dependant on the spatial relation between the mesh and the surface - values from the surface are extrapolated “downward” into the mesh in the direction specified in the command. The direction specified in the command must be one of zpos, zneg, ypos, yneg, xpos, xneg For example, specifing [zpos] will result in the upper (positive z-axis) side of the mesh having attribute values conforming exactly to those on the surface, while the lower side of the mesh will have whatever attribute values it had previous, with all nodes in between having attribute values distributed linearly between the two extremes. If a direction is not specified, it will default to zpos. If an attribute is not specified, it will default to the spatial attribute appropriate to the chosen direction (i.e. if the direction is yneg, the attribute will default to yic, the y-coordinate of each node. The attribute chosen must already exist in both the surface and main meshes. Other places to look for modules that compute some standard mesh attributes include, QUALITY, which will compute aspect ratio and volume, cmo/addatt, which will compute normal vectors, dihedral angles, solid angles, meadian points, Voronoi points and more. User functions can be computed with MATH. EXAMPLES cmo / create / cmo_src createpts/rtz/1,91,1/3.,0.,0./3.,270.,0./1,1,1/ cmo / create / cmo_snk createpts / xyz / 30 30 1 / -5. -5. -5. / 5. 5. 5. / 1 1 1 compute / distance_field / cmo_snk / cmo_src / dfield finish",
    "tags": "compute, signed_distance_field, distance_field",
    "url": "/pages/docs/commands/COMPUTE.html"
  },{
    "title": "CONNECT",
    "text": "CONNECT Connect the nodes into a Delaunay tetrahedral or triangle grid. The Delaunay criterion requires that the circumsphere (circumcircle) defined by each tetrahedron (triangle) contains no mesh nodes in its interior. If the target simulator is one that uses two-point flux approximation and Voronoi control volumes (FEHM, PFLOTRAN, TOUGH2), use connect to create the mesh, then dump/stor to compute and output geometric coefficients file. Click here for a description of Delaunay Click here for more details on the connect algorithm SYNTAX connect/[ delaunay/ ifirst,ilast,istride / big_tet_coordinates ] connect / noadd connect / check_interface OPTIONS delaunay is the default algorithm and requires that a “big tet” be constructed that contains all nodes in its interior. For mesh points with multi-materials (imt with multi-values), connect will detect material interfaces and will look for edges that intersect the interfaces.  connect will add points at these intersections to create a conforming mesh, note that mesh quality may be impacted.   ifirst,ilast,istride The user has the option of selecting a subset of nodes to connect. big_tet_coordinates The user has the option of providing the coordinates of this “big tet”. noadd This option will turn off material interface detection. check_interface option does a more exhaustive job of making sure there are no edges of the mesh that cross a material boundary. USAGE For 2D and connecting points on a planar surface, the mesh must have ndimensions_topo=2 and ndimensions_geom=2. This command will create a mesh object with settings appropriate for the connect command. cmo/create/ cmotri / triplane The connect command does not filter out coincident vertices (sqrt[(xi-xj)2 + (yi-yj)2 + (zi-zj)2] &lt; epsilon). Use the following commands before connect to remove duplicate points. filter/ 1,0,0 rmpoint/compress For better precision where large coordinate numbers are being used, translate the points close to zero before using connect. The following will move points, connect, then translate back to original position. trans 1,0,0 /XBIG,YBIG,ZBIG/ 0. 0. 0./ connect trans 1,0,0 / 0. 0. 0./ XBIG,YBIG,ZBIG The connect algorithm creates a triangulation or tetrahedralization of the convex hull. If the domain to be meshed is not convex, there is no guarantee that all of its faces and edges will be within the specified mesh boundary. Connections will be formed across non-convex boundaries. A convex geometry is not guaranteed. A point distribution over a large region where spacing varies from very small to very large can result in high aspect ratios with small concavities formed on mesh boundaries. You can mitigate the impact by adjusting the mesh resolution. Generally high aspect ratio tets (long dimension along the external boundary) are more of a problem. This means that mesh refinement that brings the mesh closer to unit aspect ratio will help. The connect command may refuse to add nodes that will result in near zero-volume tetahedra. The volume tests are based on the mesh object epsilons. To ensure that these epsilons are based on the geometry, issue a setsize command before setpts. Expert users may adjust the epsilons with the cmo/setatt command.  The connect command will report if it is successful, check to see if there are any problems. For instance, connect may finish but may not be able to include all points due to a non-convex boundary or a poor point distribution. For instance: Dudding 7181 points that have no associated tetrahedra. The mesh is complete but could not include all points. Number of points that could not be connected: 7181 LaGriT FINISH: connect EXAMPLES connect connect/delaunay/ These two commands are the same, they create the Delaunay tetrahedral connectivity of all nodes in the mesh. Add nodes to break multi-material connections. cmo / create / mo_tri / / / triplane createpts / xyz / 4 4 1 / 0. 0. 0. / 1. 1. 0. / 1 1 1 cmo / setatt / mo_tri / imt / 1 0 0 / 1 connect cmo / setatt / mo_tri / itetclr / 1 0 0 / 1 resetpts / itp Create a triplane mesh object (ndimensions_topo=2 and ndimensions_geom=2) with 4 x 4 points on plane with Z = 0. Connect into triangles and set node and element materials to 1. The resetpts/itp command will define the boundary nodes for this mesh. connect/delaunay/1,0,0/0.,0.,0./1000.,0.,0./500.,1000.,0./500.,500.,10./ connect/1,0,0/ 0.,0.,0./1000.,0.,0./500.,1000.,0./500.,500.,10./noadd connect/delaunay/1,0,0/ 0.,0.,0./1000.,0.,0./500.,1000.,0./500.,500.,10./noadd connect/delaunay/1,0,0/0.,0.,0./1000.,0.,0./500.,1000.,0./500.,500.,10./check_interface Create the Delaunay tetrahedral connectivity of all nodes in the mesh and specify explicitly the coordinates of the enclosing tetrahedron. connect /pset, get, mypoints Create the Delaunay tetrahedral connectivity of a subset of nodes with the name mypoints. connect/noadd Create the Delaunay tetrahedral connectivity of  all nodes in the mesh and disregard material interfaces. # create a 2D triangle mesh cmo / create / mo_tri / / / triplane # Make some points at the four corners createpts / xyz / 5 5 1 / 0. 0. 0. / 1. 1. 0. / 1 1 1 # Add some random points and delete duplicate points createpts / random / xyz / 0.4 / 0.1 0.1 0. / 0.9 0.9 0. filter / 1 0 0 rmpoint / compress # set some defaults for the connect routine cmo / setatt / mo_tri / imt / 1 0 0 / 1 cmo / setatt / mo_tri / itp / 1 0 0 / 0 connect # set default materials and boundary tags cmo / setatt / mo_tri / itetclr / 1 0 0 / 1 resetpts / itp Create a simple 2D triangle mesh. Set defaults for material and boundary tags for nice behavior. This starts with points at the corner of a box and fills with random points. The connect command will create the triangulation and the result is a single material mesh with inside/outside boundary points tagged with the itp attribute. connect/check_interface Create the Delaunay tetrahedral connectivity of  all nodes in the mesh with added checking of edges that have both nodes tagged as itp=’intrface’ to be sure that the edge does not cross a material interface. This option is more expensive but may fix situations where multi-material edges do not get refined because they connect an ‘intrface’ node to an ‘intrface’ node. Click here for 2D demos Click here for 3D demos The connect command replaces the LaGriT V1 command search/delaunay.",
    "tags": "connect, tet, Delaunay",
    "url": "/pages/docs/commands/CONNECT1.html"
  },{
    "title": "COORDSYS",
    "text": "COORDSYS This routine defines a local coordinate system to be in effect until another coordinate system is defined or the normal coordinate system is reset. The new coordinate system is defined by specifying an origin, a point on the new x-z plane and a point on the new z-axis. These points are specified in the normal coordinate system. The options available in ioption are: SYNTAX coordsys/ define /x0,y0,z0/xx,xy,xz/zx,zy,zz/ coordsys/ ioption normal return to the normal coordinate system save save the current coordinate system for recall restore recall the last saved coordinate system define define a new local coordinate system x0,y0,z0 is the location of the new origin, xx,xy,xz is a point on the new x-z plane and zx,zy,zz is a point on the new z-axis. These points are defined with the normal coordinate system, and used only with the define option.",
    "tags": "coordsys, coordinate system",
    "url": "/pages/docs/commands/COORDSY.html"
  },{
    "title": "COPYPTS",
    "text": "COPYPTS Copy a point distribution. There are two distinct forms of this command. The first format is designed to copy points from one mesh object into another. In this form if the names of the source and sink mesh objects are omitted, the current mesh object will be used. The copy may be restricted to a subset of points by including the source point information. Points in the sink mesh object will be overwritten if sink_stride is not zero. Attribute fields may be specified for both the source and sink mesh object. For example the x-coordinate field in the source mesh object (xic) may be placed in the y-coordinate field of the sink mesh object. Attribute values will be copied from the source mesh object to the sink mesh object. The user is warned that these values might not make sense in their new context. The second form of this command is included for historic reasons: it duplicates points within a mesh object including all the attributes of the points. Also note that if no sink points or sink stride are specified, then the copied points are placed at the end of the data arrays (see third FORMAT) otherwise the copied points are written over the existing points starting at the 1st sink point. Note also that the first form of the command gives the arguments sink first then source whereas the second form gives the source then the sink. SYNTAX copypts/sink_cmo/source_cmo/sink_range/ src_range /source_attribute_name copypts/sink_cmo/source_cmo/sink_range/ src_range copypts/ range sink_cmo is the name of mesh object to copy points into. source_cmo is the name of mesh object to copy points from. range is the convention using numbers representing ifirst,ilast,istride for a set selection. The range given as 1,0,0 means all are selected. EXAMPLES copypts/3dmesh/2dmesh/ Copy all points in 2dmesh to the end of the 3dmesh point list. copypts/3dmesh/2dmesh/0,0/pset,get,mypoints/ Copy the point set named mypoints from 2dmesh to the end of 3dmesh point list. copypts/3dmesh/2dmesh/100,4/pset,get,mypoints/boron/arsenic/ Copy the arsenic field from the point set named mypoints from 2dmesh replacing the boron field at every fourth point beginning at point 100 in 3dmesh. copypts/pset,get,mypoints/0,0/ Duplicate the point set named mypoints from the current mesh object and place the duplicated points at the end of the point list. copypts/0,0/pset,get,mypoints/ Duplicate the point set named mypoints from the current mesh object and place the duplicated points at the end of the point list. Same effect as the example directly above. The current mesh object is used since the fields are blank on the command line.",
    "tags": "copypts, copy",
    "url": "/pages/docs/commands/COPYPTS.html"
  },{
    "title": "CREATEPTS/AMR",
    "text": "CREATEPTS/AMR CREATEPTS/AMR uses an octree type refinement applied to an existing hexahedral mesh to all nodes in a specified region.  No additional elements are kept,  the intention is that the resulting node distribution will be passed to connect to generate a tetrahedra mesh. SYNTAX createpts/ amr/region_name/number_of_levels region_name is the    name of region to refine.  If blank,  all regions will be refined.  An element will be refined if any node of the element is in the specified region. number_of_levels    is the number of times the refinement will be performed.  After each level, the code will determine which of the new nodes are in the specified region and will refine the associated elements.  Default is 1. EXAMPLES   createpts/amr    refine the entire mesh createpts/amr /r1/3    refine elements with nodes in the region r1 three times DEMO TET MESH Create a hex mesh, refine with createpts/amr, connect into a tet mesh. # create the hex mesh cmo/create/cmo///hex # define geometry surface/inside/reflect/box/0,0,0/1,1,1 surface/diag/intrface/plane/0,0,0/1,0,1/1,1,1 region/lin/ le inside and ge diag / region/rin/ le inside and lt diag / mregion/mlin/ le inside and gt diag / mregion/mrin/ le inside and lt diag / # distribute nodes quadxyz/2,2,2/0.,0.,0./1.,0.,0./1.,1.,0./0.,1.,0./ &amp; 0.,0.,1./1.,0.,1./1.,1.,1./0.,1.,1./ # set node types and materials setpts # connect up the hex mesh createpts/brick/xyz/2,2,2/1,0,0/connect # refine the hex mesh createpts/amr/lin/1 createpts/amr/rin/3 # create the tet mesh cmo/create/cmot///tet # define geometry again for tet mesh surface/inside/reflect/box/0,0,0/1,1,1 surface/diag/intrface/plane/0,0,0/1,0,1/1,1,1 region/lin/ le inside and ge diag / region/rin/ le inside and lt diag / mregion/mlin/ le inside and gt diag / mregion/mrin/ le inside and lt diag / # copy in the nodes from the hex mesh to the tet mesh copypts/cmot/cmo cmo/select/cmot cmo/release/cmo cmo/setatt/cmot/itp/1,0,0/0 cmo/setatt/cmot/imt/1,0,0/0 * set node types and materials setpts * connect up the tet mesh connect # set element materials # and create parent/child nodes on interfaces settets dump/gmv/tet.gmv finish  ",
    "tags": "createpts/amr, create points",
    "url": "/pages/docs/commands/createpts/CREATEPTSAMR.html"
  },{
    "title": "CREATEPTS/BRICK",
    "text": "CREATEPTS/BRICK Builds a set nodes (logically rectangular) and creates finite element connectivity. This command is similar to the quadxyz command except that symmetry flags are included and elements are created. The brick option specifies that a mesh is connected into elements. This command can be used to create finite element connectivity on a logically rectangular set of nodes created by another method. See quadxyz or createpts command without the brick option. These commands require a hex or quad cmo type mesh object, use cmo/create to set the mesh element type. For instance, cmo/create/mo_name / / / hex or cmo/create/mo_name / / / quad. SYNTAX createpts/brick / xyz or rtz or rtp / ni,nj,nk / xmin,ymin,zmin / xmax,ymax,zmax / iiz,ijz,ikz / [ iirat,ijrat,ikrat / xrz,yrz,zrz / isym,jsym,ksym ] createpts/brick / xyz or rtz or rtp/ ni,nj,nk / 1,0,0 / connect / Note these actions apply to a hex or quad mesh object as defined with the create command or generated from another command. Distribution Types: xyz specifies Cartesian coordinates. rtz specifies cylindrical coordinates. rtp specifies spherical coordinates. Distribution Options: ni,nj,nk are the number of points to be created in each direction. xmin,ymin,zmin are the minimums for coordinates. xmax,ymax,zmax are the maximums for coordinates. iiz,ijz,ikz  if = 0 then mins and maxs are used as cell centers if =1 then mins and maxs are used as cell vertices. The default is 1,1,1 iirat,ijrat,ikrat are optional and set the ratio zoning switches (0=off,1=on) xrz,yrz,zrz are optional and are the ratio zoning value - distance is multiplied by the value for each subsequent point. isym,jsym,ksym symmetry flags - not documented 1,0,0 is the point set selection indicated by start,stride,stop or pset,get,pset_name where 1,0,0 are all points. EXAMPLES: cmo/create/cmohex / / / hex createpts/brick/xyz / 3,2,3 /0.,0.,0./1.,1.,1./1,1,1 Creates a set of hex points (3x2x3) and hex elements (2x1x2 hex) in the unit cube. The connect option should not be used in this case because the hex brick connectivity is created. cmo/create/cmohex / / / hex quadxyz /5,7,5/ 0.,0.,0./1.,0.,0./1.5,0.5,2.0/.5,.2,2.5/ &amp; -1.,1.5,0./2.0,0.,0.0/2.1,1.9,2.4/-0.2,1.8,2.3/ createpts/brick/xyz/5,7,5/1,0,0/connect These commands create a 3D set of nodes using quadxyz and then creates hex connectivity with the createpts/brick command. Be careful that the nx, ny, nz values for both the quadxyz and createpts/brick command are the same.   cmo/create/cmoquad/ / / quad quadxy/ 11, 11 / 0. 0. 0. / 1. 0. 0. / 1. 1. 0. / 0. 1. 0. createpts/brick/xyz/11,11,1/1 0 0 / connect The first line creates an empty quad cmo. The second line calls quadxy to create a 2D set of nodes. The last line uses createpts/brick to connect the points into quad elements. define RTOP 20. define NRADIAL 3 define NRAYS 20 define NRINGS 12 define WRADIUS 2. define CIRDEG 360. cmo/create/mo_cylinder / / / hex createpts/brick/rtz/NRADIAL,NRAYS,NRINGS/0. 0. 0./ &amp; WRADIUS CIRDEG RTOP /1,1,1 Use the define commands to set variables for making a cylinder mesh. This hex mesh has height of 20. There are 3 points from center to rim, there are 20 points around and 12 points vertical. Width of radius from center is 2 and the cylinder is a full 360 degrees.",
    "tags": "createpts/brick",
    "url": "/pages/docs/commands/createpts/CRTPTBRICK.html"
  },{
    "title": "CREATEPTS/RANDOM",
    "text": "CREATEPTS/RANDOM This routine is used to add random points with a given target spacing to the region of space defined by the input minimum and maximum coordinate values using the specified geometry (xyz, rtz, or rtp), and the given local origin (specified in xyz coordinates). Within the bounding geometry, the points are distributed uniformly in space, with the average separation targeted at the input value of the spacing.  Near the boundaries of the geometry, the uniform distribution is modified slightly in order to create a well defined outer boundary.  Points are added separately on the corners, edges, and surfaces of the bounding geometry, uniformly randomly distributed with the same target spacing on each of these boundary objects. Points in the interior are offset by the specified edge protection distance from the exterior.  This separation helps LaGriT’s connect algorithm avoid creating artificial “pits” in the interface surfaces. While only createpts/random is required (will result in a single point at the origin), it is recommended that you use as the minimal command, first line below. SYNTAX createpts/random /geom/spacing/ rmin1,rmin2,rmin3 / rmax1,rmax2,rmax3 createpts/random /geom/spacing/rmin1,rmin2,rmin3 /rmax1,rmax2,rmax3 / &amp; [ xoff,yoff,zoff / edgedist / ranseed1,ranseed2 ] Geometry Options for geom: xyz specifies Cartesian coordinates (default). rtz specifies cylindrical coordinates. rtp specifies spherical coordinates. Options: spacing is the target separation between the random points, values must be &gt; 0 (default is 1). rmin1,rmin2,rmin3 / rmax1,rmax2,rmax3 are the minimum and maximum coordinate values (defaults: rmin=0, rmax=rmin). For rtz rmax2-rmin2 must be &lt;= 360. For rtp the values should be rmax2 &lt;= 180, and rmax3-rmin3 &lt;= 360. All min values must be &gt;= 0. xoff,yoff,zoff is the local origin shift specified in xyz coordinate system (default is 0). edgedist is the edge protection distance (default and recommended: spacing/2). Note: if the spacing is larger with respect to the dimension of the geometry, the default setting may result in few or no interior nodes.  In this case decrease the value of edgedist. ranseed1, ranseed2 are seeds for the random number generator, the default is -1 (do not re-seed, recommended). If either seed is .le. zero, the seeds are ignored. Recommended values if reseed: large-ish integers, ranseed1 &gt; ranseed2 &gt; 0, ranseed2 odd. No initial seeds are needed, and repeating the command with the identical parameters and seeds should result in the identical point distribution. Repeating the command with no seeds specified should result in different point locations with the same distribution.   EXAMPLES createpts / random / xyz / .1 / 0 0 0 / 1 1 1 / Random points with target spacing 0.1 in a 1x1x1 box. createpts / random / rtz / .1 /  0,0,0 / 1,,360 / 2,3,4 / 0.2 Random points with target spacing 0.1 in a cylinder of radius 1 centered at xyz=(2,3,4) and with an edge protection distance of 0.2. createpts / random / rtp / .5 /  5,0,0 / 5,,360 /  , ,  /  / 98765 4321/ Random points with target spacing 0.5 on the surface of a sphere of radius 5 centered at the origin with new random seeds. CAVEATS Filter should be used afterwards to remove possibly duplicate points. The algorithm to insure the points are uniformly distributed in space is not clever about handling values outside the allowed range for rtz and rtp geometries and so it simply truncates them to the allowed range if possible or aborts. Most importantly, angles are in degrees and theta for the rtp geometry runs from 0 to degrees, with 0 degrees being the +z axis. It does know about the angular periodicity and there should be only the “corner” point artifacts of, eg, the +x axis being the origin of phi (rtp) or theta (rtz) if a full 360 degfrees for these two variables in their respective coordinate systems is used.",
    "tags": "CREATEPTS/random",
    "url": "/pages/docs/commands/createpts/CRTPTRZRAN.html"
  },{
    "title": "CREATEPTS/VECTOR",
    "text": "CREATEPTS/VECTOR This routine is used to ratio zone the region of space spanned by the input number n(i) of copies of the input vector v(ij) away from the initial point v(0j) using the desired coordinate system. The j-th component of the i-th vector V(ij) is reduced by r(ij) at each step in the i-th direction away from the initial point. No attempt is made to insure that the 3 vectors are independent. This command replaces RZV. SYNTAX ceatepts/vector/[ xyz rtz rtp / &amp;                 [ n1,n2,n3 &amp;                  /v11,v12,v13/v21,v22,v23/v31,v32,v33 &amp;                   /v01,v02,v03 &amp;                  /r11,r12,r13/r21,r22,r23/r31,r32,r33 ] default = 0:      n(i), v(i), v(0j) default = 1:      r(ij)   EXAMPLES createpts/vector/rtz/n1,0,0/.1,10.,1/ , , / , , / , , /1.1,1,.9 spiral of points createpts/vector/xyz/n1,n2,n3/1,0,0/0,1,0/0,0,1 rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 simple cubic point distribution, both lines have the same result createpts/vector/xyz/n1,n2,n3/.5,.5,.5/.5,.5,-.5/.5,-.5,-.5/ rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 rz/xyz/n1  ,n2  ,n3  /0,0,0/n1,n2,n3/0,0,0 body centered cubic point distribution, compare with the rz two command sequence with different bounding box. createpts/xyz/n1,n2,n3/.5,.5,0/0,.5,.5/.5,0,.5/ rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 rz/xyz/n1  ,n2  ,n3+1/0,0,0/n1,n2,n3/0,0,1 rz/xyz/n1  ,n2+1,n3  /0,0,0/n1,n2,n3/0,1,0 rz/xyz/n1+1,n2  ,n3  /0,0,0/n1,n2,n3/1,0,0 face centered cubic point distribution compare with the four rz command sequence (different bounding box). createpts/xyz/n1,n2,n3/1,0,0/.5,0.866,0/0,0,1 hexagonal lattice of points in x,y plane, repeated in z direction createpts/xyz/n1,n2,n3/.5,.5,0/0,.5,.5/.5,0,.5 createpts/xyz/n1,n2,n3/.5,.5,0/0,.5,.5/.5,0,.5/.25,.25,.25 rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 rz/xyz/n1  ,n2  ,n3+1/0,0,0/n1,n2,n3/0,0,1 rz/xyz/n1  ,n2+1,n3  /0,0,0/n1,n2,n3/0,1,0 rz/xyz/n1+1,n2  ,n3  /0,0,0/n1,n2,n3/1,0,0 rz/xyz/n1+1,n2+1,n3+1/0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/1,1,1 rz/xyz/n1  ,n2  ,n3+1/0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/0,0,1 rz/xyz/n1  ,n2+1,n3  /0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/0,1,0 rz/xyz/n1+1,n2  ,n3  /0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/1,0,0 diamond point distribution (two command sequence) compare the eight rz command sequence (different bounding box). createpts/xyz/n1,n2,n3/1,0,0/.5,0.866,0/0,0,1/ createpts/xyz/n1,n2,n3/1,0,0/.5,0.866,0/0,0,1/.5,0.2,.5 hexagonal close pack point distribution  (two command sequence) CAVEATS -       filter should be used afterwards to remove possibly duplicate points       this can create some really bizzare point distributions       mistyped input after “rzv/[cgeom]” always returns successful point addition, but may be very different than desired",
    "tags": "createpts vector",
    "url": "/pages/docs/commands/createpts/CRTPTRZV_LG.html"
  },{
    "title": "CREATEPTS/ xyz rtz rtp line",
    "text": "CREATEPTS/ xyz rtz rtp line This command adds points to a mesh object. It can distribute points evenly or according to a ratio zoning method as indicated by the choices xyz, rtz, rtp, or line. These points can be connected into a tet mesh object. If you want a connected hex mesh object, use the createpts/brick commands instead. SYNTAX createpts / xyz or rtz or rtp / ni,nj,nk / xmin,ymin,zmin / xmax,ymax,zmax / iiz,ijz,ikz / [ iirat,ijrat,ikrat /xrz,yrz,zrz ] createpts / line / npoints / / / xmin,ymin,zmin / xmax,ymax,zmax / iiz,ijz,ikz / Distribution Types: xyz Cartesian coordinates. rtz Cylindrical coordinates with center at (0,0,0). This results in a (partial) cylinder of points centered around the z axis. Use the rotateln and trans command to move cylinder. The minimum and maximum coordinates are the triplets: radius from the cylinder’s axis angle in the xy-plane measured from the x-axis length along the z-axis rtp Spherical coordinates with center at (0,0,0), use a trans command to move center to a new coordinate. The minimum and maximum coordinates are the triplets: radius from the center of the sphere axis angle in the zy-plane measured from the positive z-axis the angle in the xy-plane measured from the positive x-axis. See Conventions. line this option implies xyz and will distribute npoint nodes from (xmin,ymin,zmin) to (xmax,ymax,zmaz) Distribution Options: ni,nj,nk are the number of points to be created in each coordinate direction as described above. xmin,ymin,zmin are the minimums and xmax,ymax,zmax are the maximums for coordinates as described above. iiz,ijz,ikz 0 or 1 switches 0 = mins and maxs are used as cell centers 1 = mins and maxs are used as cell vertices iirat,ijrat,ikrat ratio zoning switches 0=off (default), 1=on xrz,yrz,zrz ratio zoning value - distance is multiplied by this value for each subsequent point. EXAMPLES createpts/xyz/ 5,3,10 /0.,2.,0./5.,6.,2./1,1,1/ This results in a xyz set of 150 points, five across from x=0. to x=5., 3 deep from y=2. to y=6. and 10 high from z=0. to z=2. cmo/create/ motet / / / tet createpts/rtz/ 4,6,11 /0.,0.,0./3.,360.,10./1,0,1/ cmo/setatt/ motet/ imt/ 1 filter/1,0,0; rmpoint/compress; connect This results in 264 cylinder points arranged around the z- axis. There are 3 rings of points at distances r=1., r=2. and r=3. from the z-axis. There are 11 sets of these three rings of points and heights z=0., z=1., z=2.,…,z=10. In each ring there are 6 points where each pair of points is separated by 60° Note that ijz=0 requests that points be placed at cell centers, hence the first point will be at 30° not at 0°. Corresponding to r=0, there will be 6 identical points at 11 intervals along the z-axis at heights z=0., z=1., z=2.,…z=10. The filter command tags duplicate points and the rmpoint/compress removes the tagged points and updates the mesh object. The connect command will create a connected tetrahedral mesh object. define XP1 1. define YP1 1. define XP2 100. define YP2 150. define N_POINTS 100 cmo/create/mo_line createpts/line/ N_POINTS / / /XP1 YP1 0. / XP2 YP2 0. /1 1 1/ Create a line of 100 unconnected points from point 1,1,0 to 100,150,0. EXAMPLE CYLINDER IN BOX Create point distribution with regular spaced grid in a cylinder. Make the mesh 3D and 1 cell wide. Connect into a tet mesh. Full LaGriT Command file: lagrit_input_boxincyl.txt # ------------------------------------- # CREATE CYLINDER POINTS # NRAD are number of points along radius # NRAY are number of rays/spokes around # NRING are number of ring sections in z direction # RAD length of radius from the cylinder’s axis # CIRDEG angle around measured from the x-axis # RTOP length along the z-axis from 0. define CYLMAT 2 define NRAD 11 define NRAY 73 define NRING 2 define RAD 14.25 define CIRDEG 360. define RTOP 2. cmo/create/mocyl/ / /tet cmo/select/mocyl createpts/rtz/NRAD,NRAY,NRING/0. 0. 0./ &amp; RAD CIRDEG RTOP /1,1,1 # ------------------------------------- # CREATE INSIDE BOX POINTS define BOXMAT 1 define XMIN -10. define YMIN -10. define ZMIN 0. define XMAX 10. define YMAX 10. define ZMAX 2. define NX 9 define NY 9 define NZ 2 cmo/create/mobox/ / /tet createpts/xyz/NX NY NZ /XMIN YMIN ZMIN /XMAX YMAX ZMAX /1,1,1/ Image of all points Image of all points, some points removed, then connected into tets.",
    "tags": "CREATEPTS xyz rtz rtp line",
    "url": "/pages/docs/commands/createpts/CRTPTSRZ.html"
  },{
    "title": "DEFINE",
    "text": "DEFINE Allows a value to be associated with a character string, such that the character string can be used in input decks in place of the  number. Up to 100 declarations can be defined. The keyword remove in the third argument will remove a defined variable from the stack of defined variables. Each instance of the define command will overwrite the previous assignment. SYNTAX define / name / value_real define / name / value_integer define / name / value_character define / name / remove EXAMPLES define / nx / 3 define / ny / 4 define / nz / 5 define / bottom / 0.1 define / top / 4.0 define / left / 9.8 define / type / reflect surface/s1/reflect/box/0.0,left,bottom/1.0,right,top rz/xyz/nx/nz/0.0,left,bottom/1.0,right,top/1,1,1 define / top / 1.0 define / top / 5.0 surface/s1/reflect/box/0.0,left,bottom/1.0,right,top rz/xyz/nx/nz/0.0,left,bottom/1.0,right,top/1,1,1 define / nx / remove define / ny / remove define / nz / remove",
    "tags": "define variable",
    "url": "/pages/docs/commands/DEFINE.html"
  },{
    "title": "DEREFINE",
    "text": "DEREFINE SYNTAX derefine/minsize/field/pointtype1 pointtype2/refine_type/first_point/last_point/stride/value derefine/merge /first_point / second_point This routine derefines a mesh by deleting points using the merge routine based on one of the following refine_types. edge will refine if element edge length is less then value. volume will merge if element volume is less than value. The merge routine will first attempt the smallest element edge then the next smallest, etc. aspect will derefine where aspect ratio is less than value. pinchedge will allow merging of adjacent points across a thin layer to eliminate the layer where it is too thin. pinchedge should be used only with pointtype1 and pointtype2 both equal to 2. Two criteria are currently enabled; minsize and merge. minsize allows merges if the calculation implied by refine_type is less than value. merge will merge the following first_point and second_point. The field option is not enabled and should be left default. The user specifies which merges are acceptable by designating the allowable pointtypes. Nodes with pointtype1 are merged to nodes of pointtype2. If pointtype1 and pointtype2 are both equal to 2, the code only merges if the nodes are both on the same material interface (use pinchedge if deleted nodes should be on different interfaces of the same material). derefine will not merge if an unacceptable element is created. derefine will work on material interfaces if all the children are set with the settets command. Various combinations of derefine may be used to improve the mesh. recon may be used to return to a delaunay mesh after using the derefine command. EXAMPLES derefine/minsize/0 0/aspect/ 1 0 0/1.e-3 derefine/minsize/0 2/volume/pset,get,apset/5. derefine/minsize/10 10/edge/1 0 0/5. derefine/minsize/2 2/pinchedge/1 0 0/1 derefine/merge/21/22",
    "tags": "derefine, minsize",
    "url": "/pages/docs/commands/DEREFINE.html"
  },{
    "title": "DOPING",
    "text": "DOPING replaced with INTERPOLATE Old command to interpolate between mesh object attributes or assign values to a mesh object attribute. Note: interpolate/map replaces the command doping/integer1 which copied source itetclr values to sink imt values. interpolate/voronoi replaces doping/integer2 which copied nearest node source imt to sink imt. interpolate/continuous evolved from the doping/table command. The interpolate command has newer updates to include attribute selections and expanded options. SYNTAX doping/constant/field_out/set|add|sub/ ifirst,ilast,istride/value doping/gaussian/field_out/set|add|sub/ ifirst,ilast,istride/ xyz/x1,y1,z1/x2,y2,z2/lateral_diffusion/ concentration/standard_deviation/ doping/table/field_out/set|add|sub/cmo_ref/attr_ref/[linear|log|asinh] doping/table/field_out/set|add|sub/cmo_ref/attr_ref/[linear|log|asinh]/ [geom_out/geom_ref] doping/integer1/imt1/set/ifirst,ilast,istride/cmo_ref /imt1/min|max doping/integer2/field_out2/set/ifirst,ilast,istride/cmo_ref/attr_ref/min|max|minp|maxp/[create|use] Options constant and gaussian assign values to a mesh object attribute.  Options table, integer1, and integer2 interpolate from a reference mesh object. The constant option assigns a constant value to all specified nodes. The gaussian option creates a very special gaussian distribution around a line or point.  The bounding box (x1,y1,z1) to (x2,y2,z2) specifies where the peak concentration will be, Note: y2 is ignored; if z1=z2 then the distribution will be around a point.  All coordinates are assumed to be given as Cartesian, xyz is required.  The value assigned to the attribute is determined by the Gaussian distribution: value = concentration * exp(-(L/std_dev) * *2) where L is the effective distance and can be represented as: L = sqrt( dy2 + (1/lateral_diffusion)*(dx2 + dz**2) ) and where dy = y-y1 (y2 ignored) dx = x-x1 if x &lt; x1 &lt; x2 = 0 if x1 &lt; x &lt; x2 = x-x2 if x1 &lt; x2 &lt; x dz similar to dx. The table option interpolates an attribute from a reference mesh object and reference attribute onto the current mesh object using linear, log or asinh interpolation (the default is linear).  In the case of 2D tabular interpolation, additional arguments specify the planar correspondence for the interpolation: geom_out and geom_ref refer to the output and reference orientation of a 2D axial distribution and may take the values, xy, yz, xz,  . In all cases, field_out specifies the name of the attribute, ifirst, ilast, istride specify a point set restriction, and set add or subtract indicate if the calculated or input-value is added to, subtracted from or used to set the existing node attribute value. If the values to be doped (interpolated) are integers (options integer1 and integer2), doping works in two ways.  For integer doping, only the set option is implemented. If the second field is integer1, the new nodal attributes are based on element material types. Set field_out and attr_ref to imt1 in this case. The integer1 option is implemented only for setting node material (imt1). The imt1 values of the active mesh object nodes will be set by determining which element in the reference mesh object the node falls in. This element’s material (itetclr) value is then assigned to the node imt1. The integer2 option sets node based attributes in the active mesh object by determining which voronoi cell in the reference mesh object the node falls in. Then the value for the node corresponding to this voronoi cell is copied to the active node. If the second field is integer2, the new nodal attributes are based on the table attribute types using the Voronoi cells around the table nodes. For integer doping, function can be min or max to choose what happens if a cmo_out node falls on a boundary between two elements or Voronoi cells. For 3d, Voronoi cell based doping, function can also be minp or maxp which makes any cmo_out nodes that fall outside the cmo_table geometry set to the maximum number of materials plus one. Mapset can be set to create, use, or left blank. If create is used then an idop attribute is formed that maps the cmo_table nodes to the cmo_out nodes. If use is used, doping will read and use this previously formed and saved mapping. Note that doping of integers should be done without child/parent relationships. If parents exist, the doping results are unpredictable at interface boundaries because the value of parent nodes are unpredictable there. EXAMPLES doping/constant/density/set/pset,get,mypset/9.73 For the current mesh object, the value of the attribute density will be set to 9.73 for all nodes in the point set mypset. doping/gaussian/density/add/pset,mypset/xyz/0.0,0.5,0.1/0.5,0.5,0.4/0.5/5.0e+18/0.225 For the current mesh object, for nodes in mypset, the value of the attribute density will be augmented by the value of the distribution as defined above. doping/table/my_field/set/1,0,0/cmo_ref/attr_ref/log For the current mesh object, the value of the attribute my_field will be set by interpolating from the reference mesh object and attribute. doping/table/Saturation /set/1,0,0/cmo_course/saturation_course/linear/zx/yx/ In this case the yx plane from the reference cmo is interpolated onto the zx plane of the current mesh object: doping/integer1/imt1/set/1,0,0/cmo_old/imt1/min See which element of cmo_old each node of the current mesh object falls in, and set the imt1 attribute value to the itetclr of the element in cmo_old. If the node falls in more than one element use the smallest itetclr. doping/integer2/rad2/set/1,0,0/cmo_old/rad1/min/create Create the voronoi cells around the nodes in cmo_old. See which voronoi cell the nodes in the current mesh object fall in and set the value of the attribute rad2 from the value of the attribute rad1 in the reference mesh object. If there is a conflict use the smallest value. Create a new attribute called idop as explained above.",
    "tags": "doping, deprecrated",
    "url": "/pages/docs/commands/DOPING1.html"
  },{
    "title": "DUMP",
    "text": "DUMP This command produces an output file from a Mesh Object. Some of the standard graphics packages are supported including AVS, GMV, and TECPLOT. See alphabetic list below for descriptions and syntax. SYNTAX dump / file_type / file_name /[cmo_name]/ dump / file.inp .gmv .lagrit .lg .exo .ts / [cmo_name]/ The dump command is followed by a keyword file_type to indicate the type of file to write. ‘cmo_name’ is the mesh object to write. The second line shows the short form where file_type is recognized by the file name extension as listed below. EXTENSIONS for SHORT SYNTAX              AVS .inp or .avs    GMV .gmv    Exodusii .exo    GoCAD .ts    LaGriT .lagrit or .lg ADDITIONAL FILE TYPES            chad       coord       datex       elem_adj_node       elem_adj_elem       fehm       geofest       geom       pflotran       recolor       stl       stor       tecplot       zone       zone_imt       zone_outside    AVS dump / avs / file_name/ [cmo_name] / [iopt_points, iopt_elements, iopt_node_attributes, iopt_elem_attributes] Will write the AVS UCD (Unstructured Cell Data) file format. avs = avs2 writes data values as real or integer depending on type with spacing dependent on size of values. avs1 = old avs writes all data values as real with large spacing (larger file size). iopt values indicate which data to write or skip, default is everything on with iopt values = 1 1 1 1. For example, dump / avs / file.inp / cmo_name dump / avs / file.inp / cmo_name / 1, 1, 0, 0 dump/ file_name.inp / cmo_name the first line will write node coordinates, element connectivity, and node and element attributes if they exist. The second line will write node coordinates and element connectivity, but not node attributes or element attributes. If iopt_ values = 2, or if iopt_points = 0, then the output will not be a valid AVS UCD format file. These options are provided to enable a user the flexiblity of writing ASCII files with desired information, and are not intended to be used with read/avs or other Applications that read AVS UCD files. A WARNING message is given for non-standard AVS output. The following describe valid iopt_ values. iopt_points is the first section listing node id and their x y z coordinates. = 0 Do not output node coordinate section. = 1 Output node coordinate information (node_id x y z) = 2 Output node coordinates information without node number in first column ( x y z) iopt_elements is the second section listing element id, material, type, node vertices. = 0 Do not output element connectivity information = 1 Output element connectivity information = 3 Output points as AVS pt type for VIS applications. This is only for nodes with 0 elements. iopt_node_attributes are the node attributes listing name, type, node_id and values for each. Note by default the AVS files include the mesh object node attributes imt1, itp1, icr1, and isn1 = 0 Do not output node attribute information = 1 Output node attribute information = 2 Output node attribute information without node id in first column iopt_elem_attributes are the node attributes listing name, type, element_id and values for each. iopt_values_elem = 0 Do not output element attribute information iopt_values_elem = 1 Output element attribute information iopt_values_elem = 2 Output element attribute information without element id in first column Note LaGriT Versions V3.30 and older have the following keyword definitions: avs = All numbers written as reals. att_node = Node Attributes are written as real and integer, header info lines start with # att_elem = Element Attributes are written as real and integer, header info lines start with # For a description of the AVS file format see the read/avs command. CHAD dump / chad / file_name /[cmo_name]/ Will output a file nodes, faces, and connectivity for tet, hex, pyr, or pri in CHAD format. Writes attributes imt and itp. COORD dump / coord / file_name /[cmo_name]/ See also dump/fehm Will output a single file with node list x,y,z values and element connectivity list in FEHM format. Files are written in FEHM format and are described by clicking here for details. The coord file is one of a set of files written when the fehm file type is called. DATEX dump / datex OR simul / file_name / [cmo_name] will output a file with Geometry, Element, Region, Location, and Dataset in DATEX format. ELEM_ADJ_ELEM or ELEM_ADJ_NODE dump / elem_adj_elem / file_name* / mo_name / [ delatt OR keepatt OR attonly ] Option: delatt - Write adjacency information to an ascii file. Write list of all elements adjacent to each element. File format: elem_number ean_num e1 e2 ... en Option: keepatt - write file and add node attribute ean_num (number of elements adjacent to each node) Option: attonly - do not write file, add node attribute ean_num, a dummy argument is still required in the file_name field dump / elem_adj_node / file_name / mo_name Write adjacency information to an ascii file. Write list of all elements adjacent to each node. (-99 is a boundary) File format: node_number number_of_adjacent_elem e1 e2 ... en EXO or EXODUSII dump / exo OR exodusii / file_name / mo_name [ psets ] / [ eltsets] / [ facesets file1 file2 ... filen ] Write a mesh object to a file in the Exodus II format. The keyword psets as token 5 will cause all psets (lists of vertex numbers) associated with the mesh object to be written to the ExodusII output file. The keyword eltsets as token 6 will cause all eltsets (lists of cell numbers) associated with the mesh object to be written to the ExodusII output file. If face set information is being provided from files (file1 file2 ... filen) the format of the file is written in AVS UCD cell attribute format. The first column is the global cell number, the second column is the local face number. Click here for more details on options and files that are written for ExodusII. FEHM dump/ fehm / rootname / cmo_name / [ optional keywords ] Write out a series of files for the FEHM flow and transport code. The tokens after the cmo name are all optional. The following keyword commands are optional and can occur in any order after the cmo name. ascii or binary indicate IO Mode Options for the stor file. Default is ascii. scalar, vector, both, area_scalar, area_vector, or area_both are Area Coefficient Options for writing stor file coefficient values. Default is scalar. all, graph, coefs, or none are Compression Options for the stor file. Default is all. delatt or keepatt deletes or keeps CMO Attributes created to find outside zone nodes. Default is delatt. hybrid or nohybrid Specify whether hybrid median-Voronoi control volumes should be used. Default is nohybrid. The default options will delete the outside node attributes and will not add attributes for the outside voronoi or median areas. The stor file will be written in ASCII format with scalar coefficient values with compression of area coefficient list and indices. The rootname will be used to form full names for the files that are written: rootname.fehmn rootname_interface.zone rootname_outside_vor.area rootname_material.zone rootname_multi_mat.zone rootname_outside.zone rootname.stor .fehm - mesh coordinates and geometry ( see dump/coord/... command) _material.zone - node imt (material) zone lists ( see dump/zone_imt/... command) _outside.zone - node external boundary zone lists (see dump/zone_outside/... command) _outside_vor.area - node external boundary area lists (see dump/zone_outside/... command) _interface.zone - zone lists for nodes along material interfaces _multi_mat.zone - lists of node pairs connected across material interfaces .stor - FEHM format file giving the voronoi (control volume) associated with each node and the sparce matrix structure Click here for more details on the FEHM files and options. Click here for the FEHM style STOR file format. GEOFEST dump/ geofest / file_name Write a file to be read by the GeoFEST, Geophysical Finite Element Simulation Tool hosted by Open Channel Foundation. The output file is ascii. GEOM dump / geom / file_name will write an ascii file containing the geometry information for the current run. This information includes the region and mregion definitions and surface, names, types and definitions. GMV dump / gmv / file_name / [mo_name] / [binary or ascii ] dump/ file_name.gmv / [mo_name] / Write a file to be read by the graphics program GMV. The defaults are binary and current mesh object. Use cmo/setatt//ipolydat/no to reduce file size. This command will keep the polygon data from being written to GMV files. For more on GMV visit: http://www.generalmeshviewer.com GOCAD dump / gocad / file_name Write a gocad TSURF file of triangle elements. LaGriT dump / lagrit / file_name / [cmo_name]/ [binary OR ascii] Write a LaGriT restart file that contains geometry and mesh object information. The geometry belongs to the cmo_name with which it was created. The cmo_name can be -all- in which case all mesh objects are written to the file or it can specify a list of mesh objects to be written. A subsequent read/lagrit command will restart the code at the state at which the dump command was issued. The default file type is binary. PFLOTRAN dump / pflotran / file_name_root / cmo_name / dump / pflotran / file_name_root / cmo_name / nofilter_zero Write coefficient matrix (stor) style values in PFLOTRAN .uge format file. The default dump/pflotran command does not write zero coupling coefficients. Use the keyword nofilter_zero to include zero coupling coefficients in the file. The following is the format used by PFLOTRAN for .uge (explicit unstructured grid) file. The first block are the list of ids of cells and the coordinates of cell centroids and the volumes of the cells. The PFLOTRAN cells are Voronoi volumes, one for each node. CELLS &lt;integer&gt; integer = # cells (N) id_1 x_1 y_1 z_1 volume_1 d_2 x_2 y_2 z_2 volume_2 ... ... id_N x_N y_N z_N volume_N The second block consists of a list of ids of the connecting cells (id_up, id_dn), coordinates of the face centroid between the two connected cells and areas of the faces. CONNECTIONS &lt;integer&gt; integer = # connections (M) id_up_1 id_dn_1 x_1 y_1 z_1 area_1 id_up_2 id_dn_2 x_2 y_2 z_2 area_2 ... ... id_up_M id_dn_M x_M y_M z_M area_M RECOLOR dump / recolor / file_name This command writes the existing colormap to the specified file. See colormap command STL dump / stl / file_name Output in STL, stereo lithography format. This is only supported for triangle mesh objects. STOR dump / stor / file_name_root / cmo_name / [ascii OR binary ] / [scalar OR vector OR both OR area_scalar OR area_vector OR area_both] \\ [all OR graph OR coefs OR none] / [hybrid OR nohybrid ] Same syntax as dump/fehm except the only output is the FEHM sparse matrix coefficient STOR file rootname.stor. File can be written in ascii or binary (fortran unformatted platform dependent). The area coefficient values can be written as scalar or vector. The compression default is all which will compress both the list of area coefficients and the indices. The coefs compression, or none compression both use and older algorithm and will result in larger files and may take longer to run. The stor file is one of a set of files written when the fehm file type is called. Click here for further explanation of syntax options. Click here for the FEHM style STOR file format. TECPLOT dump / tecplot / file_name Write a file to be read by the Tecplot graphics package. The output file is ascii. Only node attributes are output, element attributes are ignored and not output. Tecplot does not support prism or pyramid element types so they are written as eight node, degenerate hex elements. The ioflag parameter is used to control if the node attributes are output or not is the AVS ioflag. The expected suffix for the file name is .plt. If a name is given without the .plt suffix, a suffix “.plt” is added. Output is ascii. This output format does not support output of a mesh with nodes but zero elements. If there are zero elements, a header is written but node coordinate information is not output. ZONE dump / zone / file_name/ [cmo_name] / [delatt OR keepatt] [keepatt_voronoi OR keepatt_median] Write out a set of fehm format zone files for the mesh object nodes. These include zones for mesh materials and the external faces of the mesh as described below. The keepatt option will keep node attributes that tag nodes on external mesh boundaries (see zone_outside). The delatt option will delete the outside attributes if they exist (the are removed by default). The area attributes for outside nodes can be created with the keepatt_voronoi or keepatt_median options (see zone_outside). Files are written in FEHM format and are described in the dump/fehm command by clicking here for details. The file_name is used to create names for the following 5 files: file_name_material.zone - node imt (material) zone lists (see dump/zone_imt/... command) file_name_outside.zone - node external boundary zone lists (see dump/zone_outside/... command) file_name_outside_vor.area or file_name_outside_med.area - node external boundary area lists (see dump/zone_outside/... command) file_name_interface.zone - zone lists for nodes along material interfaces, 0 length file if mesh is single material file_name_multi_mat.zone - lists of node pairs connected across material interfaces, 0 length file if mesh is single material dump / zone_imt / file_name / [cmo_name] / [ imt_value ] will output only one file with name file_name_material.zone. It is written in FEHM zone format and are described by clicking here for details. file_name_material.zone is node list for each integer material (imt) value. If the optional fifth argument is specified as an integer, then a node list file is written only listing the nodes with the value specified by imt_value. For options to output PSET’s as ZONE/ZONN files see PSET. The zone_imt file is one of a set of files written when the fehm file type is called. dump / zone_outside OR zone_outside_minmax / file_name /[cmo_name] / [delatt OR keepatt] [keepatt_voronoi OR keepatt_median] Write fehm zone format files that contain the outside node list and the associated outside area list. There are two files written: file_name_outside.zone is a node list for each of 6 possible external boundaries. If keepatt is specified, then 6 node based attributes are added to the mesh object with the names bottom, top, right_e, back_n, front_s, and left_w. A node can occur in multiple zones. For instance, a node located on a top corner of the mesh can be found in zones for top, front_s, and left_w. 1 = top = top = positive z direction (0,0,1) 2 = bottom = bottom = negative z direction (0,0,-1) 3 = left_w = left or west = negative x direction (-1,0,0) 4 = front_s = front or south = negative y direction (0,-1,0) 5 = right_e = right or east = positive x direction (1,0,0) 6 = back_n = back or north = positive y direction (0,1,0) file_name_outside_vor.area is a list of Voronoi area vectors (Ax_i,Ay_i,Az_i) associated with each external node. It is written to match the node lists as written in the outside.zone file. Along with each outside zone tag (such as top), there is a sum of each vector for that zone. For applications such as infiltration, the z component (each 3rd value) would be used from the top zone list. 00001 top Sum VORONOI vectors: 0.5000000E+00 0.5000000E+00 0.5000000E+00 nnum 3 -2.500000000000E-01 -2.500000000000E-01 2.500000000000E-01 2.500000000000E-01 0.000000000000E+00 1.250000000000E-01 0.000000000000E+00 2.500000000000E-01 1.250000000000E-01 If the keyword keepatt_voronoi is specified, three node attributes (xn_varea, yn_varea, zn_varea) representing the voronoi area are added. If the keyword keepatt_median is specified, three node attributes (xn_marea, yn_marea, zn_marea) representing the median area are added and the file name will be file_name_outside_med.area. Note that the old version file name file_name_outside.area has area vectors computed with the median strategy. The option zone_outside_minmax is used to find the min and max external node along each row and column of a regular structured grid where the index for i, j, and k can be detirmined. The node attributes i_index, j_index, and k_index are created. Click here for an image showing difference between the default and the minmax options for outside nodes. These zone_outside files are part of a set of files written when the zone or fehm file type is called. The fehm zone format and descriptions are in the dump/fehm command details. EXAMPLES: dump / gmv /file_name.gmv/cmo_name/ dump / gmv /file_name.gmv/cmo_name/ascii dump / file_name.gmv / cmo_name dump / tecplot /file_name.plt/cmo_name dump / lagrit /file_name.lg/-all-/binary dump/file_name.inp/cmo_name dump / avs /file_name.inp/cmo_name dump / avs /file_name.inp/cmo_name/1 0 0 0 (output only node coordinates) dump / avs /file_name.inp/cmo_name/1 1 0 0 (output node coordinates and element connectivity) dump / avs /file_name.inp/cmo_name/0 0 0 1 (output element attributes) dump / avs /file_name.inp/cmo_name/0 0 2 2 (output node and element attributes without node numbers as first column of output) dump / avs2 /file_name.inp/cmo_name/1 1 1 0 (output node coordinates, element connectivity and node attributes) dump / fehm /file_root/cmo_name/ (write ascii compressed STOR file and full set of fehm input files) dump / stor /file_root/cmo_name/ (write ascii compressed STOR file) dump / stor /file_root/cmo_name/ binary (write unformatted compressed STOR file - platform dependent) dump / stor /file_name/cmo_name/ascii/area_scalar dump / zone_outside /file_root/cmo_name/keepatt (write outside node zones and voronoi areas, keep outside attributes) dump / zone_outside /file_root/cmo_name/keepatt_voronoi (write outside node zones and keep Voronoi area attributes) dump / zone_outside_minmax /file_root/cmo_name (write outside nodes at minmax extent of each column) dump / zone /file_root/cmo_name/ delatt keepatt_voronoi (write all FEHM zone and area files, delete the outside attributes and keep the voronoi area attributes) dump/ exo / file_name / cmo_name Write generic exodus output without any sets. dump/ exo / file_name / cmo_name / psets Write exodus output with point sets only. dump/ exo / file_name / cmo_name / / eltsets Write exodus output with element sets only. dump/ exo / file_name / cmo_name / / / facesets Write exodus output with face sets only. The facesets are internally calculated and defined. Note that the algorithm is computationally expensive and can take a long time to finish. dump/ exo / file_name / cmo_name / / / facesets file1,file2,...,filen Write exodus output with face sets only. The face sets are imported from file1, file2, …, filen. dump/ exo / file_name / cmo_name / psets / eltsets / facesets file1,file2,...,filen Write exodus output with all psets, element sets, and face sets. The face sets are imported from file1, file2, …, filen. Click here for demos",
    "tags": "write output files",
    "url": "/pages/docs/commands/DUMP2.html"
  },{
    "title": "DUMP/FEHM and DUMP/STOR",
    "text": "DUMP/ fehm DUMP/ stor Output a set of files that are of general use but are specifically designed for the FEHM porous flow and transport code. Both commands dump/fehm and dump/stor use the same set of optional settings after the required file root name and cmo name. The keyword fehm writes the full set of 7 FEHM files. The keyword stor writes a single FEHM sparse matrix stor file. OUTPUT FILES: The root will be used to form full names for the files that are written: rootname.fehmn rootname_interface.zone rootname_outside_vor.area rootname_material.zone rootname_multi_mat.zone rootname_outside.zone rootname.stor .fehmn is a list of mesh object node x,y,z values and the element connectivity list in ASCII FEHM format (also dump/coord/… command). _material.zone is a file with a node list for each integer material (imt) value (also dump/zone/imt/… command). _interface.zone is output of FEHM zone format files of nodes along an interface where interface is defined as a node to node connection where the integer attribute imt changes. Note this file will have 0 length if there is only one material. _multi_mat.zone is a list of multi-material connections, where multi-material is defined as a node to node connection where the integer attribute imt changes. Each list consists of a header followed by the list of node pairs. The header consists of the material number followed by “multi-material connections” on the same line, followed by “nnum” (nedges) on the next line, followed by the number of entries in the list. The list of node pairs are written where first node is inside the current material and the second is the connected node on other side of material interface. The lists are sorted by the first node. Note this file will have 0 length if there is only one material. _outside.zone is a list of each node located on the outside areas. If the keyword keepatt is included, then 6 node based attributes are added to the mesh object with the names top, bottom, left_w, right_e, back_n, and front_s. Note that a node can belong to more than 1 zone list. For example, in an orthogonal cube aligned with the coordinate axes, a corner node can belong to 3 zone lists (e.g. front_s, top and left_w lists). By default, these node attributes are deleted after the zone file is written and the mesh object remains unchanged. (also dump/zone_outside/… command). These outside zones are defined as 6 possible external boundaries for rectangular geometries and are defined as: 1 = top = top = positive z direction (0,0,1) 2 = bottom = bottom = negative z direction (0,0,-1) 3 = left\\_w = left or west = negative x direction (-1,0,0) 4 = front\\_s = front or south = negative y direction (0,-1,0) 5 = right\\_e = right or east = positive x direction (1,0,0) 6 = back\\_n = back or north = positive y direction (0,1,0) _outside_vor.area (default) or _outside_med.area uses outside nodes to write a list of 2D area or 1D length vectors (Ax_i,Ay_i,Az_i) associated with each and listed the same order as zones and nodes in the file root_name_outside.zone. optional keyword keepatt_voronoi will keep the attributes created for outside voronoi areas. Three node attributes (xn_varea, yn_varea, zn_varea) are added and they contain the vector area associated with the voronoi areas for each of the nodes located on their external triangles. optional keyword keepatt_median will keep the attributes created for outside median areas. Three node attributes (xn_marea, yn_marea, zn_marea) are added and they contain the vector area associated with the median area for each of the nodes located on their external triangles. These area vectors are computed by computing the median mesh (triangle centroids connected to triangle edge centers)  If the input mesh are 2D triangles, the median length of external edges incident upon a node are written. .stor is geometric coefficient matrix written in FEHM stor file format. These are the Voronoi (control volume) area and volume associated with each node and the sparse matrix structure. ASCII compressed is the default file output. The stor file represents a sparse coefficient matrix and is used for solving PDE on a triangular or tetrahedral Delaunay mesh. The stor format is written for FEHM input and is described at this page:    FEHM STOR File Format FORMAT: Simple: dump / fehm / root_name / cmo_name dump / stor / root_name / cmo_name The root_name will be used to form names for all files written. dump/fehm will write full set of FEHM input files including a stor file dump/stor will write a sparse matrix stor file only (default is ASCII compressed scalar) Optional Keywords: The following command settings are optional and can occur in any order after the cmo_name. ascii or binary  indicate IO Mode Options for the stor file. Default is ascii. scalar, vector, both, area_scalar, area_vector, or area_both are Area Coefficient Options for writing stor file coefficient values. Default is scalar. all, graph, coefs, or none are Compression Options for the stor file. Default is all. delatt or keepatt deletes or keeps CMO Attributes created to find outside zone nodes. Default is delatt. hybrid or nohybrid Specify whether hybrid median-Voronoi control volumes should be used. Default is nohybrid. STOR IO MODES: binary Output sparse matrix stor file in Fortran unformatted format Note: These files are platform dependent.  ascii (default)  Output sparse matrix stor file as ASCII format. This is a larger file but not machine dependent. STOR Area Coefficient OPTIONS: scalar (default)  Area/distance               coefficients are output as scalars  vector Area/distance               coefficients are output as vectors  both Area/distance               coefficients are output as scalars and vectors  area_scalar Area                        coefficients are output as scalars area_vector Area                        coefficients are output as vectors  area_both  Area                        coefficients are output as scalars and vectors  STOR Compression OPTIONS: all (default) (_astor) compression of area coefficients and compression of coefficient indices graph (_gstor) compression of area coefficient indices (edge compression)   coefs (_cstor) compression of area coefficient to a list of unique values. Note: This older algorithm uses more space and time. none (_nstor) full indices and area coefficient list. Note: This older algorithm uses more space and time. The attributes ccoef and ij_ccoef may be added if negative area coefficients are detected when the _astor or _gstor compression algorithms are invoked (default) or by using the all or graph keywords, these two new attributes are added to the CMO. Since the area coefficients are really edge based quantities but we only have access to node and element quantities, the following convention is used. If any area coefficient is negative the integer node array ij_ccoef and real node array ccoef are created. All connections with area coefficients &gt;= 0 are set to zero in these attributes, so values will range from the largest negative value to 0. This is not implemented for 2D and there is no option to turn this feature on or off. If no area coefficients are negative the arrays are not created. If the area coefficient A_ij, between nodes i and j is negative then ccoef(i)    = ccoef(j) = A\\_ij ij\\_ccoef(i) = j ij\\_ccoef(j) = i Note: The old syntax using the alternate_scalar keyword is now the default option using scalar and compressed. It is the same as using keywords all or graph and if used will be recognized. CMO Attributes for outside zones: delatt (default) No new cmo attributes are created. keepatt Six node attributes are created (top, bottom, left_w, right_e,back_n, front_s) which are assigned values according to the direction of the octant of their normal vector. Each outside node can occur in multiple directions. For instance an edge between top and left side will be in both top and left_w attributes. Attribute values greater than 0 are nodes found in that direction. STOR Hybrid OPTIONS: nohybrid (default) Do not use hybrid median-Voronoi control volumes hybrid Use hybrid median-Voronoi control volumes. These hybrid volumes represent a means for addressing poorly shaped tetrahedra on a boundary of the mesh. Boundary tetrahedra whose Voronoi centers are outside the mesh lead to incorrect modeling results. Alternatively, if we construct control volumes using medians (centroids), the center point for each element always lies within that element, but median meshes lack other nice properties of Voronoi meshes. As a compromise between the median and Voronoi approaches, we start with a Voronoi mesh and fix boundary tetrahedra whose circumcenters are not contained within the boundary of the mesh. To fix such an element, we draw a line segment from the median center to the Voronoi center and find the point at which this segment intersects the surface of the element. This intersection then becomes the center point for the purposes of determining control volumes. Essentially we move the Voronoi center toward the median point until it just reaches the element. When we use the hybrid approach, we also make a slight change to the way we calculate the area coefficients. Voronoi control volumes have the property that their faces are always perpendicular to the mesh edges that intersect them. With hybrid control volumes (as well as median control volumes), this is not the case. To compensate for this, when we compute the area coefficient we only consider the component of the face area vector which is in the same direction as the edge. We accomplish this by taking the area vector and dotting it with a unit vector in the direction of the edge. The hybrid option may lead to poor results if it is applied to a mesh that is non-Delaunay, because there may be elements which it cannot fix, such as interior elements whose circumcenters are outside the mesh. A warning will be printed if the code detects that the mesh appears to be non-Delaunay. NOTE: The hybrid option is only available with the default implmentation using no other options or including all, graph, and scalar in the command. EXAMPLES: dump / fehm / file_name / cmo (write all FEHM files, STOR file will be ascii compressed) dump / stor / file_name / cmo (write the FEHM STOR file in ascii compressed format) dump / fehm / file_name / cmo / binary / none (write all FEHM files, STOR file will be unformatted compressed) dump / stor / file_name_as / cmo / ascii / none / vector (write ascii STOR file with vector coefficients) dump / stor / file_name_as / cmo / ascii / none / area_scalar (ascii STOR file with area coefficients without distance) OLD EXAMPLES (recognized but no longer used): dump / stor / file_name_as / cmo / ascii / / alternate_scalar dump / stor / file_name_as / cmo / asciic / / alternate_scalar dump / fehm / file_name / cmo / binaryc / / alternate_scalar/ keepatt",
    "tags": "",
    "url": "/pages/docs/commands/dump/DUMP3.html"
  },{
    "title": "DUMP_RECOLOR",
    "text": "DUMP_RECOLOR This command is similar to the regular dump command except that the mesh object is recolored before being dumped.  There are two options specific to this version.  If restore is specified  (the default), the original itetclr and imt1 values are restored, leaving the mesh object unaltered.  If norestore is specified the mesh object is left recolored (and the original values of itetclr and imt1 lost).  If create is specified (the default) then a new colormap is created and used to recolor.  Otherwise if existing is specified, the existing colormap is used to recolor the mesh object.  Three dump types are available:  “gmv”, “LaGriT” and “avs”. iomode can be ascii or binary; binary is the default. SYNTAX dump_recolor/type/file/mo/[restore or norestore/create or existing /imode EXAMPLES dump_recolor/gmv/mesh.gmv**/ascii Writes an ascii gmv dump to the fine mesh.gmv.  The mesh object that is dumped is the current mesh object recolored according to its own material adjacency. dump_recolor/gmv/mesh.gmv/norestore/existing Recolors the current mesh object using the existing colormap and then writes a binary gmv dump to the fine mesh.gmv.",
    "tags": "dump_recolor",
    "url": "/pages/docs/commands/DUMP_RECOLOR.html"
  },{
    "title": "EDIT",
    "text": "EDIT SYNTAX edit / iopt / ifirst,ilast,istride / material_# or name/ edit/ angular /ifirst,ilast,istride /material_# or name/xcen edit/radial /ifirst,ilast,istride /material_# or name/xcen edit/ points /ifirst,ilast,istride /material_# or name/array1,array3,array4/ Prints an edit of various quantities based on the value of the option argument, the point limits, and/or a material specification. iopt specifies what to print as follows: no value for iopt –edit of sums, averages, and extrema of position coordinates (x,y,z), and of mesh object attribute fields cwo gives same information as the default, but only for the two points specified. parts gives a list of materials types, their names, count and sequence. points lists up to 4 cell-center array values for a set of points. Possible array values are: xic,yic,zic,or mesh object attribute name   EXAMPLES edit/ parts/ edit/point /pset,get,mypoints/",
    "tags": "edit",
    "url": "/pages/docs/commands/EDIT2.html"
  },{
    "title": "ELTSET",
    "text": "ELTSET (Element Set) Associate a name with a element set based on various selection criteria and logical operators. Output element sets. By convention, ifirst,ilast,istride syntax represents a set selection defined either by a set of elements from ifirst to ilast, with increments of istride (1 by default). A set selection can also be defined with eltset,get, eset_name where eset_name has been defined by the following eltset commands. Most commands with the syntax ifirst,ilast,istride can also use eltset,get, elset_name. The following are the syntax and parameter definitions, click on options in table or scroll down the page.       attribute_name delete list logicals pset region quality volume quality aspect write attribute_name eltset/eset_name/ attribute_name /eq or ne or lt or gt or le or ge /value/ forms an eltset from elements in attribute_name that compare to value. The comparators are eq equal to, gt greater than, lt less than, ge greater than or equal, le less than or equal to, ne not equal. delete eltset/eset_name/ delete removes a previously define element set from current mesh object list eltset/eset_name/ list eltset / / list list all elements in eset_name. If the 2nd argument is empty, list all names all of eltsets for the mesh object logicals eltset/eset_name/ union inter not / eset_list/ logical operations union, inter and not act on previously defined eltsets. The definition of the unary operator not is extended such that not/e1/e2 means e1 and (not(e2)). pset eltset/eset_name/ inclusive or exclusive or face /pset,get, pset_name/ forms an eltset from nodes in a pset with name pset_name. The following criteria are used to define which elements node set are included. The selection criteria is required. inclusive all elements any of whose nodes is in pset, if a node is on any element, include it. Generally the largest selection. exclusive all elements all of whose nodes are in pset, all nodes of an element must be in the set. Generally a smaller selection. face elements if all nodes of a face are in pset region mregion eltset/eset_name/ region or mregion / region_name / will return all nodes that are in the specified geometry region or material mregion given by its region_name. This command calculates the center of mass of the element and determine which mregion or region the center lies in. It is possible if the interface surfaces are curved that the center will not lie in the same material or geometry region as the vertices. Using values of itetclr may give the better result. volume aspect eltset/eset_name/ volume/ eq or ne or lt or gt or le or ge /value eltset/eset_name/ aspect/ eq or ne or lt or gt or le or ge /value forms an eltset based on the quality criteria volume or aspect ratio. The value and comparator detirmines the set selection. write eltset/eset_name or -all- / write /file_name[.cellset]/ ascii or binary write or dump an element list with name eset_name to a file, options are ascii or binary. The argument -all- will write all eltsets in the mesh object. EXAMPLES eltset/element_set1/itetclr/eq/4 eltset/element_set2/face/pset/get/mypset eltset/element_set3/inclusive/pset/get/mypset eltset/element_set4/region/upper eltset/element_set5/volume/lt/3.0 eltset/element_set5/delete eltset / / list These are various examples of the eltset command. cmo / select / mo_hex intersect_elements / mo_hex / mo_wells / if_inter eltset / e_refine / if_inter / gt / 0 refine/ eltset / eltset,get,e_refine cmo / setatt / mo_hex / if_inter / 1,0,0 / 0 eltset / e_refine / delete This set of commands will intersect mesh object named mo_hex with mesh object named mo_wells. The attribute if_inter is created by intersect_elements and has a non-zero value for elements intersected by mo_wells. The selected set is refined. It is good practice to clean up if using names and attributes over again. Here we set if_inter values to 0 and remove the element set when we are done.",
    "tags": "element set eltset",
    "url": "/pages/docs/commands/ELTSET2.html"
  },{
    "title": "dump exo",
    "text": "DUMP / EXO Write a mesh object to a file in the ExodusII format. This command can be used to define ExodusII blocks (itetclr), node sets (psets), element sets (eltsets), and side sets (facesets). The facesets are commonly used to define faces on the external mesh to define boundary conditions. The command extract/surfmesh can be used to extract the mesh boundary surface and create the faceset attributes to define in an ExodusII mesh file. NOTE: ExodusII requires that elements are ordered by their block ID (element itetclr value). ExodusII routines will automatically sort by these values, so we pre-sort before calling dump/exo so that element and node numbering is consistent with any set definitions. Both Paraview (sets) and GMV (surfaces) can be used to view ExodusII mesh files with face sets. See Examples below for more on writing ExodusII files with LaGriT. SYNTAX dump/exo/file_name/cmo_name dump/exodusii/file_name/cmo_name dump/exo/file_name/cmo_name [psets] / [eltsets] / [facesets] [file1 file2 ... filen ] file_name and cmo_name are the names of the ExodusII file and mesh object to write. psets Dump ExodusII file with vertex sets. The keyword psets as token 5 will cause all psets (lists of vertex numbers) associated with the mesh object to be written to the ExodusII output file. eltsets Dump ExodusII file with element sets. The keyword eltsets as token 6 will cause all eltsets (lists of cell numbers) associated with the mesh object to be written to the ExodusII output file. facesets file1 file2 ... filen If face set information is being provided from files (file1 file2 … filen) the format of the file is written in AVS UCD cell attribute format. The first column is the global cell number (idelem1), the second column is the local face number (idface1). Listing file facesets avoids automatic facesets generated for all psets and eltsets. Only the facesets in the files listed in the command will be used to define facesets. See examples below. LIMIT ON FILENAMES: If a command line maximum length is 16384 characters, and if the faceset file names have 12 characters (face0001.inp), you can run dump/exo with about 1300 faceset files before running out of command line space. facesets (no file list) Dump ExodusII file with face sets (ExodusII side sets). If no files are listed, the face sets will be automatically generated. Note facesets will be created for all the nodes in each pset, and for all elements in each eltset. This can generate a large number of facesets. EXAMPLES # sort based on cell itetclr id and cell centers createpts / median sort / MO_MESH / index / ascending / ikey / itetclr xmed ymed zmed reorder / MO_MESH / ikey dump/exo/hex.exo / MO_MESH ExodusII will sort elements by their block ID (element itetclr value), do a pre-sort so element numbering is consistent with the written ExodusII file. This example calls the sort command using the element itetclr values and element median points (xmed, ymed, zmed). The reorder command will order the elements based on the ikey ordering. No vertex set, element set or face sets are written for this mesh. dump/exo/ prism_fs.exo / moprism / / / facesets &amp; fs_001.faceset, fs_002.faceset, fs_003.faceset, fs_004.faceset &amp; fs_005.faceset, fs_006.faceset, fs_007.faceset Write an ExodusII file for a prism mesh with 7 facesets as defined in 7 AVS attribute files. dump / exo / out_2D_tri_pset_eltset.exo / motri / psets / eltsets / dump / exo / out_2D_tri_pset.exo / motri / psets / / dump / exo / out_2D_tri_eltset.exo / motri / / eltsets / This example mesh object has both psets and eltsets defined before the dump command. The first line writes an ExodusII file with vertex set, element set and no face set. The second line writes an ExodusII file with vertex set, and no element set and no face set. The third line writes an ExodusII file with a element set, no vertex set, and no face set. DEMO EXODUSII WITH FACESET FILES ON BOUNDARY This Demo includes a full set of input files to create a stacked mesh, define boundary facesets, and write the ExodusII file. Demo Web Pages: ExodusII face sets from Boundary Polygon DEMO EXODUSII FACESET FILES ON CUBE The following creates a cube shaped hex mesh then writes an ExodusII file with top and bottom facesets. Input LaGriT command file: write_cube_exo_facesets.lgi The hex mesh is created with createpts and assigned 2 materials to the itetclr array. The mesh elements are sorted by the itetclr values and median xmed, ymed, zmed points. This will ensure that element and face numbers are consistent with ExodusII requirements. After sort and reorder the mesh boundary faces are extracted into a mesh object using extract/surfmesh The surface mesh is subset into regions representing the top, bottom, and side boundaries defined by the 6 normal directions set by command settets/normal where itetclr is set to 1 (down), 2 (up), 3 (right), 4 (back), 5 (left), and 6 (front). # Get top faces and write faceset file cmo / copy / mo_tmp / mo_surf cmo / select / mo_tmp eltset / e_top / id_side / eq / 2 eltset / e_delete / not / e_top rmpoint / element / eltset get e_delete rmpoint / compress cmo / DELATT / mo_tmp / id_side dump / avs2 / output_2_top.faceset / mo_tmp / 0 0 0 2 cmo / printatt / mo_tmp / idelem1 cmo / printatt / mo_tmp / idface1 cmo / delete / mo_tmp The itetclr values are saved into new attribute id_side and are used to select and subset the surface mesh to top faces with the value 2. The faceset file named “output_2_top.faceset” is written. The format of the AVS faceset file includes the list of element-face relationships written in AVS UCD cell attribute format. The first column is the global cell number, the second column is the local face number. Subset the surface into sets such as top and bottom, write faceset files from each set. File output_1_bottom.faceset: File output_2_top.faceset: 0 0 0 2 0 0 0 0 2 0 00002 1 1 00002 1 1 idelem1, integer idelem1, integer idface1, integer idface1, integer 2 1 1 2 5 1 3 2 7 1 4 2 8 1 6 2 These are the first lines of each faceset file for top and bottom showing the AVS format and values written. dump / exo / output_hex_final.exo / mohex / / / facesets &amp; output_1_bottom.faceset output_2_top.faceset The faceset files can be listed in the dump/exo command. Note the ExodusII ID for each set will be in the same order as the file names, ie first file will be given set ID=1, the second will have set ID=2. The ExodusII file is written as a binary file and can be read by various visualization software such as GMV and Paraview. For documentation on the ExodusII API see http://gsjaardema.github.io/seacas/exodusII-new.pdf The NetCDF utility ncdump can be used to convert the binary to ASCII file for checking that all mesh sections are written as expected. The result is an ExodusII binary mesh with 2 block materials and 2 side sets as reported in the LaGriT output: dump/exo/output_hex_final.exo/mohex///facesets output_1_bottom.faceset output_2_top.faceset got 1 output_1_bottom.faceset got 2 output_2_top.faceset ExodusII: Start writing to file: output_hex_final.exo using cmo: mohex Exodus FACESETS imported from files. 2 Total read: 4 Current offset: 0 Set tag: 1 nfaces: 4 first: 2 1 last: 8 1 Set new offset: 4 Total read: 8 Current offset: 4 Set tag: 2 nfaces: 4 first: 1 2 last: 6 2 Set new offset: 8 Title: LAGRIT TO EXODUSII number of dimension: 3 number of nodes: 27 number of elements: 8 number of edges: 0 number of edge blocks: 0 number of element blocks: 2 number of face blocks: 0 number of node sets: 0 number of edge sets: 0 number of element sets: 0 number of side sets: 2 number of face sets: 0 number of node maps: 0 number of edge maps: 0 number of face maps: 0 number of element maps: 0 ------------------------------------------ EXPSS loop: 1 Side Set tag: 1 Faces: 4 2 Side Set tag: 2 Faces: 4 ------------------------------------------ Done ExodusII Side Sets Total: 2 ExodusII: Done writing to ExodusII file: output_hex_final.exo using cmo: mohex DEMO USING PSETS AND ELTSETS Input LaGriT command file write_exo_pset_eltset.lgi This command file is an example for writing psets/eltsets, both defined in the mesh object before writing the file. Note all psets and eltsets defined in the mesh object will be written to the ExodusII file. dump/exo/out_2D_tri_pset_eltset.exo/motri/psets/eltsets/ ExodusII: Start writing to file: out_2D_tri_pset_eltset.exo using cmo: motri Title: LAGRIT TO EXODUSII number of dimension: 2 number of nodes: 16 number of elements: 18 number of edges: 0 number of edge blocks: 0 number of element blocks: 3 number of face blocks: 0 number of node sets: 3 number of edge sets: 0 number of element sets: 3 number of side sets: 0 number of face sets: 0 number of node maps: 0 number of edge maps: 0 number of face maps: 0 number of element maps: 0 WRITING EXODUS NODE SETS: 3 sets in total Nodeset Names Set ID # nodes in set p1 1 13 p2 2 7 p3 3 11 WRITING EXODUS ELEMENT SETS: 3 sets in total Elemset Names Set ID # elements in set e1 1 9 e2 2 3 e3 3 6 ExodusII: Done writing to ExodusII file: out_2D_tri_pset_eltset.exo using cmo: motri Using ncdump command, the binary ExodusII file can be converted for viewing the psets (node_ns) and eltsets (elem_els): node_ns1 = 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ; node_ns2 = 2, 3, 5, 6, 11, 12, 15 ; node_ns3 = 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 14 ; elem_els1 = 1, 2, 3, 4, 5, 6, 7, 8, 9 ; elem_els2 = 10, 11, 12 ; elem_els3 = 13, 14, 15, 16, 17, 18 ;",
    "tags": "dump, exo, exodus, sort",
    "url": "/pages/docs/commands/EXODUS.html"
  },{
    "title": "EXTRACT",
    "text": "EXTRACT This command produces a 2D mesh object from a 3D mesh object. A material interface, a plane , an isosurface or a network may be extracted. The output mesh object will be oriented such that the outward normal of the plane that defines the surface will point in the same direction as the normals for the triangles in the output MO. If the command extracts on an isosurface, the output MO will be oriented such that the normals for the triangles point in the direction of increasing field. If the command extracts on an interface, the output MO triangles will be oriented the same as the triangles extracted from region1 of the input MO. In the case of a plane extracted along all or a portion of a material interface, only those points that lie inside the material (i.e.: away from the direction of the normal) will be picked up. If the extraction is on a boundary, the normal to the extraction plane must point out of the material in order for points to be picked up. SYNTAX extract/ plane /threepts / x1,y1,z1/x2,y2,z2/x3,y3,z3/1,0,0/cmoout/cmoin extract/plane/ ptnorm / x1,y1,z1/xn,yn,zn/1,0,0/cmoout/cmoin extract/plane/ axes / xv,yv,zv/1,0,0/cmoout/ extract/plane/ abcd / a,b,c,d/ 1,0,0/cmoout/cmoin extract/isosurf / attribute/value/ 1,0,0/cmoout/cmoin extract/intrface / region1/1,0,0/cmoout/cmoin extract/intrfac2 / region1/region2/1,0,0/cmoout/cmoin extract/network / 1,0,0/cmoout/cmoin extract/surfmesh / 1,0,0/cmoout/[cmoin] [external] The following options are available: plane/threepts/ plane may be defined by three points in the plane x1,y1,z1/x2,y2,z2/x3,y3,z3 plane/ptnorm/ plane defined by vector normal to the plane x1,y1,z1 and xn,yn,zn plane/axes/ three points on the axes of the space xv,yv,zv plane/abcd/ a,b,c,d are the coefficients of the plane equation ax+by+cz=d isosurf/ An isosurface is defined by the value of the surface and the attribute to test for this value. intrface/ An interface is defined by the material(s) bounding the interface region1 intrfac2/ region1 [region2] are the material numbers or the material region (mregion) names whose interface is to be extracted. Use -all- to extract from all interfaces. network A network is defined as the material interface network from the mesh object. Unlike the other extract forms, this extracts the “parent” interface and not the “child” interface, and ignores boundaries. The output cmo also contains a new attribute “map” which maps nodes in the output cmo to (parent) nodes in the input cmo. This is supposed to work for 2D meshes (tri, quad, or hybrid) in 2D or 3D and 3D meshes (tet, pyr, pri, hex or hybrid). surfmesh extracts the boundary and interface surfaces of a mesh. The keyword external will not extract interior interfaces. See full description at extract/surfmesh. cmoout and cmoin are the new output mesh object name and source input mesh object name. 1,0,0 is the range ifirst, ilast, istride selection to work on. EXAMPLES extract/plane/threepts/0.,50.,0./1.,50.,0./1.,50.,1./1,0,0/2dmesh/mo_mesh define / XVEC / 1.0 define / YVEC / 2.0 define / ZVEC / 3.0 extract /plane /ptnorm/ XP YP ZP / XVEC YVEC ZVEC / 1 0 0 / mo_extract / mo_hex extract / isosurf / dfield_1 / 0.0 /1,0,0/ mo_iso1 / mohex DEMO cmo/create/3dmesh/ * add an attribute to contain a field for refinement and extraction cmo/addatt/3dmesh/boron cmo/modatt/3dmesh/boron/ioflag/gx/ cmo/modatt/3dmesh/boron/interp/linear/ *  simple unit cube divided into 2 region by a horizontal plane surface/cube/reflect/box/.0,.0,.0/1.,1.,1./ surface/mid/intrface/plane/0.,0.,.5/1.,0.,.5/1.,1.,.5/ region/r1/ le cube and le mid / mregion/m1/ le cube and lt mid / region/r2/ le cube and gt mid / mregion/m2/ le cube and gt mid / * start out with just a few nodes createpts/xyz/3,3,3/0.,0.,0./1.,1.,1./1,1,1/ setpts search settets * put some values on the field doping/gaussian/boron/set/1,0,0/xyz/0.0,0.0,0.0/1.,0.,0./0.5/ &amp; 3.23e+20/0.063/ * use refine to add more detail - note only linear interpolation * between the few original nodes - one would never really do this without * recalculating the field on the finer mesh refine/maxsize///edge/1,0,0/0.01,0.0,0.0/ recon refine/constant/boron/linear/edge/1,0,0/1.3+20/ recon * extract a plane extract/plane/threepts/0.,0.,0./1.,0.,0./1.,0.,1./1,0,0/2dmesh/3dmesh pset/p1/geom/xyz/0.,0.,0./.5,.5,.5/ * extract a plane - note pset is ignored! extract/plane/threepts/0.,0.,0./1.,0.,0./1.,0.,1./pset,get,p1/2dm1/3dmesh dump/gmv/gmv.3dm/3dmesh/ dump/gmv/gmv.2dm/2dmesh/ dump/gmv/gmv.2d1m/2dm1/ cmo/select/3dmesh * refine some more refine/constant/boron/linear/edge/1,0,0/1.3+20/ recon * now get an isosurface extract/isosurf/boron/1.0e+20/1,0,0/2dm2/3dmesh dump/gmv/gmv.2dm2/2dm2 * get the boundary of one region extract/intrface/m1/1,0,0/2dm3/3dmesh dump/gmv/gmv.2dm3/2dm3 * get the interface between two regions extract/intrfac2/m1/m2/1,0,0/2dm4/3dmesh dump/gmv/gmv.2dm4/2dm4 * try the network option extract/network/1,0,0/2dm5/3dmesh dump/gmv/gmv.2dm5/2dm5 * get the surface mesh - note interface plane is included extract/surfmesh/1,0,0/2dm6/3dmesh dump/gmv/gmv.2dm6/2dm6 finish",
    "tags": "extract",
    "url": "/pages/docs/commands/EXTRACT1.html"
  },{
    "title": "EXTRACT/SURFMESH",
    "text": "EXTRACT / SURFMESH This routine extracts the boundary of a mesh. If the original mesh is a solid mesh, it extracts the surface mesh. If it is a surface mesh, it extracts the edge mesh. If the interface elements have “parent-child” nodes, then only the parent nodes and elements are extracted. Not all attributes in the input mesh object are created or initialize in the output mesh object. Among the array-valued attributes, only xic,yic,zic,itet,jtet,itetoff,itettyp, and icr1 are set. The node attribute imt is set to 1. The icontab array is copied from the input mesh object to the output mesh object. The elements of the extracted surfmesh are detirmined by the faces of the original mesh elements. So if the original mesh is hexahedral, the surfmesh will be quads, if it is tetrahedral, the surfmesh will be triangles. If you want all triangles in the surfmesh you can first convert the mesh to tetrahedrals using the command grid2grid. Note: the itp array of the input mesh object must be correctly set. Use the command resetpts/itp which will identify nodes on the outside and also on material interfaces for multi-value itetclr values. See more about this attribute at Mesh Object. SYNTAX extract / surfmesh / 1,0,0 /cmo_out /[ cmo_in ][ external ] 1,0,0 is the range convention where the integers represent start,stop,stride and 1,0,0 represents all. The pset or eltset selections are also allowed. cmo_out is the name of the extracted mesh object. cmo_in is optional and is the name of the mesh object to extract from, the default is the current mesh object. external means only the exterior surface mesh will be extracted and not the interior interfaces (extracted by default). Note if itetclr is set to a single value and the itp array is updated, there will be no interior interfaces to extract. -all- deprecated option at end of syntax is ignored. By default, all interior and exterior surfaces are extracted. ADDED ATTRIBUTES | mregion2 mregion1 | |------&gt; normal | itetclr = 1 | itetclr = 2 itetclr0 = 1 | itetclr1 = 2 element# = 1 | element# = 2 idelem0 = 1 | idelem1 = 2 Six new element attributes and one node attribute, are added to the output mesh indicating the material numbers (itetclr) on each side of the mesh faces, i.e., the color of elements that existed on each side of a face in the original mesh. For multi-material, the convention is that the normal points into the larger material id (itetclr) material. itetclr0 (values 0 to max material) and itetclr1 (values 1 to max material) based on itetclr material values on each side of the extracted surface. 0 indicates a face on the boundary. idelem0 (values 0 to nelements) and idelem1 (values 1 to nelements) element number on each side of the extracted surface. idface0 (values 0 to num element faces) and idface1 (values 0 to num element faces) the local face number for each element on either side of the extracted surface. facecol (values between 0 and max material) is a model face number constructed from the itetclr0 and itetclr1 attributes and is not guaranteed that the same facecol value will not be given to two disjoint patches of mesh faces. idnode0 (values 0 to nnodes) provides the mapping from nodes in the extracted interface network to (parent) nodes in the input mesh object; that is, IDNODE0(J) is the parent node in the input mesh object that corresponds to node J in the output mesh object. EXAMPLES extract/surfmesh/1,0,0/ mos_all / MO_MESH extract/surfmesh/1,0,0/ mos_out / MO_MESH / external Demo Extract Surfmesh This demonstrates the difference between extracting all or just external boundaries. See Full Demo at Demo Extract Surfmesh. The first image shows the original hex mesh and nodes colored by the itp boundary tags. The image is clipped at the front to show the internal 0 value itp nodes and the tagged interface nodes with value 2. The second image shows the extracted surfmesh which includes the interface between the materials. The third image shows the surfmesh extracted from external boundary only. Click on images for full size.       Input Hex Mesh surfmesh all surfmesh external Hex mesh colored by itetclr material, nodes show itp values (clip front) extract all boundaries and interfaces, color by itetclr1 (clip front) extract external boundaries only, color by itetclr1 (clip front) Demo Write Face Sets This example shows how extract/surfmesh can be used to write boundary face information that can be used by ExodusII files to define facesets (side sets). See Full Demo at Demo Write Face and Node Sets. Write the mesh element number idelem1 and element face number idface1 to define a boundary or surface in order to set model conditions. Note it is very important that you use the model source mesh to get the intended node and element numbers. If you subset or change the source mesh, the node and element numbers might change so your faceset list will not be valid. # extract surface faces from boundary and interfaces extract/surfmesh/ 1,0,0 / mo_surf / mo_master # subset the surface to selected faces # select faces on interface below material 2 cmo/select/ mo_surf eltset/ e_delete/ itetclr0 ne 2 rmpoint / element / eltset get e_delete rmpoint / compress # write file with element-face number pairs # using the surfmesh attributes idelem1 and idface1 # first delete all the attributes we do not want to write cmo / DELATT / mo_surf / itetclr0 cmo / DELATT / mo_surf / idnode0 cmo / DELATT / mo_surf / idelem0 cmo / DELATT / mo_surf / facecol cmo / DELATT / mo_surf / itetclr1 cmo / DELATT / mo_surf / idface0 dump / avs / mat2_interface.facesets / mo_surf / 0 0 1 2 The file mat2_interface.facesets will have the element number and the boundary face local number for the selected faces. In this case the faces are all upward facing and all faces are id 2 on the tet element they are extracted from. 0 0 0 2 0 00002 1 1 idelem1, integer idface1, integer 1503 2 1504 2 1508 2 1509 2 1513 2 1514 2 1518 2 ...",
    "tags": "extract surfmesh",
    "url": "/pages/docs/commands/dump/EXTRACT_SURFMESH.html"
  },{
    "title": "FIELD",
    "text": "FIELD The FIELD Command option manipulates one or more specified fields in the Current Mesh Object SYNTAX field/compose/composition function/ifirst,ilast,istride/field list/ field/mfedraw/root file name/x1,y1,z1/x2,y2,z2/field list/ field/scale/scale option/factor/ifirst,ilast,istride/ field list / field/volavg/averaging option/iterations/ifirst,ilast,istride/filed list/ compose the field value with the specified composition function for all points in the specified point set. The composition functions allowed are currently asinh and log. So, for example, if ‘i’ is in the point set and asinh is the composition function, we have the assignment: field(i) = asinh(field(i)) mfedraw causes a binary dump of the specified fields to two files in the mfedraw input format. mfedraw is a graphics package for visualizing moving piecewise linear functions of two variables, such as those originally encountered in Moving Finite Elements. The files are named ‘root1.bin’ and ‘root2.bin’, where ‘root’ is the root file name argument. Because the graphics data are a function of two variables, you must supply two orthonormal vectors (x1,y1,z1) and (x2,y2,z2) which specify the graphics coordinate axes. More precisely, given 3D coordinates (x,y,z), the 2D graphic coordinates will then be (x *x1+y *y1+z *z1 , x *x2+y *y2+z *z2). So, for example, the choice: /x1,y1,z1/x2,y2,z2/ = /1.,0.,0./0.,1.,0./ causes the ‘z’ coordinate to be discarded while the ‘x’ and ‘y’ coordinates are unchanged. scale option scales the field values of the specified points. scale option can take on the values normalize, multiply, and divide. If normalize is specified, we multiply all the field values by factor/(fieldmax-fieldmin), where ‘fieldmax’ and ‘fieldmin’ are the maximum and minimum values taken over the point set. This has the effect of normalizing the field so that the new difference between the maximum and minimum values is equal to factor. If multiply is specified, we multiply all the field values in the point set by factor. If divide is specified, we divide all the field values in the point set by factor. volavg option, for all the members of the point set and for all specified fields, replaces the point field values with values that represent the average of the field(s) over the control volumes associated with the points. The averaging option specifies what kind of control volume is to be used; the choices are voronoi and median. iterations is an integer that specifies a repeat count for how many times this procedure is to be performed on the field(s). The affect of this process is to broaden and smooth the features of the field(s), similar to the effect of a diffusion process. The voronoi choice, unlike the median. choice, produces a diffusive effect independent of mesh connectivity. However, again unlike the median. choice, it requires that the mesh be Delaunay, or incorrect results will occur. ## EXAMPLES field/compose/asinh/1,0,0/field/scale/normalize/4.field/volavg/voronoi/4/1",
    "tags": "field",
    "url": "/pages/docs/commands/FIELD.html"
  },{
    "title": "FILTER",
    "text": "FILTERKD FILTER FILTER/ELEMENT This command is used to filter (mark for deletion) a set of nodes that are geometricly close, within the tolerance value. This command changes the node type of the deleted nodes to type ‘dudded’ (itp=21) but does not remove them from the point list. There must be least one point must be specified in the point range in order for this command to work properly. Dudded nodes are not removed from the mesh object, but are ignored by many routines because of their dudded status. Use the command rmpoint/compress to remove dudded nodes and update the mesh object. If the mesh object has connected elements, the itet values in the connectivity array are adjusted. This may change topology. To filter duplicate elements or flat elements, see filter/element or filterkd with the zero_element option. FORMAT: filterkd/ ifirst,ilast,istride/ [tolerance] / [nocheck OR zero_element] filter/ ifirst,ilast,istride / [tolerance] / [ min OR max ] / attribute] This version of filter is being replaced with the kd-tree search algorithm used in filterkd that more accurately identifies nodes within the tolerance value. iirst,ilast,istride defines the node set where 1,0,0 are all nodes in the mesh object. [tolerance] This is the epsilon value used to measure node distances. If this value is not included, the mesh object epsilon value is used. nocheck This is the default for filterkd and will skip the code that removes zero elements. The behavior is similar to original filter except a kdtree structure is used instead of a binning method for finding nodes within epsilon value. This version has been shown to be more accurate where precision matters. zero_element This option is available with filterkd where a mesh has connected elements. The algorithm removes flat elements as using the tolerence value as mininum edge length. Duplicate nodes not associated with these flat elements are not removed. minmax / attribute This option is available with the filter command. Nodes for deletion are detected based on the standard geometric criteria however, the choice about which node is retained is determined based on comparison of the attribute values and the node with either the ** min** or ** max** value is retained. filter/[element]/[search_range]/ [nodelete OR delete] Search a mesh object for duplicate elements. A duplicate element is defined as having the exact same set of nodes in the element connectivity list (itet). The order of the nodes in the connectivity does not matter. The element with the larger itetclr value (master) wi ll be kept. The duplicate element will have its material color (itetclr) changed to max(itetclr) + 1. Two new element attributes (iclr1, iclr2) are added to the mesh object to keep track of the correspondence of master(retained)/duplicate(removed) elements and their original material id (itetclr).  The option nodeleteis the default and elements are not removed. Use option delete to remove the elements marked as duplicate. ]{style=”font-family: times;” The search_range can be set by the user. This number limits the number of elements above and below an element (in numerical order) to search. The default is 10. For more on filter/element see filter/element details.  EXAMPLES: filterkd/1,0,0 filter/1,0,0 Filter all nodes and delete duplicates with tolerance distance set to mesh object epsilon value. Both filter and filterkd behave the same but filterkd performs with better precision. filterkd / 1 0 0 / 1.e-3 Filter all nodes and delete duplicates where epsilon tolerance is set by user to 1.e-3. filterkd / [pset] / get_point_set Filter a subset of the nodes and delete duplicates with epsilon tolerance set automaticly. filterkd / 1 0 0 / 1.e-3 / zero_element Identify and remove all flat elements with edge length less than 1.e-3 as defined by user. filter / 1 0 0 / / min / imt Filter all nodes and delete duplicates with epsilon tolerance set automaticly. When duplicate nodes are detected the imt attribute is examined and the node with minimum imt value is retained. filter / [element]/ [nodelete] Filter elements and set itetclr of duplicates to max(itetclr) + 1. Assign values to iclr1 and iclr2 arrays. filter / [element] / 1e20 / [delete] Filter all elements (assuming there are less than 1e20)  with an exhaustive search and delete duplicate elements. Assign values to iclr1 and iclr2 arrays.",
    "tags": "filter, filterkd, filter element",
    "url": "/pages/docs/commands/FILTER.html"
  },{
    "title": "FILTER/ELEMENT",
    "text": "FILTER/ELEMENT SYNTAX filter/[ element]/[search_range]/[nodelete|[delete] Search a mesh object for duplicate elements. A duplicate element is defined as having the exact same set of nodes in the element connectivity list (itet). The order of the nodes in the connectivity does not matter. The element with the larger itetclr value (master) will be kept. The duplicate element will have its material color (itetclr) changed to max(itetclr) + 1. Two new element attributes (iclr1, iclr2) are added to the mesh object to keep track of the correspondence of master(retained)/duplicate(removed) elements and their original material id (itetclr).  For all elements the values of iclr1 are set their original itetclr values. For any element that is neither master nor duplicate, the value of icr2 is set to its itetclr value. For an element that is a master, icrl2 is set to the original itetclr value of its duplicate. For an element that is a duplicate, icrl2 is set to the original itetclr value of its master. For example, consider the 4 element mesh, where element 2 and 3 are: Element 1,2 itetclr = 1 Element 3,4 itetclr = 2 then after: [filter]{style=”font-weight: bold;”/[element]/10/[nodelete]                               Maximum material id max(itetclr)          =          2                          Duplicate Elements will be set to itetclr =          3                          search_range                              =         10                          nelements searched                        =          4                          Number of duplicate element found         =          1                          cmo/printatt/cmohex1/itetclr/1 0 0                                              Attribute: itetclr                                                                       1          1                                                                    2          3                                                                    3          2                                                                    4          2                                                           cmo/printatt/cmohex1/iclr1/1 0 0                                                Attribute: iclr1                                                                         1          1                                                                    2          1                                                                    3          2                                                                    4          2                                                           cmo/printatt/cmohex1/iclr2/1 0 0                                                Attribute: iclr2                                                                         1          1                                                                    2          2                                                                    3          1                                                                    4          2                                                           All elements are tested. The search for each element’s duplicate does not occur over the entire element list. The default for search_range is 10 and results in looking at the 10 elements in the element list sequentially above and 10 elements sequentially below the test element.  In the example given below the elements are sorted so that elements that are physically close to each other will be close to each other in the element list. The [search_range] can be set by the user. Setting [search_range] to a number larger than the number of elements will cause all elements to be searched. The algorithm will only detect one duplicate element per element. If there are more than two elements with the same connectivity, they can be found by calling filter/element multiple times. The default behavior is to not delete the duplicate elements.  However the duplicate elements will be deleted from the mesh if the parameter [delete] is specified. In general if you are merging together two meshes and then want to delete duplicate elements the commands might be: Merge two mesh objects **addmesh **/ merge / cmohex / cmohex1 / cmohex2 Create an attribute with the median x,y,z coordinate of each element [createpts] / [median] Sort and reorder the elements based on the median points. This will insure that elements that occupy the same location will have element numbers near one another. [sort] / -def- / [index] / [ascending] / ikey / xmed ymed zmed [reorder] / -def- /ikey Filter and remove duplicate nodes. [filter] / 1 0 0 [rmpoint] / [compress] Filter and remove duplicate elements. [filter] / [element] / [delete]  EXAMPLES: filter / [element] Filter all elements and set itetclr of duplicates to max(itetclr) + 1. Assign values to iclr1 and iclr2 arrays. filter / [element] / [nodelete] Filter elements and set itetclr of duplicates to max(itetclr) + 1. Assign values to iclr1 and iclr2 arrays. filter / [element]/ [delete] Filter elements and delete duplicate elements. Assign values to iclr1 and iclr2 arrays. filter / [element] / 1e20 / [delete] Filter all elements (assuming there are less than 1e20)  with an exhaustive search and delete duplicate elements. Assign values to iclr1 and iclr2 arrays.",
    "tags": "filter element",
    "url": "/pages/docs/commands/FILTER_element.html"
  },{
    "title": "FINISH",
    "text": "FINISH Terminate processing this command stream and return to the driver routine. This is a requirement so LaGriT can exit gracefully. SYNTAX finish",
    "tags": "finish, exit",
    "url": "/pages/docs/commands/FINISH.html"
  },{
    "title": "FSET",
    "text": "FSET This command  is used to  define a  set  of element faces. Defining face sets can be useful for either defining boundary conditions, material interfaces, or surface subsets for further mesh processing. SYNTAX fset / name / pset, get, pointsetname name must be an integer or character string. Currently, only 32 named face sets may exist. However, any number of integer-numbered face sets (up to the total number of faces in the problem) may be defined. Face sets may be used in all of the usual ways that eltsets and psets may be used. NOTE: Not all modules support use of fset. EXAMPLES fset / fname / pset,get, psetname cmo/setatt/3dmesh/fluid_structure /fset,get,blue/ where fluid_structure is the name of a face set attribute",
    "tags": "fset",
    "url": "/pages/docs/commands/FSET.html"
  },{
    "title": "GRID2GRID",
    "text": "GRID2GRID The grid2grid command converts a mesh with one element type to a mesh with another. The conversion type is determined by the second argument. NOTE: Use of grid2grid to convert a 3D mesh to a tetrahedral mesh will in general result in a non-Delaunay tetrahedral mesh. If the target simulator is one that uses two-point flux approximation and Voronoi control volumes (FEHM, PFLOTRAN, TOUGH2) then using hextotet and then dump/stor to compute and output geometric coefficients, is not a good idea. If the ultimate goal is a a geometric coefficients file, one should use connect to connect vertices into a Delaunay mesh. Note: Use of grid2grid to convert an octree refined hexahedral into to a tetrahedral mesh should not be done. You will get a result, however, no special algorithms are implemented to connect across interfaces where octree resolution changes and hanging nodes occur. One should instead copy the octree vertex set into a tet mesh object and use connect to create a tetrahedral mesh. SYNTAX grid2grid / ioption / [ cmo_sink ] / [ cmo_source ] OPTIONS ioption: is a character string that determines the element type of the source and sink meshes. There is no ‘default’ option - this argument must be specified. quadtotri2   quad to 2 triangles, no new points. prismtotet3   prism to 3 tets, no new points. quattotri4   quad to 4 triangles, with one new point. pyrtotet4   pyramid to 4 tets, with one new point. hextotet5   hex to 5 tets, no new points. hextotet6   hex to 6 tets, no new points. prismtotet14   prism to 14 tets, four new points (1 + 3 faces). prismtotet18   prism to 18 tets, six new points (1 + 5 faces). hextotet24   hex to 24 tets, seven new points (1 + 6 faces). tree_to_fe   quadtree or octree grid to grid with no parent-type elements to clean amr or octree structures. [ cmo_snk / cmo_src ] are the mesh_object names for the new mesh to create and the source mesh object. cmo_src is the original grid. cmo_snk is the name for the new tet or triangle grid. These may be the same grid, if so desired. If both are left blank, the current mesh object will be used. If only one mesh name is given, it will be used at the sink mesh, and the current mesh object will be used as the source. EXAMPLES grid2grid / hextotet24 /  cmo_tet / cmo_hex Convert each hex element in cmo_hex to 24 tets and name the new grid cmo_tet. grid2grid / quadtotri4 /  new_mesh No source mesh is given, so the current mesh object (which is a quad mesh) will have every quad converted into 4 triangles, and saved as new_mesh. grid2grid / tree_to_fe / new_mesh /  octree_mesh Parent elements in octree_mesh will be removed, so only the leaf elements remain. The result will be stored in new_mesh. This is often used to ensure a single valid mesh for other commands or for use outside of LaGriT. The octree attributes itetpar, itetkid, and itetlev will be updated in the new_mesh. A description of the octree mesh and attributes are described in the command refine",
    "tags": "grid2grid, hextotet, amr",
    "url": "/pages/docs/commands/GRID2GRID.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#GENERIC%20MESH%20REGION%20QUERIES:) “30” “30”](MeshVertex.md) “30” “30”](Geom.md)   GENERIC REGION TYPE OPERATORS  int RType_NumVerts(ElType type); Number of vertices for a generic element of a particular type int RType_NumEdges(ElType type); Number of edges for a generic element of a particular type int RType_NumFaces(ElType type); Number of faces for a generic element of a particular type void RType_EdgeVertMap(ElType type, int ienum, int *evnums); Get the local vertex numbers for local edge ‘ienum’ of element type. void RType_FaceVertMap(ElType type, int ifnum, int nfv, *int * *fvnums); Get the local vertex numbers for local facee ‘ifnum’ of element type. void RType_FaceEdgeMap(ElType type, int ifnum, int nfe, *int * *fenums); Get the local edge numbers for local face ‘ifnum’ of element type. void RType_EdgeVertMap(ElType type, int ienum, int *evnums); Get the local vertex numbers for local edge ‘ienum’ of element type.    “30” “30”](mstkla.md#GENERIC%20MESH%20REGION%20QUERIES:) “30” “30”](MeshVertex.md) “30” “30”](Geom.md)",
    "tags": "",
    "url": "/pages/mstkla/GenRegion.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#GMTKLA_Init) “30” “30”](GenRegion.md) “30” “30”](GeomEntity.md)  GEOMETRIC MODEL INITIALIZATION:   void GMTKLA_Init(void); Initialize the geometric model interface (does nothing for now but include it for completeness sake).    MODEL OPERATORS:    int GM_NumRegions(void); Number of model regions. Note this has nothing to do with number of material attributes. That is the analysis preprocessing concern not the mesh generator’s or the geometric modeler’s. The number of model regions refers to the number of distinct volumes in the geometric model. int GM_NumFaces(void); Number of model faces. For now, this just returns the number of surfaces in the geometric model although they are strictly not the same. PGeomRegn GM_Region(int i); Return the i’th geometric model region PGeomFace GM_Face(int i); Return the i’th geometric model face void GM_Regions(int nr, *PGeomRegn * *gregs); Get all the model regions void GM_Faces(int nf, *PGeomFace * *gfaces); Get all the model faces “30” “30”](mstkla.md#GMTKLA_Init) “30” “30”](GenRegion.md) “30” “30”](GeomEntity.md)",
    "tags": "",
    "url": "/pages/mstkla/Geom.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#MODEL%20EDGE:) “30” “30”](GeomFace.md) “30” “30”](GeomVertex.md) “169” “131” int GEs_AreSame(PGeomEdge pe1, PGeomEdge pe2)   void GE_Faces(PGeomEdge pe, int nf, *PGeomFace * *faces)   void GE_Regions(PGeomEdge pe, int nr, *PGeomRegn * *regns)   int GE_OnBoundary(PGeomEdge pe, PGeomEntity gent)     “30” “30”](mstkla.md#MODEL%20EDGE:) “30” “30”](GeomFace.md) “30” “30”](GeomVertex.md)",
    "tags": "",
    "url": "/pages/mstkla/GeomEdge.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#MODEL%20ENTITY:) “30” “30”](Geom.md) “30” “30”](GeomRegion.md) “169” “131” MODEL ENTITY OPERATORS: GType GEnt_Type(PGeomEntity gent); Type of a geometric model entity (GREGION, GFACE, GEDGE, GVERTEX, GUNKNOWN).  Typically can be used in conjunction with the operator to get mesh entity classification. So one can get the model entity a mesh vertex is on, query what type it is and do something based on the response (e.g. reposition the vertex only if it is classified in a model region).   int GEnt_Number(PGeomEntity gent); ID Number of geometric model entity. Can be called instead of GR_Number, GF_Number, GE_Number and GV_Number.   int GEnt_OnBoundary(PGeomEntity g1, PGeomEntity g2); Check if g2 is on the boundary of g1 (Check if a face is on the boundary of a region, an edge is on the boundary of a face, a vertex is on the boundary of a region) int GEnts_Common(int nent, GType types, *PGeomEntity gents, *int ncm, *GType ctypes, *PGeomEntity *cgents) Given nent entitities (the entity pointers given in gents and their types in types), find their  common entities, cgents. The entities will be of the lowest order possible (but higher than the highest order of the input entities). For example, if we were given two model edges connected by one common face, the output would be this common face. On the other hand if these edges were not connected by a common face but the faces connected to them are on the boundary of the same model region, the model region would be returned as a common entity. Naturally, there may be more than one such common model entity in general geometric models. int GEnt_OnExtBoundary(PGeomEntity gent) Check if model entity is on external boundary   “30” “30”](mstkla.md#MODEL%20ENTITY:) “30” “30”](Geom.md) “30” “30”](GeomRegion.md)",
    "tags": "",
    "url": "/pages/mstkla/GeomEntity.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#MODEL%20FACE:) “30” “30”](GeomRegion.md) “30” “30”](GeomEdge.md) “169” “131”    MODEL FACE OPERATORS:  void GF_Regions(PGeomFace gf, PGeomRegn gr[2]); Get the regions on either side of the face. gr[0] is the region on the opposite side of the normal while gr[1] is the region on the same side of the normal.  In principle (not in LaGriT), both entries of gr may be filled _AND_ gr[0] may be equal to gr[1]. Also in principle, both entries of gr may be NULL.     “30” “30”](mstkla.md#MODEL%20REGION:) “30” “30”](GeomRegion.md) “30” “30”](GeomEdge.md)",
    "tags": "",
    "url": "/pages/mstkla/GeomFace.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#MODEL%20REGION:) “30” “30”](GeomEntity.md) “30” “30”](GeomFace.md) “169” “131”    MODEL REGION OPERATORS:  void GR_Faces(PGeomRegn gr, int nf, *PGeomFace *faces); Get the model faces that form the boundary of a model region. int GR_FaceDir(PGeomRegn gr, PGeomFace gf); Get the sense in which a model region is using a face, i.e., is the face normal pointing into the region (return value 0), out of the region (return value 1), both (return value 2) or none (return value -1). * * * * MUST VERIFY THiS WITH CODE VALUES * * * * * * int GR_OnBoundary(PGeomRegn this, PGeomEntity gent);       “30” “30”](mstkla.md#MODEL%20REGION:) “30” “30”](GeomEntity.md) “30” “30”](GeomFace.md)",
    "tags": "",
    "url": "/pages/mstkla/GeomRegion.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#MODEL%20VERTEX) “30” “30”](GeomEdge.md) “30” “30”](utilities.md) “169” “131”“30” “30”](mstkla.md#MODEL%20VERTEX) “30” “30”](GeomEdge.md) “30” “30”](utilities.md)",
    "tags": "",
    "url": "/pages/mstkla/GeomVertex.html"
  },{
    "title": "help",
    "text": "HELP SYNTAX help/ variable_name help/ code_variable will return the variable definition and the correct value of the variable. EXAMPLES help/ipointi",
    "tags": "help",
    "url": "/pages/docs/commands/HELP.html"
  },{
    "title": "HEXTOTET",
    "text": "HEXTOTET This command, while still recognized, has a newer more readable syntax, see grid2grid instead. The hextotet command creates a tetrahedral grid from 3D grids, and triangles from 2D. The first parameter ioption determines how the conversion is performed. NOTE: Use of hextotet (or grid2grid) to convert a 3D mesh to a tetrahedral mesh will in general result in a non-Delaunay tetrahedral mesh. If the target simulator is one that uses two-point flux approximation and Voronoi control volumes (FEHM, PFLOTRAN, TOUGH2) then using hextotet and then dump/stor to compute and output geometric coefficients, is not a good idea. If the ultimate goal is a a geometric coefficients file, one should use connect to connect vertices into a Delaunay mesh. Note: Use of hextotet to convert an octree refined hexahedral into to a tetrahedral mesh should not be done. You will get a result, however, no special algorithms are implemented to connect across interfaces where octree resolution changes and hanging nodes occur. One should instead copy the octree vertex set into a tet mesh object and use connect to create a tetrahedral mesh. SYNTAX hextotet / [ ioption ] / cmo_snk / cmo_src / [ rmvolume] OPTIONS ioption is a numerical number indicating the number of tets or triangles to break each element into. If this parameter is missing then default settings are used. The defaults are underlined and will be detirmined by reading the mesh_type of the mesh_object. If mesh_type is quad, 2 is used. If mesh_type is prism, 3 is used. If mesh_type is hex, 6 is used. Otherwise 24 is the default value for ioption. The selections include: 2   quad to 2 triangles, no new points. 3   prism to 3 tets, no new points. 4   quad to 4 triangles, with one new point. 4   pyramid to 4 tets, with one new point. 5   hex to 5 tets, no new points. 6   hex to 6 tets, no new points. 14   prism to 14 tets, four new points (1 + 3 faces). 18   prism to 18 tets, six new points (1 + 5 faces). 24   hex to 24 tets, seven new points (1 + 6 faces). cmo_snk / cmo_src : are the mesh_object names. cmo_src is the original grid. cmo_snk is the name for the new tet or triangle grid. rmvolume : keyword is optional and will assign hextotet_remove_volume and hextotet_remove_duplicates to ‘yes’. This will enable hextotet to use its own algorithm for removing elements with zero volume and duplicate points. It may be prone to epsilon errors for grids over large areas. By default, zero volumes and duplicate points are not removed from the new mesh object cmo_snk. EXAMPLES hextotet / 24 / cmo_tet / cmo_hex Convert each hex element in cmo_hex to 24 tets and name the new grid cmo_tet. hextotet / / cmo_tri / cmo_quad No value is given for ioption, so the default settings are used. The mesh_type of cmo_quad is quad, so each element is converted to two triangles. The new mesh_object is named cmo_tri. hextotet / 3 / cmo_tet / cmo_pri / rmvolume Each prism element in cmo_pri is converted to three tet elements. Zero volume elements and duplicate points are removed. The new tet mesh object is called cmo_tet. cmo/addatt/mohex/imtsav/VINT/scalar/nnodes/linear/ cmo copyatt / mohex mohex / imtsav imt cmo/addatt/mohex/itetsav/VINT/scalar/nelements/linear/ cmo copyatt / mohex mohex / itetsav itetclr cmo setatt mohex imt 1 cmo setatt mohex itetclr 1 resetpts itp hextotet / 5 / motet / mohex / CAUTION If mesh is multi-material this can add signifigant time to the hextotet routine! This example shows a good practice which will avoid this issue. The attributes imtsav and itetsav are created and values copied before setting the mesh materials in itetclr and imt to 1. The command resetpts/itp will reset boundary and interface accordingly. This mesh mohex has each hex element converted into 5 tets each. The number of nodes will not change. LINKS: Click here for demos",
    "tags": "hex to tet connect",
    "url": "/pages/docs/commands/HEXTOTE.html"
  },{
    "title": "INPUT INFILE",
    "text": "INPUT or INFILE These commands instruct LaGriT to begin processing commands from a file. The infile commands may be nested. Each file  set of commands MUST be terminated with a finish command. This works well with the define commands for multiple calls to the same command file. SYNTAX infile / file_name input / file_name EXAMPLES loop / do / NL 1 10 1 / loop_end &amp; infile lagrit.input_refine_smooth Use loop command to run 10 iterations commands to smooth using file “lagrit.input_refine_smooth”: pset / psmooth / geom / xyz / 1 0 0 / -3. -3. -3. / 3. 3. 3. recon / 0 smooth / position / esug / pset get psmooth finish * Well R-60 define NORDER 149 define WELLID 4600001 define SCREENID 4811 define MO_WELL mo define XC 495828.64 define YC 539043.30 define RTOP 1797.76 define RBOT 1791.39 define WLEN 6.37 define R0 0.0 define R1 56.0 define NRAYS 8 define NRADIAL 4 define R_RATIO 2.0 define WELLAVS 149_4600001_cyl.inp infile build_1well.mlgi Set variables and build a cylinder well using commands in file “build_1well.mlgi”: cmo / create / MO_WELL / / / tet createpts/brick/rtz/NRADIAL,NRAYS,2/0. 0. 0. /R1,360.,WLEN/ &amp; 1,1,1/1 0 0/ R_RATIO 1.0 1.0 cmo/addatt/MO_WELL/wellid/VINT/scalar/nnodes//permanent/agfx/0 cmo/addatt/MO_WELL/screen/VINT/scalar/nnodes//permanent/agfx/0 cmo/addatt/MO_WELL/topbot/VINT/scalar/nnodes//permanent/agfx/0 cmo/setatt/MO_WELL/wellid WELLID cmo/setatt/MO_WELL/screen SCREENID cmo/setatt/MO_WELL/imt1 NORDER cmo/setatt/MO_WELL/itetclr 1 cmo select MO_WELL filter / 1 0 0 rmpoint / compress resetpts / itp cmo select MO_WELL pset/pbot/attribute zic/1,0,0/ eq 0. cmo setatt MO_WELL topbot 1 cmo setatt MO_WELL topbot pset,get,pbot -1 trans/1,0,0/ 0. 0. 0./XC YC RBOT dump avs WELLAVS MO_WELL cmo printatt MO_WELL imt minmax cmo printatt MO_WELL topbot minmax cmo printatt MO_WELL -xyz- minmax finish",
    "tags": "infile input command",
    "url": "/pages/docs/commands/INPUT.html"
  },{
    "title": "INTERSECT",
    "text": "INTERSECT Creates a new Mesh Object from the intersection of two existing Mesh Objects. The existing Mesh Objects have to be topologically 2D and geometrically 3D. The created Mesh Object will be topologically 1D and geometrically 3D. SYNTAX intersect/cmo_out/cmo_1_in/cmo_2_in cmo_out is the new mesh object. Node quantities for the new Mesh Object will be created by interpolation on the corresponding node quantities of the first input Mesh Object cmo_1_in from the second mesh object cmo_2_in. This command will also apply the line_graph option of the sort command on the new Mesh Object. This will sort the elements (which will be line segments) into a reasonable order based on their connectivity, and will also create element attributes **ctype, cid, loop_id. intersect will create a temporary sort key and use that to reorder the elements, so there is no need to use your own sort key. For more details on the sorting and on the created element attributes, please see sort.",
    "tags": "intersect",
    "url": "/pages/docs/commands/INTERSECT.html"
  },{
    "title": "MASSAGE",
    "text": "MASSAGE MASSAGE creates, annihilates, and moves nodes and swaps connections in a 2D or 3D mesh in order to improve element aspect ratios and establish user-desired edge lengths. Specifically, MASSAGE performs up to four iterations of a loop which calls AGD3D (a routine for automated merging of nodes), RECON (a routine for automated reconnection of edges), and SGD (a routine for element aspect ratio improvement using smoothing). MASSAGE then calls CEL_CHAIN which performs Rivara edge refinement and then another call to RECON.  In the case of 2-D surface grids, this is then followed by a call to CER_CHAIN which is another edge refinement routine and then a final call to RECON if necessary. AGD3D will attempt to merge edges that are shorter than merge_length.  CEL_CHAIN will attempt to bisect edges that are longer than bisection_length .  For 2D surfaces, CER_CHAIN will attempt to bisect edges that deviate from an averaged surface normal (“have a roughness of”) greater than tolroughness. RECON will attempt to create ‘nice’ elements by using face swapping. The LaGriT command MODE/RECON can alter the meaning of ‘nice’.  The default is to reconnect to restore the delaunay criterion.  Calling MODE / RECON/GEOM prior to the MASSAGE call will create ‘plumper’ elements.  SGD will attempt to improve element aspect ratios by moving nodes. Note:  Since CEL_CHAIN is called only once at the end of MASSAGE, it may be necessary to call MASSAGE twice for optimal results.  This is because annihilation of nodes is done with an intent to improve element aspect ratios, but cannot be effective if there are too few nodes initially. Note: The user may wish to call RMPOINT/COMPRESS after MASSAGE operations that merge a significant number of nodes. SYNTAX massage/bisection_length/merge_length/toldamage/[[tolroughness]]/ &amp; [ifirst,ilast,istride]/ [nosmooth] / [norecon] &amp; [strictmergelength]/[ignoremats]/ &amp; [lite]/[checkaxy]/[semiexclusive]/[exclusive] Primary Parameters bisection_length edge length that will trigger bisection. can either be a scalar value or a node attribute. merge_length is the edge length value that will trigger merging. toldamage is a parameter which controls how much the mesh interface and external boundaries will be deformed.    Roughly, it measures the depths of ‘dents’ that are invariably introduced when nodes are moved, annihilated, and faces are swapped. tolroughness (for 2D surface grids only)  measure of grid roughness (deviation from average surface normal) that triggers refinement. The following are guidelines for using these primary parameters: When setting the bisection parameter bisection_length as a scalar value, if the edge length is greater than scalar value, the edge will be refined. If a node attribute is used, the edge length is compared to the minimum value of the two nodes, if edge length is greater, the edge will be refined. Thus, one should put a minimum floor value (probably equal to twice the desired minimum edge lenth) for the field. Otherwise the code will refine indefinitely. For an example of an appropriate field see MASSAGE2. The value of bisection_length should not be smaller than merge_length, or the action of merging nodes together will be largely pointless because the newer, longer edges created by merging will simply be bisected again.  It is recommended that bisection_length be at least three times as large as merge_length. If the damage parameter toldamage is set to an extremely small number, there will be few if any node movements, but annihilations, or face swaps will be allowed.  Conversely, if this parameter is set too large, boundaries may be significantly deformed. Setting toldamage equal to approximately .01 times the diameter of the mesh frequently gives acceptable results. Merges of edges of length &lt;= merge_length are meant to coarsen the mesh, but are not meant to deform surfaces and material interfaces on this scale.  The amount of material/surface deformation set with toldamage is meant to be considerably less than merge_length. On the other hand, the maximum roughness tolerated in the graph tolroughness should be considerably more than toldamage, or roughness refinement will be triggered by actions such as flipping or merging. The following are guidelines for setting these parameters: bisection_length &gt;= 3 times merge_length &gt;&gt; toldamage tolroughness &gt;= 10 times toldamage  (for 2D surface grids) For example, for a grid with diameter of order 3, these values are suggested: bisection_length, merge_length, toldamage, tolroughness = .3, .1, .01, .1 If bisection_length or merge_length is omitted, the omitted parameter will be set so that bisection_length = 3 times merge_length. If bisection_length and merge_length are omitted, both values will be taken to infinity. If toldamage is omitted, no node annihilation will take place. If tolroughness is omitted, no refinement on roughness will occur and thus the format is compatible with old commands where refinement on roughness did not occur. Additional Parameters nosmooth will turn off the smooth step by skipping the call to SGD. norecon will turn off all recon steps. lite will specify only one iteration of the merging/reconnection/smoothing loop is executed, and a reconnection after edge refinement is omitted.  This is suitable for applications, such as Gradient Weighted Moving Finite Elements, where MASSAGE is called repeatedly. ignoremats causes MASSAGE to process the multimaterial mesh in a single material mode; it ignores multi-material interfaces.  strictmergelength forces strict interpretation of merge_length so that there is no merging along the edges of flat elements.  This is important if ignoremats is specified to avoid losing the interfaces. checkaxy for 2D meshes, ensures the output mesh will have positive xy-projected triangle areas, provided that the input mesh had them in the first place.  exclusive applies to point sets, edge refinement operations will only be performed on edges whose endpoints are both in the PSET that MASSAGE is working on.  (As usual, new nodes created by refinement are added to the PSET so that MASSAGE can refine edges recursively.)  The default behavior is inclusive, where only ONE edge endpoint has to belong to the PSET for the edge to be eligible for refinement. semiexclusive represents an intermediate case between inclusive and exclusive. Refinment is triggered only by edges with both endpoints in the PSET, but some edges with less than two endpoints in the PSET might be refined as part of a ‘Rivara chain’ triggered by the refinement of an edge with both endpoints in the PSET.  EXAMPLES massage/[0.3/0.1/0.01] Mesh edges longer than 0.3 will be bisected; mesh edges shorter than 0.1 might be collapsed if that causes damage (normal surface motion) to material interfaces or external boundaries less than 0.01 ; smoothing of nodes causing damage less than 0.01 is allowed ; face swapping causing damage less than 0.01 is allowed. massage/[H_SCALE/0.1/0.01]/ Same as above, except that the bisection_length is a node field called H_SCALE in this case. massage/[[0.3/0.1/0.01/0.1] Same as above but for 2-D surface meshes, roughness greater than 0.1 will trigger refinement. massage/0.3/0.1/0.01/pset,get,[pset1] Mesh edges (containing at least one endpoint in pset1) longer than 0.3 will be bisected; mesh edges shorter than 0.1 might be collapsed if that causes damage (normal surface motion) to material interfaces or external boundaries less than 0.01 and if the annihilated node is in pset1;  smoothing of nodes in pset1 causing damage less than 0.01 is allowed; face swapping causing damage less than 0.01 is allowed (unfortunately, LaGriT at this time does not restrict swapping to pset1). massage/0.3/0.1/0.01/pset,get,pset1,nosmooth As above, but without smoothing. massage/1.e+20/0.1/0.1/1,0,0/nosmooth Because of the virtually infinite value of [bisection_length],no edges will be bisected.  Since merge_length=toldamage=0.1, merging of edges  of length less than 0.1 will be considered, and will not be rejected because of excessive damage.  Hence we expect that all edges of length less than 0.1 will be merged away (except in those cases where merging would invert tetrahedra or change material topology).   Because nosmooth is specified, no smoothing will take place.  Face swapping causing damage less than [toldamage] is allowed massage[/1.e+20/1.e-9/1.e-9/1,0,0]/nosmooth/strictmergelength /ignoremats This set of arguments will remove degenerate elements from a mesh by merging nodes that have the same coordinate values ( within 1.e-9).",
    "tags": "massage, agd3d, sgd, recon, cel_chain",
    "url": "/pages/docs/commands/MASSAGE.html"
  },{
    "title": "MASSAGE2",
    "text": "MASSAGE2 MASSAGE2 iteratively calls MASSAGE to refine adaptively according to a gradient field. Thus, the bisection_length option must be a field. SYNTAX massage2 / infile_name / min_scale / bisection_length / merge_length / toldamage / &amp; [tolroughness] /[ifirst,ilast,istride]/ [nosmooth**]/[norecon**] &amp; [strictmergelength ]/[ignoremats ]/[lite] /[checkaxy]/[semiexclusive]/[exclusive] &lt;/pre&gt;     `infile_name` is a file which contains a set of LaGriT [**`infile`**](/pages/docs/commands/INPUT.html) commands that calculates the gradient field based on the distance field. In other words, the gradient field is a function of the distance field. It is necessary to have this file when using this routine, as the field must be updated after each refinement iteration. See sample infile below. `min_scale` is the minimum length scale of the mesh (the minimum desired edge length). See [**`MASSAGE`**](/pages/docs/commands/MASSAGE.html) for a full description of all command parameters. ## Creating user function infile for MASSAGE2 This file contains a set of LaGriT commands which calculate the gradient field for refinement based on the distance field. A file could be written like this: #user_function.mlgi #An example of calculating the gradient field F # as a linear function of the distance field D #Define some coefficients for the function define / COEF_A / define / COEF_B / #Formula F = COEF_A times D + COEF_B #First remove any distance field that exists and recompute the distance field cmo / DELATT / mo_sink / dfield compute / distance_field / mo_sink / mo_src / dfield #Calculate F math / multiply / mo_sink / ref_field / 1,0,0 / mo_sink / dfield /COEF_A math / add / mo_sink / ref_field / 1,0,0 / mo_sink / ref_field /COEF_B finish The user does not have to put a floor value for the gradient field in this case (unlike in MASSAGE), as MASSAGE2 will calculate the floor value automatically. However, the minimum length scale 'min_scale' must be specified. The user must also create a node-based attribute for the gradient field before calling MASSAGE2. In the example above, attribute 'ref_field' must already exist in the mesh object. The name of the field must also match the 'field_name' argument in the MASSAGE2 command. ## EXAMPLES ``` massage2 / user_function.mlgi / 0.1 / ref_field / 1.e-5 / 1.e-5 / strictmergelength ``` Call massage refinement with commands defined in the infile user_function.mlgi using attribute ref_field.",
    "tags": "massage2, refinement",
    "url": "/pages/docs/commands/MASSAGE2.html"
  },{
    "title": "MATH",
    "text": "MATH The math routine operates on attributes of a mesh object(s). It performs arithmetic operations or evaluates mathematical functions on the source mesh object or objects, and places the results in the sink mesh object. The source and sink mesh objects can be the same, and there can be either one or two source objects, depending on the operation selected. All attributes must have the same type, rank, and length. Mathematical functions other than floor and ceiling are not implemented for attributes whose values are integers. SYNTAX math/operation/cmo_sink/attr_sink/1,0,0/cmo_src/attr_src / [value] math / integrate /cmo_sink/attr_sink/1,0,0/ attr_src_field operation The first parameter a keyword that indicates the type of work to perform, see below. cmo_sink attr_sink are the sink cmo and sink attribute for the math results to be written to. These parameters are required for all math operations. 1 0 0 is the selected range istart,ilast,istride where 1,0,0 represents all. The selections can also be defined by pset or eltset. value is required by some math operations and can be of type constant or can be a cmo attribute. For the standard arithmetic operations, value can be either a constant or an attribute. These arithmetic operations work for all types of attributes. For the mathematical functions other than floor and ceiling, value is omitted, and the function is performed on the src_attr and stored in the sink_attr. cmo_src2/attr_src2/ where cmo_src2 may be the same name as the source cmo, or the name of a second source cmo. attr_src2 assumes attribute is part of cmo_src constant is a numerical value that is provided for some of the operations. OPERATIONS plus add minus sub subtract times multiply mult divide min max modulo are arithmetic operators; the result is stored in sink_attr where sink_attr = (src_attr) operator value. Where value can be a constant or mesh object attribute. min max are not to be confused with the minimum or maximum value of an attribute; rather the the result is a comparison of pairs of source values. sin cos tan ln (natural log), and log10 are mathematical functions. The value parameter is omitted, and the function is performed on the src_attr and stored in the sink_attr. These functions are not implemented for integer attributes. floor and ceiling are mathematical functions where value is used as the lower or upper limit, the value(s) of src_attr are checked against value, and the results are stored in the sink_attr. These functions work for all types of attributes. power function uses both value parameters. The first value or src_attr is raised to the power of the second value or attribute. You cannot use two constants. At least one of the sources must be an attribute. The result is stored in the sink_attr. exp and exp10 functions raise the constant e or the constant 10 to the power specified by src_attr and stores the result in the sink_attr. sum adds all node or element values in attr_src, within the selected range and writes the result to attr_sink. The sink attribute must be of type ‘REAL’ or ‘INT’ (length=’scalar’) and will be created if it does not exist. integrate for elements only. It is a function that computes the product of ‘field_value’ times the ‘element volume’ at each element and either saves these products (or sums) to the sink attribute. The ‘field_value’ for an element is either the value of attr_src (if attr_src is an element attribute and has length ‘nelements’) or is the average of the values at the vertices of the element (if attr_src is a node attribute). If sink_attr does not exist or if it exists and has length ‘nelements’, the products are stored in sink_attr. If sink_attr exists and has length ‘scalar’, then the products are summed up and the result is stored in sink_attr. If the user requires just the integrated sum this alternative avoids having to use the pair of commands integrate, sum and also avoids creating the ‘nelement’ long sink attribute. EXAMPLES math/multiply/ sink_mo/sink_attribute/50,60,3/src_mo/src_attribute/1.0 math/add/ mo/attribute/50,60,3/mo/attribute/100.0 math/modulo/ mo/attribute/1,0,0/mo/attribute/10 math/sub/ sink_mo/sink_attribute/50,60,3/src_mo1/src_attribute1/src_mo2/src_attribute2/ math/min/ sink_mo/sink_attribute/1,0,0/src_mo1/src_attribute1/src_mo2/src_attribute2/ math/ln/ sink_mo/sink_attribute/1,0,0/src_mo/src_attribute/ math/floor/ sink_mo/sink_attribute/1,0,0/src_mo/src_attribute/2.0/ math/power/ sink_mo/sink_attribute/1,0,0/src_mo/src_attribute/2.0/ math/power/ sink_mo/sink_attribute/1,0,0/2.0/src_mo/src_attribute/ math/power/ sink_mo/sink_attribute/1,0,0/base_mo/base_attribute/power_mo/power_attr math/exp/ sink_mo/sink_attribute/1,0,0/src_mo/src_attribute/ math/exp10/ sink_mo/sink_attribute/1,0,0/src_mo/src_attribute/ math/integrate/ cmotri /Vf /1,0,0/ cmotri/ Fn math/sum/cmotri / Vfsum /1,0,0/ cmotri / Vf math/sum/cmotri / area_sum /1,0,0/ cmotri / darea",
    "tags": "math",
    "url": "/pages/docs/commands/MATH.html"
  },{
    "title": "MERGE",
    "text": "MERGE Merge pairs of points together. The command massage may be used to merge nodes together based on the edge distance separating the nodes. SYNTAX merge/first_point/second_point merge/1st_of_pair1/2nd_of_pair1/1st_of_pair2/2nd_of_pair2/../1st_of_pairn/2nd_of_pairn Parameters are pairs of points to merge. On return, the first_point of a pair is the survivor unless first_point may not be removed ( a corner point for example), then the command operates as if first_point and second_point have been interchanged. If there is no confirmation of the merge, one or both of the points may be inactive, or the merge may be illegal because the points are not neighbors or because this merge is disallowed by the merge tables. Merging may trigger other merges by the reconnection step that follows the merge. EXAMPLES merge/21,22/",
    "tags": "merge",
    "url": "/pages/docs/commands/MERGE.html"
  },{
    "title": "MODE",
    "text": "MODE The MODE Command  sets up several optimization options. SYNTAX mode/discrete/surface_cmo/tolldamage mode/adaption_field/field_name mode/recon/geom delaunay adaption Discrete optimization discrete/surface_cmo/tolldamage If this mode is set, refine, smooth, merge will require any operation that involves nodes on the specified surface to result in a mesh whose surface nodes are also members of the surface_cmo. A mesh object attribute associated with the 3d mesh named discrete_optimize will be created and its value will be the name of the surface mesh object. Error adaption adaption_field / field_name If this mode is set, optimization operations will be based on reducing error.  A mesh object attribute associated with the 3d mesh named ‘adaption_field’ will be created and it’s value will be the name of the field. Reconnection recon/geom recon/delaunay recon/adaption Setting this mode will determine the criterion used to reconnect the mesh.  The default mode is delaunay and setting mode to delaunay will cause recon to attempt to create a delaunay mesh.  Setting mode to geom will reconnect to increase inscribed radii of elements.  Setting mode to adaption will reconnect to reduce solution error.  The parameter field_name must be set with the mode/adaption_field command. EXAMPLES mode/adaption_field/solution mode/recon/adaption",
    "tags": "mode",
    "url": "/pages/docs/commands/MODE.html"
  },{
    "title": "MREGION",
    "text": "MREGION Define a material region from a set of surfaces by logically combining surface names and region names. MREGION is used together with SURFACE and REGION to set mesh object geometry and materials. See Examples below. Defining a mregion will cause the information associated with this material region to be stored under the name of the geometry of the current mesh object. Releasing the region will remove this information. The defined mesh object geometry can be named with the GEOMETRY command. SYNTAX mregion/ material_region_name/ surface_and_region_operators mregion/ mregion_name/ release Defining a material region will cause the information associated with this material region to be stored under the name of the geometry of the current mesh object. Releasing the material region will remove this information. To define a material region, use operators with surfaces and regions according to the following rules. The operators or, and, and not mean union, intersection, and complement respectively and are applied to surfaces and regions. Parentheses are operators and are used for nesting. Spaces are required to separate operators and parentheses. The operators lt, le, gt, and ge are applied to mesh object surfaces according to the following rules: lt if the surface following is a volume then lt means inside not including the surface of the volume. If the surface is a plane or a sheet lt means the space on the side of the plane or sheet opposite to the normal not including the plane or sheet itself. le if the surface following is a volume then le means inside including the surface of the volume. If the surface is a plane or a sheet le means the space on the side of the plane or sheet opposite to the normal including the plane or sheet itself. gt if the surface following is a volume then gt means outside not including the surface of the volume. If the surface is a plane or a sheet gt means the space on the same side of the plane or sheet as the normal not including the plane or sheet itself. ge if the surface following is a volume then ge means outside including the surface of the volume. If the surface is a plane or a sheet ge means the space on the same side of the plane or sheet as the normal including the plane or sheet itself. Internal interfaces should be excluded when defining material regions, use lt and gt. External boundaries should be included, use le and ge. EXAMPLES mregion/mat1/ le box1 and ( lt sphere1 and ( lt plane1 or gt plane2 ) ) Define a material mat1 that is inside or on a box shaped surface, and inside surface called sphere1, and relative to plane1 and plane2. mregion/mat2/ regiona or regionb Define a material region based on earlier defined regions such that material mat2 are all nodes found inside regiona or regionb. cmo/create/cmo surface/outside/reflect/box/0,0,0/3,2,1 region/all/le outside mregion/all/le outside createpts/xyz/3,3,3/0,0,0/3,2,1/1,1,1 setpts connect Very simple application of the region and mregion commands to create a single material box shaped mesh. # Define geometry cmo / select / CMO_IN geometry / create / stack_geom # define surfaces for CMO_IN cmo / select / CMO_IN surface / s0 /reflect / sheet / mo0 surface / s1 /reflect / sheet / mo1 surface / s2 /reflect / sheet / mo2 surface / s3 /reflect / sheet / mo3 surface / s4 /reflect / sheet / mo4 surface / s5 /reflect / sheet / mo5 surface / s6 /reflect / sheet / mo6 # define geometry regions # all internal interfaces are defined # and are included once only region / r_below / le s0 region / r1 / ge s0 and lt s1 region / r2 / ge s1 and lt s2 region / r3 / ge s2 and lt s3 region / r4 / ge s3 and lt s4 region / r5 / ge s4 and lt s5 region / r6 / ge s5 and lt s6 region / r_above / ge s6 # define material regions # internal interfaces not included mregion / mr_below / lt s0 mregion / mr1 / gt s0 and lt s1 mregion / mr2 / gt s1 and lt s2 mregion / mr3 / gt s2 and lt s3 mregion / mr4 / gt s3 and lt s4 mregion / mr5 / gt s4 and lt s5 mregion / mr6 / gt s5 and lt s6 mregion / mr_above / gt s6 # Finished building geometry Define geometry and material regions based on surface grids read into mesh objects named mo0, mo1, … mo6. The result are regions stacked in layers such that nodes found equal to surface s0 are the interface nodes between regions r1 and r2. Nodes between surfaces s0 and s1 are in region r1 and have the material labeled mr1. And so on. This mesh geometry has the name stack_geom.",
    "tags": "mregion, region, surface",
    "url": "/pages/docs/commands/MREGION.html"
  },{
    "title": "",
    "text": "“30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MSTKLA_Init) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/prelim.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshRegion.md) MESH INITIALIZATION:     void MSTKLA_Init(void); Initialize the mesh toolkit. MESH OPERATORS   These operators work on variables of type PMeshObj. PMeshObj MESH_Create(); Creates a default mesh object and returns it - At this point all the info in it is useless. void MESH_InitFromFile(PMeshObj mesh, *char **filename, *char *format, *int iotype, *char * **name); Read a mesh in from “filename” and initialize the “mesh”. The file is in the format “format” (“lagrit” for LaGriT dumps, “gmv” for GMV files, “avs” for AVS files). ‘iotype’ is 1 for ascii and 0 for binary. ‘name’ is the name of the mesh that is read and returned If a LaGriT file is read, the geometric model info will be read as well. void MESH_InitFromCMO(PMeshObj mesh, char *cmoname); Initialize the mesh object from a given cmo. If ‘cmoname’ is NULL (say sent in as the character string ), the mesh object is initialized from the default mesh object. If not the given cmo is made is active and the mesh object is initialized from that. “31” “32”This implies that sometime in the middle of a LaGriT subroutine, one can call a C routine which initializes a mesh object and then uses the functionality of MSTKLA!! (Cool!) int MESH_Select(PMeshObj mesh); Make a particular mesh object active void MESH_Delete(PMeshObj mesh); Delete a particular mesh object. “31” “32” * NOT YET IMPLEMENTED * WILL BE IN SOON void MESH_WriteToFile(PMeshObj mesh, char filename, *char format, *int iotype); “31” “32” * NOT YET IMPLEMENTED * WILL BE IN SOON * * PMeshObj MESH_Duplicate(PMeshObj mesh); “31” “32” * NOT YET IMPLEMENTED * * int MESH_NumVertices(PMeshObj mesh); Number of vertices (nodes) in the mesh. “27” “31” * * IMPORTANT * * * This count may include deleted vertices, parent vertices and other types of vertices that should be ignored. So when looping through vertices of a mesh, one should check if the vertex is to be ignored by checking if MV_Type returns VIGNORE or VDELETED. int MESH_NumRegions(PMeshObj mesh); Number of regions (elements) in the mesh. “27” “31” * * IMPORTANT * * * This count may include deleted regions. While looping through the regions of a mesh, one should check if the region is to be ignored by checking if MR_Type returns RDELETED. PMeshVert MESH_Vertex(PMeshObj mesh, int i); Fetch the i’th vertex (node) of the mesh (This is C so remember i starts from 0) The returned mesh vertex object can be queried for information. The returned vertex must always be checked for its type to see if it deleted or must otherwise be ignored. PMeshRegn MESH_Region(PMeshObj mesh, int i); Fetch the i’th region (element) of the mesh. The returned mesh region can be queried for information. The returned region must be checked if it is a deleted region. void MESH_BldUpAdj(PMeshObj mesh); Build the vertex to region connectivity. This will allow upward adjacency operator MV_Regions to be called. In fact those operators will function properly only after this is called. void MESH_DelUpAdj(PMeshObj mesh); Delete the vertex to region connectivity information to save memory. It is not possible for MSTKLA to determine when this information is not needed and call this routine automatically. void MESH_IncrNodeLists(PMeshObj mesh); Increment all the node lists. “31” “32”( * NOT FULLY TESTED * *) void MESH_IncrElemLists(PMeshObj mesh); Increment all the element lists. “31” “32”( * NOT FULLY TESTED * *) void MESH_CmprNodeLists(PMeshObj mesh); Compress all the element lists. “31” “32” * * NOT YET IMPLEMENTED * * * “27” “31” * * IMPORTANT !!! * * * There is one side effect of compression of lists. If one is storing a list of node numbers or PMeshVerts (which for the LaGriT interface are just integers cast as pointers), then after compression, the node numbers or PMeshVert “addresses” may not be referring to the nodes you think they are. void MESH_CmprElemLists(PMeshObj mesh); Compress all the element lists.  * * NOT YET IMPLEMENTED * * * “27” “31” * * IMPORTANT !!! * * * There is one side effect of compression of lists. If one is storing a list of element numbers or PMeshRegns (which for the LaGriT interface are just integers cast as pointers), then after compression, the element numbers or PMeshRegn “addresses” may not be referring to the elements you think they are.     “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MSTKLA_Init) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/prelim.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshRegion.md)",
    "tags": "",
    "url": "/pages/mstkla/Mesh.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#MESH%20VERTEX:) “30” “30”](MeshEdge.md) “30” “30”](GenRegion.md)      MESH ATTRIBUTE OPERATORS   void MESH_AddAtt(PMeshObj mesh, char **attname, *AttType attype, Rank rank, MType mtype, Interp interp, int persist, char **ioflags, *double defval); AttType, Rank and Interp are typedef enums which are available if one includes “mstkla.h”. The specific names (which are pretty much the strings that are used in LaGriT) are given in mstkla_types.h (See MSTKLA typedefs) ‘persist’ must be 0 for temporary atts and 1 for permanent attribs ‘ioflags’ is a string as in lagrit  (may be any combination of ‘a’, ‘g’, ‘f’, ‘s’, ‘x’, ‘no’ for AVS, GMV, FEHM, SGI, LaGriT or None) mtype is MVERTEX if the attribute is to be node based and is MFACE or MREGION if the attribute is to be element based depending on whether the mesh is 2D or 3D respectively. void MESH_ModAtt(PMeshObj mesh, *char **attname, *char *fieldname, *int inew, double rnew, *char **cnew); Here depending on the fieldname, one has to fill the right value for inew, rnew or cnew. * * NOT TESTED * * * void MESH_CopyAtt(PMeshObj trgmsh, PMeshObj srcmsh, char trgatt, *char *srcatt); * * NOT TESTED * * *  void MESH_DelAtt(PMeshObj mesh, *char **attname); void MESH_SetAtt(PMeshObj mesh, char **attname, *int ifirst, int ilast, int istride, char **psetname, *double value); If psetname is specified ifirst is ignored * * NOT TESTED * * * Once attributes have been created, one can go to an individual mesh entity and ask for the value of an attribute for that entity or change the value. The entities can be Mesh Vertices (always), Mesh Faces (for a surface mesh only), Mesh Regions (for a solid mesh only). For example one can use MR_GetAttVal operator to get the value of an attribute for a given element or use MR_SetAttVal to set it. See attribute operators forMesh Vertices,Mesh Regions and Mesh Faces   “30” “30”](mstkla.md#MESH%20VERTEX:) “30” “30”](MeshEdge.md) “30” “30”](GenRegion.md)",
    "tags": "",
    "url": "/pages/mstkla/MeshAttributes.html"
  },{
    "title": "",
    "text": "“30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20EDGE:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshFace.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshVertex.md)    MESH EDGES: Since LaGriT does not really store mesh edges, the mesh edge data structure (MeshEdge, PMeshEdge) is created on the fly whenever edge information is requested. Therefore after utilizing the edge(s) get information, it (they) should be destroyed by calling ME_Delete operator. int ME_Number(PMeshObj mesh, PMeshEdge e); * This will return 0 for now since I haven’t yet decided on a good * way to assign a unique number to the (virtual) edges of the mesh. void ME_Delete(PMeshEdge e); Free the data structure associated with this edge created on the fly. (There is an operator for creation but I cannot yet imagine needing to make that a publicly available operator). “27” “31” * IMPORTANT * * ME_Delete will not remove any connections in the mesh. It just destroys the temporary data structure used to store the edge info int ME_IsParent(PMeshObj mesh, PMeshEdge pe); If both vertices of the edge are parents, the edge is a parent. PMeshEdge ME_Parent(PMeshObj mesh, PMeshEdge pe); The parents of each vertex of the edge are obtained and a new ‘parent’ edge is constructed from them. void ME_Children(PMeshObj mesh, PMeshEdge pe, int nec, *PMeshEdge * *ec); “31” “32” * * NOT YET IMPLEMENTED * * * Child vertices of the face are found and appropriate combinations of these vertices are used to construct the new ‘child’ faces. For a combination to be appropriate, the vertices of the child face has to point to the same material region. int MEs_areSame(PMeshEdge e1, PMeshEdge e2); Compare the data in two MeshEdge data structures and see if they represent the same connection in the mesh. This operator is needed since the on-the-fly PMeshEdge pointers may not be the same and they do not directly point to any persistent “object” in the database. PGeomEntity ME_GMentity(PMeshObj mesh, PMeshEdge e); Return the geometric model entity the edge is on. In the absence of explicit edge representation in the database, this may be problematic in a few cases cases where multiple classifications are possible. GType ME_GMtype(PMeshObj mesh, PMeshEdge e); Return the type of geometric model entity the edge is on. This (I think) is more deterministically found from the classifications of its vertices but still there may be some incorrect cases. The way around is complicated and will not be implemented for now. PMeshVert ME_Vertex(PMeshObj mesh, PMeshEdge e, int i); Return the i’th vertex of the mesh edge. i can only be 0 or 1. Parent edges return parent vertices and child edges return child vertices. If a vertex is not on an interface the vertex itself is returned. “31” “12”PMeshVert ME_OtherVertex(PMeshObj mesh, PMeshEdge e, PMeshVert v); Return the other vertex of the mesh edge (obviously the one that is not v). void ME_Faces(PMeshObj mesh, PMeshEdge e, int nef, *PMeshFace * *efaces); Get the “faces” of an “edge”. The faces data structures are also constructed on the fly since they do not exist in the LaGriT database. Also, as with other upward connectivity queries, this can execute usefully only if the routine MESH_BldUpAdj is called beforehand. Also, see note on freeing the PMeshFace structures listed under MV_Edges and MV_Faces. The behavior of this operator for parent and child edges is similar to MV_Edges. void ME_Regions(PMeshObj mesh, PMeshEdge e, int ner, *PMeshRegn * *eregions); Get the regions connected to an edge. MESH_BldUpAdj must be called before this operator can be called usefully. The behavior of this operator for child and parent edges is similar to that of MV_Regions. “27” “31” * IMPORTANT * * Since MESH_BldUpAdj builds explicit upward adjacency information, this routine does not require a seed region to be provided. Also, this routine will work regardless of whether there is a complete cycle of regions around the edge and whether the edge is an arbitrary type of non-manifold edge!! int ME_EntOnBdry(PMeshObj mesh, PMeshEdge pe, PMeshVerte pv); Check if vertex is on the boundary of edge. In other words, is this vertex one of the edges vertices.     “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20EDGE:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshFace.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshVertex.md)",
    "tags": "",
    "url": "/pages/mstkla/MeshEdge.html"
  },{
    "title": "",
    "text": "“30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20FACE:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshRegion.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshEdge.md)     MESH FACES: Since LaGriT does not really store mesh faces, the mesh face data structure (MeshFace, PMeshFace) is created on the fly whenever face information is requested. Therefore after utilizing the face(s) get information, it (they) should be destroyed by calling MF_Delete operator. int MF_Number(PMeshObj mesh, PMeshFace f); “31” “32” * This will return 0 for now since I haven’t yet decided on a good * way to assign a unique number to the (virtual) faces of the mesh. void MF_Delete(PMeshFace f); Free the data structure associated with this face created on the fly. (There is an operator for creation but I cannot yet imagine needing to make that a publicly available operator). “27” “31” * IMPORTANT * * MF_Delete will not remove any connections in the mesh. It just destroys the temporary data structure used to store the face info int MF_IsParent(PMeshObj mesh, PMeshFace pf); If all vertices of the face are parents, the face is a parent. PMeshFace MF_Parent(PMeshObj mesh, PMeshFace pf); The parents of all vertices of the face are obtained and a new ‘parent’ face is constructed from them. void MF_Children(PMeshObj mesh, PMeshFace pf, int nfc, *PMeshFace * *fc); “31” “32” * * NOT YET IMPLEMENTED * * * Child vertices of the face are found and appropriate combinations of these vertices are used to construct the new ‘child’ faces. For a combination to be appropriate, the vertices of the child face has to point to the same material region. int MFs_areSame(PMeshObj mesh, PMeshFace f1, PMeshFace f2); Compare the data in two MeshFace data structures and see if they represent the same connection in the mesh. This operator is needed since the on-the-fly PMeshFace pointers may not be the same and they do not directly point to any persistent “object” in the database. PGeomEntity MF_GMentity(PMeshObj mesh, PMeshFace f); Return the geometric model entity the face is on. In the absence of explicit face representation in the database, this may be problematic in a few cases cases where multiple classifications are possible. GType MF_GMtype(PMeshObj mesh, PMeshFace f); Return the type of geometric model entity the face is on. This (I think) is more deterministically found from the classifications of its vertices but some problems may still occur. See Comments in ME_GMtype. PMeshVert MF_Vertices(PMeshObj mesh, PMeshFace f, int nfv, *PMeshVertex * *fverts); Return the vertices of the mesh face. The vertices are in no particular order.  Parent faces return parent vertices and child faces child vertices. If a vertex is not on an non-manifold boundary (interface) the vertex itself is returned. PMeshVert MF_VerticesOrd(PMeshObj mesh, PMeshFace f, int nfv, *PMeshVertex * *fverts); “31” “32” * NOT YET IMPLEMENTED * * Return the vertices of the mesh face. The vertices are ordered such that the smallest one is the first. Also, the sequence is such that the face points out of the region connected to it or in case there are two regions connected to it, such that it points out of the region with the lower ID Number. The behavior of the operator for parent and child faces is the same as MF_Vertices void MF_Edges(PMeshObj mesh, PMeshFace f, int nef, *PMeshFace * *efaces); Get the “edges” of an “face”. The edges data structures are constructed on the fly since they do not exist in the LaGriT database. See note on freeing the PMeshFace structures listed under MV_Edges and MV_Faces. Parent faces return parent edges and child faces return child edges. void MF_Regions(PMeshObj mesh, PMeshFace f, PMeshRegn fregions[2]); Get the regions connected to an face. MESH_BldUpAdj must be called before this operator can be called usefully. The regions will be returned such that the face ‘f’ as defined will point out fregions[0] (if it exists) and into fregions[1] (if it exists). A parent face will return both regions connected to it while a child face will return a region only on its side of the interface. If a “child” face constructed from interior nodes and child nodes on an interface, both regions connected to it are returned. “27” “31” * IMPORTANT * * Since MESH_BldUpAdj builds explicit upward adjacency information, this routine does not require a seed region to be provided. int MF_EntOnBdry(PMeshObj mesh, PMeshFace f, MType mtype, PMeshEntity pent); Check if mesh entity of type ‘mtype’ is on the boundary of mesh face. mtype can only be MEDGE or MVERTEX. In other words, check if mesh face is made up of mesh edge or vertex in question.     []{#MF-Attribsint MF_GetAttVal(PMeshObj mesh, PMeshFace f, *char **attname, *int **ival, *double **rval, *char **cval, *void * **pval, *AttType **atype); Depending on the type of the attribute, the appropriate field will be filled on succesful completion. Arrays are returned in pval, integer in ival and real number in rval (I don’t think lagrit supports character attributes) “27” “31” Will only work for surface meshes int MR_SetAttVal(PMeshObj mesh, PMeshFace f, *char *attname, *int ival, double rval, char cval, *void **pval); This is similar to the GetAttVal routine - depending on the type and rank, one sends in a value with the right variable * * PERHAPS these routines need an additional variable, “rank” but for now…..   “27” “31” Will only work for surface meshes “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20FACE:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshRegion.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshEdge.md)",
    "tags": "",
    "url": "/pages/mstkla/MeshFace.html"
  },{
    "title": "",
    "text": "“30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20REGION:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/Mesh.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshFace.md)      MESH REGIONS:  int MR_Number(PMeshObj mesh, PMeshRegn r); Number ID for mesh region PGeomEntity MR_GMEntity(PMeshObj mesh, PMeshRegn r); Geometric entity (can only be a region) mesh region is classified on ElType MR_Type(PMeshObj mesh, PMeshRegn r); Type of element that mesh region is (TET, HEX etc) int MR_NumVerts(PMeshObj mesh, PMeshRegn r); Number of vertices in the element void MR_Vertices(PMeshObj mesh, PMeshRegn r, int nv, *PMeshVert * *verts); List of vertices of a mesh region void MR_VerticesE(PMeshObj mesh, PMeshRegn r, PMeshEdge e, PMeshVert *rverts); “31” “32”THIS OPERATOR IS APPLICABLE ONLY TO TETS Return the vertices of the given tet w.r.t to the given edge. The vertices v1 and v2 are vertices of the edge (maybe (0,1) or (1,0)) - these are returned as rverts[0] and rverts[1]. The vertices rverts[2] (call it k1) and rverts[3] (k2) are returned such that if the vertices are above the edge then looking from vertex 0 to vertex 1 of the edge k2 is to the left of k1. Mathematically,    (v2k1 X v2k2) . v2v1 &gt; 0 where v2k1 is the vector from v2 to k1, etc. void MR_VerticesLocE(PMeshObj mesh, PMeshRegn r, int enum, PMeshVert *rverts); “31” “32”THIS OPERATOR IS APPLICABLE ONLY TO TETS Same as MR_VerticesE (above) but the edge is specified by a local edge number of the region instead of an explicit pointer. int MR_NumFaces(PMeshObj mesh, PMeshRegn r); Number of faces of element void MR_Edges(PMeshObj mesh, PMeshRegn r, int num, *PMeshEdge * *edge); List of edges of a mesh region void MR_Faces(PMeshObj mesh, PMeshRegn r, int num, *PMeshFace * *faces); List of faces of a mesh region int MR_LocEdgeNum(PMeshObj mesh, PMeshRegn r, PMeshEdge e); Local edge number of the given edge in the given region int MR_LocFaceNum(PMeshObj mesh, PMeshRegn r, PMeshFace f); Local face number of the given face in the given region. int MR_EntOnBdry(PMeshObj mesh, PMeshRegn r, MType mtype, PMeshEntity pent); Check if mesh entity of type ‘mtype’ is on the boundary of mesh region. mtype can be MFACE, MEDGE or MVERTEX. In other words, the operator checks if mesh region is made up of mesh face, edge or vertex in question.   PMeshRegn MR_FaceNebr(PMeshObj mesh, PMeshRegn r, int lfnum); Return the mesh region adjacent to face number ‘lfnum’ of region ‘r’ The local face numbering starts from 0 in C style.   []{#MR-Attribsint MR_GetAttVal(PMeshObj mesh, PMeshRegn r, *char **attname, *int **ival, *double **rval, *char **cval, *void * **pval, *AttType **atype); Depending on the type of the attribute, the appropriate field will be filled on succesful completion. Arrays are returned in pval, integer in ival and real number in rval (I don’t think lagrit supports character attributes) “27” “31” Will only work for solid meshes int MR_SetAttVal(PMeshObj mesh, PMeshRegn r, *char *attname, *int ival, double rval, char cval, *void **pval); This is similar to the GetAttVal routine - depending on the type and rank, one sends in a value with the right variable * * PERHAPS these routines need an additional variable, “rank” but for now…..   “27” “31” Will only work for solid meshes   “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20REGION:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/Mesh.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshFace.md)",
    "tags": "",
    "url": "/pages/mstkla/MeshRegion.html"
  },{
    "title": "",
    "text": "“30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20VERTEX:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshEdge.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/GenRegion.md)      MESH VERTEX OPERATORS   int MV_Number(PMeshObj mesh, PMeshVert v); Return an ID number for the mesh vertex.   VType MV_Type(PMeshObj mesh, PMeshVert v); Return the mesh vertex type. Most useful in checking if a mesh vertex has been deleted or if it is a parent vertex on an interface PGeomEntity MV_GMEntity(PMeshObj mesh, PMeshVert v); Return the geometric model entity the mesh vertex is classified on. GType MV_GMtype(PMeshObj mesh, PMeshVert v); Return the type of geometric model entity the mesh vertex is classified on (GREGION, GFACE, GEDGE, GVERTEX, GUNKNOWN). void MV_Coords(PMeshObj mesh, PMeshVert v, double *xyz); Coordinates of mesh vertex int MV_IsParent(PMeshObj mesh, PMeshVert v); “31” “32”A vertex not on an interface is its own parent - return value will be 1 int MV_IsChild(PMeshObj mesh, PMeshVert v); “31” “32”A vertex not on an interface is its own child - return value will be 1 PMeshVert MV_Parent(PMeshObj mesh, PMeshVert v); “31” “32”For a vertex not on an interface, the vertex itself is returned void MV_Children(PMeshVert mesh, PMeshVert v, int nvc, *PMeshVert * *vc) “31” “32”For a vertex not on an interface, a 1 item array with the vertex pointer itself is returned and nvc = 1   void MV_Edges(PMeshObj mesh, PMeshVert v, int nve, *PMeshEdge * *vedges); List of mesh edges connected to vertex. For this routine to work properly, one must call MESH_BldAdj first. If not the routine will just return 0. If the vertex is a parent vertex, then the operator will return all the edges connected to all the child vertices of the vertex. The edge returned will be of type PARENT. Each of these edges will be made up of ‘v’ and any other parent vertex it is connected to. If it is a child vertex, then it will return edges connected only to itself.  In this case all the edges will be of type CHILD. Each edge will be made up of the child vertex ‘v’ and any other child vertex it is connected to. Note that vertices on 2-manifold (single material) boundaries and in the interior can be considered a parent or a child as required. “27” “31” * * IMPORTANT * * * When finished with the list of edges, call ME_Delete on each of the edges and free the vedges list. This is important since the MeshEdge data structures are created on the fly and the MESH object does not keep track of them.   void MV_Faces(PMeshObj mesh, PMeshVert v, int nvf, *PMeshFace * *vfaces); “31” “32” * NOT YET TESTED * * List of mesh faces connected to vertex. For this routine to work properly, one must call MESH_BldAdj first. If not the routine will just return 0. The behavior of the operator for parent and child vertices is the same as it is for MV_Edges. “27” “31” * * IMPORTANT * * * When finished with the list of faces, call MF_Delete on each of the faces and free the vfaces list. This is important since the MeshFace data structures are created on the fly and the MESH object does not keep track of them. int MV_numRegions(PMeshObj mesh, PMeshVert v); Number of mesh regions connected to mesh vertex. For this routine to work properly, one must call MESH_BldUpAdj first. If not the routine will just return 0.   void MV_Regions(PMeshObj mesh, PMeshVert v, int nr, *PMeshRegn * *regns); List of mesh regions connected to mesh vertex. For this routine to work properly, one must call MESH_BldUpAdj first. If not the routine will just return 0 for the number of regions and a NULL pointer for the region list.   For a parent vertex, mesh regions in all the material regions connected to all its children are returned. For a child vertex, only mesh regions in the particular material region pointed to by the child are returned. []{#MV-Attribsint MV_GetAttVal(PMeshObj mesh, PMeshVert v, *char **attname, *int **ival, *double **rval, *char **cval, *void * **pval, *AttType **atype); Depending on the type of the attribute, the appropriate field will be filled on succesful completion. Arrays are returned in pval, integer in ival and real number in rval (I don’t think lagrit supports character attributes)   int MV_SetAttVal(PMeshObj mesh, PMeshVert v, *char *attname, *int ival, double rval, char cval, *void **pval); This is similar to the GetAttVal routine - depending on the type and rank, one sends in a value with the right variable * * PERHAPS these routines need an additional variable, “rank” but for now…..     “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#MESH%20VERTEX:) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/MeshEdge.md) “30” “30”](http://www.ees.lanl.gov/staff/rao/mstkla/GenRegion.md)",
    "tags": "",
    "url": "/pages/mstkla/MeshVertex.html"
  },{
    "title": "NEGATIVE_AIJ",
    "text": "NEGATIVE_AIJ This command tests all edges of all boundary faces for negative coupling coefficients. It adds three attributes to the mesh object: num_neg_coup_coeff is the number of negative coupling coefficients neg_coup_coeff is the value of coupling coefficients (type VDOUBLE length = num_neg_coup_coeff ) ietet_aij is a vector with length = num_neg_coup_coeff. for each negative coupling coefficient: i: ietet_aij(1,i) contains the tetrahedron number which contributes the most negative portion to the coupling coefficient ietet_aij(2,i) contains the local face number that contains the local edge (ietet_aij(3,i)) which has the negative coupling coefficient. SYNTAX negative_aij negative_aij/refine negative_aij/refine/maxiter negative_aij/eltset/eltset_name negative_aij/rivara The attributes num_neg_coup_coeff, neg_coup_coeff, and ietet_aij can be used to generate a set of points to be added to the mesh in an attempt to reduce the number of negative coupling coefficients by using the refine option. The points added are created by projecting the fourth node of the tetrahedron onto the identified face and then projecting this projection onto the identified edge. If the final projected point lies between the end points of the identified edge, this edge is refined. The identification and refinement steps may be iterated up to maxiter times. Alternatively the attribute may be used to create an eltset of the identified elements. The rivara option uses a rivara refinement method to add nodes on exterior boundary edges until all coupling coefficients are positive or until a maximum number of iterations has been exceeded. EXAMPLES negative_aij negative_aij/refine for both examples, only one iteration will be performed negative_aij/refine/ 5 a maximum of 5 iterations will be performed negative_aij/eltset/ bad_tets an element set called bad_tets will be created, no refinement will be performed negative_aij/rivara refinement method to add nodes on exterior boundary edges Click here for demo of the command above",
    "tags": "negative_aij, coefficients",
    "url": "/pages/docs/commands/NEGATIVE.html"
  },{
    "title": "OFFSETSURF",
    "text": "OFFSETSURF This command is used to offset a triangulated surface in the direction of the surface outward normal, i.e., normal surface motion. For each node a ‘synthetic’ unit outward normal N is computed based on the weighted average angle of the normals of the triangles shared by that node. To add the nodes in the new surface to the main mesh object use the copypts command. To add the new surface to the main mesh object use a surface command with new_cmo as the sheet name (e.g. surface/s2d/bndy_type) SYNTAX offsetsurf/ new_cmo / old_cmo / dist / [keywords] new_cmo is the name of the new surface. old_cmo is the surface to be used in generating the offset surface. dist is the distance to offset the surface. The new node coordinates, R_new, are computed using the formula: R_new = R_old + dist times N_node The following keywords are available: keepatt, keep_angle Compute node angle weighted normals and keep the vector components in three scalar attributes x_n_norm y_n_norm z_n_norm keep_area Compute node area weighted normals and keep the vector components in three scalar attributes x_n_norm y_n_norm z_n_norm xzero Compute the full offset direction vector but set x component to zero yzero  Compute the full offset direction vector but set y component to zero zzero  Compute the full offset direction vector but set z component to zero xy, xz, yx, yz, zx, zy - these keywords come after the ‘dist’ value. They constrain the offset to be parallel to the specified plane. These arguments can be used with a line type mesh object to constrain the offset to a particular plane.   EXAMPLES offsetsurf/mo_out/cmo_in/d offset a triangulated surface a distance d using angle weighted normals offsetsurf/cmo_out / cmo_in / d / keep_area offset using area weighted normals offsetsurf/mo_out/cmo_in/d/[xy,xz,yx,yz,zx,zy] offset a line cmo a distance d in a direction parallel to the specified plane offsetsurf/mo_out/cmo_in/d/x y z offset a line cmo a distance d in the direction specified by the vector (x,y,z)",
    "tags": "offsetsurf",
    "url": "/pages/docs/commands/OFFSETSURF.html"
  },{
    "title": "PERTURB",
    "text": "PERTURB This command moves node coordinates in the following manner. Three pairs of random numbers between 0 and 1 are generated. These pairs refer to the x, y and z coordinates of the nodes respectively. The first random number of each pair is multiplied by the factor given in the command. The second random number is used to determine if the calculated offset is to be added or subtracted from the coordinate. WARNING: No checking is done to see if elements are inverted by this perturbation. If one uses too large a value for the perturbation, one can easily cause element inversions that will flip the normal vector of triangles and cause 3D cells to have negative volumes. Use the QUALITY command to report element volumes. SYNTAX perturb/ pset,get,psetname / xfactor,yfactor,zfactor pset,get,psetname is the range of nodes to offset, 1,0,0 means all nodes. xfactor,yfactor,zfactor perturbation values   EXAMPLES perturb/1,0,0/0.5,0,0   add offsets to only the xcoordinates of all nodes perturb/pset,get,mypset/0.001,0.001,0.001  add small offsets to all coordinates of the nodes in the pset named mypset DEMO using FACTOR parameters # For a unit cell divided into PTS**3 sub-cells, # delta-x = 0.01 = distance between sub-cell centers # x_p = delta-x / 100 = 0.0001 = 1% perturbations # eps_1 = sqrt(3*x_p) = 0.000173 = max dist. from origin define/XP/0.0001 define/EPS1/0.00018 define/PTS/101 cmo/create/mo1 createpts/xyz/PTS,PTS,PTS/0.,0.,0./1.,1.,1./1,1,1/ pset/po1/seq/0,0,0/ cmo/setatt/mo1/imt/pset,get,po1/1 cmo/create/mo2 createpts/xyz/PTS,PTS,PTS/0.,0.,0./1.,1.,1./1,1,1/ pset/po2/seq/0,0,0/ cmo/setatt/mo2/imt/pset,get,po2/2 perturb/pset,get,po2/XP,XP,XP/ addmesh/merge/mfilter/mo1/mo2 cmo/copy/mfilterkd/mfilter cmo/select/mfilter filter/1 0 0/EPS1 cmo/printatt/mfilter/imt/minmax cmo/printatt/mfilter/-xyz-/minmax cmo/select/mfilter rmpoint/compress cmo/printatt/mfilter/imt/minmax cmo/printatt/mfilter/-xyz-/minmax finish",
    "tags": "perturb",
    "url": "/pages/docs/commands/PERTURB.html"
  },{
    "title": "PSET",
    "text": "PSET (Point Set) Associate a name with a point set based on various geometric and logical operators. Manipulate point sets. Output point sets. By convention, ifirst,ilast,istride syntax represents a range selection defined either by a set of points from ifirst to ilast, with increments of istride (1 by default). A set selection can also be defined with pset,get, pset_name where pset_name has been defined by the following PSET commands. Most commands with the syntax ifirst,ilast,istride can also use pset,get, pset_name. The following are the syntax and parameter definitions, click on options in table or scroll down the page.         attribute constraints delete eltset geom list logicals region seq surface write zone attribute pset/pset_name/ attribute / attribute_name /ifirst,ilast,istride/[eq or ne or lt or gt ] / [value] forms a pset from points in selected range which have the specified value for a node based attribute. If the optional comparator field is given; that operation is used to compare the attribute value to the requested value. Note the comparator fields and the value can swap argument order. This option was previously named zq in old releases. constraints pset/pset_name/constraints/ num_constraints forms a pset of nodes having the specified number of constraints.  The node’s icr value is used as an index to the icontab attribute which gives the number of constraints.  See Mesh Object for an explanation of the icontab entries. delete pset/pset_name/ delete removes a previously defined pset from current mesh object eltset pset/pset_name/ eltset / element_set_name forms a pset of nodes in the element set with the name element_set_name. geom pset/pset_name/geom / xyz /ifirst,ilast,istride/ xl,yl,zl / xu,yu,zu/ xcen,ycen,zcen pset/pset_name/geom / rtz /ifirst,ilast,istride/ r1,t1,z1 / r2,t2,z2/ xcen,ycen,zcen pset/pset_name/geom / rtp /ifirst,ilast,istride/ r1,t1,p1 / r2/t2/p2/ xcen,ycen,zcen forms a pset from all points inside a geometric shape as defined in the following options: xyz forms a pset from all points inside a box whose corners are xl,yl,zl and xu,yu,zu relative to the geometry center at xc,yc,zc. rtz forms a pset of nodes within the cylinder or cylindrical shell given by radius r1 to r2, angle theta t1 to t2 and height z1 to z2. rtp forms a pset of nodes within the sphere, sperical shell or sperical section given by radius r1 to r2, and angles theta t1 to t2 and angles phi p1 to p2.  See Conventions for an explanation of angles theta and phi. list pset/pset_name/list pset / / list list all nodes in pset_name. If the 2nd argument is empty, list all names all of psets for the mesh object logicals pset/pset_name/ union inter not / pset1[ ,pset2, … psetn ] logical operations union, inter and not act on previously defined psets.  The definition of the unary operator not is extended such that not/p1/p2 means p1 and (not(p2)). region mregion pset/pset_name/region or mregion / region_name / ifirst,ilast,istride will return all nodes that are in the specified region or mregion as given by its region_name. seq pset/pset_name/ seq /ifirst,ilast,istride forms a pset of the nodes defined by ifirst, ilast, istride; the special syntax,: 1,0,0 refers to all nodes and 0,0,0 refers to the last set of nodes created. surface pset/pset_name/ surface / surface_name / [ifirst,ilast,istride] identifies nodes on the specified surface as indicated by defining surface_name.  The following keywords for surface_name can be used: -all- will identify nodes on all and any surfaces. -interface- will identify all nodes on interfaces. -boundary- will idendtify nodes on external boundary surfaces. write pset/ pset_name or -all- / write / file_name[.vertexset] / [ascii or binary] write or dump a pset node list to a file, options are ascii or binary. zone zonn pset / name or -all- / zone or zonn / file_name[.zone or .zonn] / [ascii] [zone_number] write pset node list to a file (FEHM Flow and Transport code zone file format). By default the zone_number is a number 1-n where n is the number of psets defined in the mesh object. Specify a number value for a single zone file with the zone_number option. zq (deprecrated) pset/pset_name / attribute_name/ ifirst,ilast,istride / [value] / [eq or ne or lt or gt ] replaces: zq / attribute_name / ifirst,ilast,istride / [value] / [eq or ne or lt or gt ] EXAMPLES pset/apset/seq/1,0,0/ associate the pset name apsetwith all points. pset/apset/seq/0,0,0/ associate the pset name apset with the last set of nodes created. pset/apset/ union /pset1,pset2,pset3 associate the pset name apset with the set of nodes which belong to at least one of pset1, pset2, pset3. pset/apset/ inter / pset1,pset2,pset3 associate the pset name apset with the set of nodes which belong to pset1, and pset2, and pset3. pset/apset/ not /pset1,pset2,pset3 associate the pset name apset with the set of nodes which belong to pset1, and do not belong to pset2, and do not belong to pset3 pset/apset/not/pset1 associate the pset name apset with the set of nodes which do not belong to pset1 pset/list/ list the names of all psets pset/mypset/list output the list the node numbers of the members of mypset to the screen and the log file outx3dgen pset/mypset/write/file_name.vertexset/ascii Write list of nodes in pset mypset to an ascii file named file_name.vertexset pset/-all-/write/root_name/ascii Write list of nodes in all psets. root_name is treated as a root name and each pset is written to a separate file beginning with that root. For example, if you have psets named pset1 and pset2, they will be written to files called root_name_pset1.vertexset and root_name_pset2.vertexset. pset/mypset/zone/file_name.zone/ascii Write list of nodes in pset mypset to an ascii file named file_name.zone in FEHM zone file format. The zone number will be 1 if this is the first pset for the mesh object. pset/mypset/zone/file_name.zone/ascii 42 Write list of nodes in pset mypset to an ascii file named file_name.zone in FEHM zone file format. The zone number will be 42 as specified. pset/apset/attribute/itp/1,0,0/10/ge associate the name apset with the points whose type field(itp1) has value greater than or equal to 10 (these would be boundary nodes). pset/apset/ inter / pset1,pset2,pset3 associate the pset name apset with the set of nodes which belong to pset1, and pset2, and pset3. pset/p1/attribute/zic/1,0,0/gt 1.0 pset/p2/attribute/zic/1,0,0/lt 10.0 pset/pboth/ inter / p1 p2 pset/p1/attribute/zic/ 1,0,0 /gt 1.0 pset/pboth/attribute/zic/ pset,get,p1 / lt 10.0 associate the name pboth with all nodes that have zic values between 1.0 and 10.0, note both sets of commands have the same result. pset/mypset/geom/rtz/pset,get,oldpset/0.,0.,0./10.,360.,10. associate the name mypset with the nodes that are members of the pset oldpset and which fall inside the cylinder of radius 10 and height 10 and whose axis is the z-axis. pset/spset/surface/s1/1,0,0 associate the name spset with the set of nodes that lie on the surface s1. pset/spseta/surface/s2/pset,get,spset associate the name spseta with the set of nodes that lie on the surface s2 and which are members of the pset spset This command and the previous command would identify the nodes that are on the intersection of surfaces s1 and s2 and give the name spseta to these nodes. pset/mypset/constraints/3 associate the name mypset with the set of nodes that have 3 constraints ( normally the set of nodes that lie on 3 constrained surfaces – surfaces of type reflect or intrcons) Click here for demos",
    "tags": "pset node selection",
    "url": "/pages/docs/commands/PSET.html"
  },{
    "title": "PSTATUS",
    "text": "PSTATUS See also PSET Saves, removes, retrieves, or replaces a specified set of points, usually the last set of points defined by a generator command or the set of points defined by ifirst,ilast,istride. Note that point sets must be specified in sequence in order for this command to work properly. SYNTAX pstatus Returns current point status counters pstatus /save/name/ifirst,ilast,istride Saves the point status numbers, ifirst,ilast,istride under name pstatus /store/name/ifirst,ilast,istride Overwrites what was in name with ifirst,ilast,istride pstatus/ delete/name Deletes values from name pstatus/get/name Retrieves values from name",
    "tags": "pstatus",
    "url": "/pages/docs/commands/PSTATUS.html"
  },{
    "title": "QUADXY",
    "text": "QUADXY Define an arbitrary, logical quad of points in 3D space with NDIM1 x NDIM2 number of nodes. The four corners of the quad surface are defined in counter clockwise order ( the normal to the quad points is defined using the right hand rule and the order of the points). The nodes can be connected using the createpts/brick/xyz command. SYNTAX quadxy/ndim1, ndim2 /x1,y1,z1/x2,y2,z2/x3,y3,z3/x4,y4,z4 EXAMPLES # create quad sheet define NX 3 define NY 5 cmo/create/moquad/ / / quad quadxy/ NX NY /0. 0. 0./10. 0. 0./10. 20. 0./0. 20. 0. createpts/brick/xyz/ NX NY 1 /1,0,0/connect # read elevations from data file with x y z coordinates # save z to attribute named elev and set to 0 same as template cmo / create/ motmp cmo readatt motmp /xic,yic,zic/1,0,0/ ev_points.dat cmo/addatt/motmp/ elev/VDOUBLE/scalar/nnodes/linear/permanent/ cmo/copyatt/ motmp motmp/ elev zic cmo/setatt/ motmp / zic 0. # assign the z values from the point data to the template interpolate/voronoi/moquad zic/1,0,0/ motmp elev cmo/printatt/moquad/ zic minmax dump/avs/ quad_surface.inp/ moquad This is XY Flat, as shown in first image, a 3 x 5 quad grid on the XY plane where Z = 0. Next, this example shows how point data can then be copied into this quad template. It is important that the quadxy template and the point set have the same NX NY. But node order does not matter as interpolate will assign elevation from nearest node. define X1 2.0 define Y1 40.0 define Z1 4.0 define X2 2.0 define Y2 1.0 define Z2 1.0 define X3 50. define Y3 20. define Z3 40. define X4 55. define Y4 15. define Z4 1. define / NX / 6 define / NY / 1 define / NZ / 24 cmo/create/moquad/ / / quad quadxy/NX NZ/ X1 Y1 Z1 / X2 Y2 Z2 /X3 Y3 Z3 / X4 Y4 Z4 createpts/brick/xyz/NX NY NZ/1,0,0/connect This example shows XZ Twisted, as shown in last image. Create a 6 x 24 quad grid with a twist. The quadxy command enables assignment to the 4 corners such that the surface is not planer. Input LaGriT command file for 3 examples: ex_quadxy.lgi",
    "tags": "quadxy 2D point distribution",
    "url": "/pages/docs/commands/QUADXY.html"
  },{
    "title": "QUADXYZ",
    "text": "QUADXYZ Define arbitrary, logical set of points in 3D(xyz) space, no elements are created. The set of points can be connected into hexahedrals by using the command createpts/brick as shown in the example and image below. This point distribution is defined by 8 points along the xyz axis. This differs from createpts/brick/xyz/ which generates a logicially rectangular distribution defined by 2 points at the mininum and maximum corners of the domain and then generates connectivity for elements. SYNTAX quadxyz/ nx,ny,nz / &amp; x1,y1,z1/x2,y2,z2/x3,y3,z3/x4,y4,z4 / &amp; x5,y5,z5/x6,y6,z6/x7,y7,z7/x8,y8,z8 nx ny nz specifies the number of points between the 1st and last point along each X, Y, Z axis. The number of points will be 1 more than the number of spaces. x1,y1,z1/x2,y2,z2/x3,y3,z3/x4,y4,z4 are the coordinates counter clockwise around the bottom quad face. x5,y5,z5/x6,y6,z6/x7,y7,z7/x8,y8,z8 are the coordinates counter clockwise around the top quad face. EXAMPLES define NPTS 2 cmo/create/mohex quadxyz/NPTS NPTS NPTS/ &amp; 0. 0. 0./1. 0. 0.02 / 1. 1. 0. /0. 1. .1 / &amp; 0. 0. 1./1. 0. 1./ 1. 1. 1. /0. 1. 1.1 createpts/brick/xyz/NPTS NPTS NPTS/1,0,0/connect Create a 2x2x2 point distribution (mesh object with 0 elements). Then use createpts/brick to create connectivity. The result is a single hex with 8 points as shown in the image. Click on image for full size.",
    "tags": "quadxyz point distribution",
    "url": "/pages/docs/commands/QUADXYZ1.html"
  },{
    "title": "QUALITY",
    "text": "QUALITY quality provides a collection of mesh quality measurements. Together with commands in cmo/addatt a good summary of mesh metrics can be reported or used for further mesh optimization. For quality measurments to characterize tet elements by various types, see Quality Measures. SYNTAX quality / [quality_type] / [quality_type_options] DESCRIPTIONS The following are definitions for valid quality-type commands and their quality_type_options. quality with no arguments writes to screen and outx3dgen or lagrit.out logfile reports on the min, max, and counts of aspect ratios and volumes. The aspect ratios are displayed with 7 bins (log scale) with counts of values between .01 and 1. The element volumes are displayed with 5 bins with counts of values between the min and max volumes. quality/aspect / [y] computes the ratio of the radius of the circumsphere to the radius of the inscribed sphere of a tetrahedron. The ratio is multiplied by 3 so that a value of 1 indicates a regular tetrahedron. The display is a binned count of the number of elements whose aspect ratio falls in each of 7 bins (log scale between .01 and 1). y option creates aratio mesh element attribute containing the value of the aspect ratio for each element. Valid element types are tet and tri, hex, and quad (where the length of the hex or quad diagonals are used). quality/edge_ratio / [y] computes the ratio (shortest element edge/longest element edge) and displays a binned count of the min/max edge ratio in each of 7 bins (log scale between .01 and 1). y option creates eratio mesh element attribute containing the value of the min/max edge ratio for each element. quality/edge_min / [y] displays a binned count of the minimum edge lengths displayed log scale between .01 and 1. The binned values are normalized by dividing with the max value. The min and max of the mininum edge length for each element are also reported. y option creates edgemin mesh element attribute containing the value of the min edge length of each element. quality/edge_max / [y] displays a binned count of the maximum edge lengths displayed log scale between .01 and 1. The binned values are normalized by dividing with the max value. The min and max of the maximum edge length for each element are also reported. y option creates edgemax mesh element attribute containing the value of the max edge length of each element. quality/angle / gt OR lt / value / finds the max and min dihedral angles between adjacent faces (or 2D edges) of an element in radians. If the compare option is used, it displays a count of the number of elements with a dihedral angle that is greater than or less than the supplied value. See also cmo/addatt/cmo/ang_ commands for dihedral angle and solid angle calculations. quality/pcc creates an element based attribute called neg_coup_coeff which is a “negative coupling coefficient” indicator. A value of 1 means the coupling coefficient is OK. Anything less than 1 means it is negative. This is useful when viewing a mesh to find where the negative coupling coefficients occur. quality/quad generates some quality measures for quads and displays them after binning them into seven bins. For details on the quad quality measures see cmo/addatt/ quad_quality. quality/taylor/ fieldname / value / creates and displays a count of the number of element-edge pairs with a taylor error estimate value whose absolute value is greater than the supplied value. This creates the attribute quality_taylor with length in attribute quality_taylor_len. quality/volume allows any combination of the quality_type_options for example: quality/volume/ number_of_bins / itetclr / lt | gt | eq | ne | xvalue / eltset,get,ename quality/volume / [number_of_bins] / [ itetclr ] number_of_bins is an integer value controlling the number of bins in which to distribute the volume values for display. if number_of_bins is 0, then binning of distributed volumes is skipped, and only min and max volumes are reported. number_of_bins must be the 2nd argument to quality if used. itetclr is a keyword that will give volume information according to the values in the itetclr attribute. Number_of_bins applies to each tetclr value. For each itetclr value, the volume of elements will be totaled. quality/volume / gt OR lt OR eq OR ne / value will report volumes based on compare operator and given xvalue, for instance quality/volume/lt 0.0/ will report total number of elements with volumes less than 0.0 It may be used in combination of other volume options. if used with itetclr keyword, values will be reported by itetclr value quality/volume / eltset, get, eset_name eltset,get,ename will report volumes on elements in defined eltset can be used in combination with previous options with operations done only on the chosen eltset. itetclr will still report for each of the values in itetclr. EXAMPLES quality/aspect display summary of aspect ratio distribution in 7 bins quality/aspect/ y create attribute aratio and display summary of aspect the aratio distribution quality/angle/gt/179/ return count of elements with a dihedral angle &gt; 179 quality/taylor/boron/1.e-10/ run taylor error estimate and return count of element edge pairs with absolute error greater than 1.e-10 quality/volume quality/volume/ 2 The first call will display summary of volumes with 5 bins, the second command will show summary with 2 bins quality/volume/itetclr quality/volume /itetclr/lt .03 quality/volume/itetclr/eltset,get,e2 All three commands will loop through itetclr (material values) and report a total volume for each itetclr value. The second command will report element volumes lt .03 by the itetclr values. The third command will report element volumes by itetclr values, but only for elements in the set e2 quality quality/ aspect / y quality/ edge_max / y cmo/addatt /cmotri /area_normal/ xyz/ anorm cmo/addatt /cmotri /scalar /xnorm ynorm znorm / anorm cmo/printatt /cmotri / aratio minmax cmo/printatt /cmotri / edgemax minmax cmo/printatt /cmotri / znorm minmax Example calls using quality and cmo/addatt commands to show mesh quality statistics. quality The default with no arguments will calculate and display element volumes and aspect ratios for the current mesh object. Output for the quality command with no arguments: quality epsilonl, epsilonaspect: 1.4360051E-10 2.9612012E-30 -------------------------------------------- elements with aspect ratio &lt; .01: 0 elements with aspect ratio b/w .01 and .02: 0 elements with aspect ratio b/w .02 and .05: 0 elements with aspect ratio b/w .05 and .1 : 0 elements with aspect ratio b/w .1 and .2 : 12020 elements with aspect ratio b/w .2 and .5 : 625891 elements with aspect ratio b/w .5 and 1. : 157053 min aspect ratio = 0.1053E+00 max aspect ratio = 0.7229E+00 epsilonvol: 1.1335396E-05 --------------------------------------- element volumes b/w 0.1667E+02 and 0.3318E+02: 612924 element volumes b/w 0.3318E+02 and 0.6605E+02: 54612 element volumes b/w 0.6605E+02 and 0.1315E+03: 18204 element volumes b/w 0.1315E+03 and 0.2617E+03: 45510 element volumes b/w 0.2617E+03 and 0.5210E+03: 63714 element volumes b/w 0.2617E+03 and 0.5210E+03: 63714 min volume = 1.6666667E+01 max volume = 5.2100000E+02 ----------------------------------------------------------- 794964 total elements evaluated. Click Here For more Examples on Quality Measurements",
    "tags": "quality mesh metrics",
    "url": "/pages/docs/commands/QUALITY.html"
  },{
    "title": "Quality for Tetrahedrons",
    "text": "quality measures to characterize tets as type: equilateral, sliver, wedge, cap or needle elements. Characteristics Equilateral: Characterized by equal edge lengths, aspect ratio 1, and angles near 70 degrees. Sliver: Characterize by small minimum dihedral angle and large maximum dihedral angle but not a large solid angle. Cap: Characterize by large maximum solid angle. Needle: Characterize by small min/max edge length ratio but not small minimum dihedral angle. Wedge: Characterize by small minimum dihedral angle and small min/max edge length ratio. See example input and output files for these elements in test/level01/quality. Characteristic Equilateral Sliver Cap Needle Wedge Picture Coordinates 0 0 00 1 11 0 11 1 0 1 0 0.1-1 0 0.1 0 1 -0.1 0 -1 -0.1 1 0 01 1 00 0 00.75 0.25 0.1 .1 -.1 0 .1 .1 0-.1 0 0 0 0 1 1 0 0 -1 0 0 0 1 0.1 0 1 -0.1 Aspect Ratio 1.0 0.2927 0.07447 0.3429 0.2617 Min Dihedral Angle 7.05288E+01 1.59424E+01 1.57931E+01 5.33585E+01 1.14212E+01 Max Dihedral Angle 7.05288E+01 1.57380E+02 1.49549E+02 8.74394E+01 90.0 Max Solid Angle 3.15863E+01 9.26487E+00 2.60111E+02 5.56182E+01 8.19307E+01 Min/Max Edge Length Ratio 1.0 7.14143E-01 2.59807E-01 1.98030E-01 0.1 Example: LaGriT input file to identify sliver, cap, needle and wedge type elements. *--* ex_id_tet_types *--* Header Begin *--* LAGriT Example Identify Sliver, Cap, Needle, Wedge * Carl Gable * gable -at- lanl -dot- gov * * *--* Create a random point distribution *--* Connect them into a tet mesh *--* *--*---------------------------------------------------- *--* Header End *--* ex_id_tet_types *--* cmo / create / cmo1 / / / tet surface / outer / reflect / box / 0,0,0 / 1,1,1 region / r1 / le outer / mregion / m1 / le outer / createpts / random / xyz / 0.1 / 0,0,0 / 1,1,1 setpts connect dump / gmv / output_tets.gmv * * Compute the various tet quality measures * * Minimum Dihedral Angle, (degree) cmo / addatt / cmo1 / ang_mind / ang_mind * Minimum Dihedral Angle, (radian) cmo / addatt / cmo1 / ang_minr / ang_minr * Maximum Dihedral Angle, (degree) cmo / addatt / cmo1 / ang_maxd / ang_maxd * Maximum Dihedral Angle, (radian) cmo / addatt / cmo1 / ang_maxr / ang_maxr * Minimum Solid Angle, (degree) cmo / addatt / cmo1 / ang_mind_solid / s_mind * Minimum Solid Angle, (radian) cmo / addatt / cmo1 / ang_minr_solid / s_minr * Maximum Solid Angle, (degree) cmo / addatt / cmo1 / ang_maxd_solid / s_maxd * Maximum Solid Angle, (radian) cmo / addatt / cmo1 / ang_maxr_solid / s_maxr * Aspect Ratio quality / aspect / y * ( minimum edge lenght ) / ( maximum edge length ) quality / edge_ratio / y * Edge lenght minimum quality / edge_min / y * Edge length maximum quality / edge_max / y * * Identify Slivers * * Define adjustable parameters to determine cut-off values. * define / MIN_DIHEDRAL / 10.0 define / MAX_DIHEDRAL / 170.0 define / MAX_SOLID_ANG_BIG / 170.0 define / MAX_SOLID_ANG_SMALL / 10.0 define / EDGE_RATIO / 0.1 * eltset / e_dih_small / ang_mind / le / MIN_DIHEDRAL eltset / e_dih_big / ang_maxd / ge / MAX_DIHEDRAL eltset / e_solid_big / s_maxd / le / MAX_SOLID_ANG_SMALL eltset / e_tmp / inter / e_dih_small e_dih_big eltset / e_sliver / inter / &amp; e_tmp e_solid_big * * Identify Cap elements * eltset / e_cap / s_maxd / ge / MAX_SOLID_ANG_BIG * * Identify Needle elements * eltset / e_edge_ratio / eratio / le / EDGE_RATIO eltset / e_dih_small / ang_mind / le / MIN_DIHEDRAL eltset / e_needle / not / e_edge_ratio e_dih_small * * Identify Wedge elements * eltset / e_wedge / inter / e_edge_ratio e_dih_small * * Set up some attributes to tag the elements. * cmo/addatt/cmo1/if_sliv/vint/scalar/nelements/-def-/-def-/-def-/1 cmo/addatt/cmo1/if_cap/vint/scalar/nelements/-def-/-def-/-def-/1 cmo/addatt/cmo1/if_ned/vint/scalar/nelements/-def-/-def-/-def-/1 cmo/addatt/cmo1/if_wed/vint/scalar/nelements/-def-/-def-/-def-/1 cmo/setatt/cmo1/if_sliv/eltset get e_sliver/ 2 cmo/setatt/cmo1/if_cap /eltset get e_cap / 2 cmo/setatt/cmo1/if_ned /eltset get e_needle/ 2 cmo/setatt/cmo1/if_wed /eltset get e_wedge / 2 dump / gmv / tet_types.gmv / cmo1 * begin compare here cmo / status cmo / printatt / / -all- / minmax quality finish",
    "tags": "",
    "url": "/pages/docs/QUALITY_sliver_cap_needle_wedge.html"
  },{
    "title": "RADAPT",
    "text": "RADAPT The command radapt performs r-adaption smoothing on 2D or 3D mesh objects. For a more general version of smoothing see command SMOOTH. This command takes a 2D or 3D mesh object and moves nodes (specifically the nodes selected by ifirst,ilast,istride), without changing the connectivity of the mesh, in order to adapt the mesh to best capture the behavior of a specified field or to an adaption function fadpt supplied by the user. SYNTAX radapt /[position] / esug or mega/ [ifirst,ilast,istride] / [field]/ [refresh or stale] radapt / [position] / esug or mega/ [ifirst,ilast,istride] / [user] SYNTAX for the adaption function subroutine fadpt(xvec,yvec,zvec, imtvec, nvec, time, fvec) xvec, yvec, zvec - Vectors of x, y, and z coordinates of the points where the function is to be evaluated. imtvec - Vector of imt values for the case where function value depends on material type as well as position (ie. functions with discontinuities). nvec - Vector length (= number of places where function is to be evaluated). time - Time (scalar), for time-dependent functions. fvec - Vector of adaption function values. DESCRIPTION There are two adaptive smoothing algorithms available: esug Elliptic Smoothing for Unstructured Grids. This can only be used on triangular 2D mesh objects. If field is specified in the command line, esug will attempt to adapt the grid to the specified field. If the keyword user is specified in the command line, esug will attempt to adapt the grid to an adaption function defined by the user-supplied subroutine fadpt. Ref.: Ahmed Khamayseh and Andrew Kuprat, “Anisotropic Smoothing and Solution Adaption for Unstructured Grids”, Int. J. Num. Meth. Eng., Vol. 39, pp. 3163-3174 (1996) mega Minimum Error Gradient Adaption. For adaptive smoothing purposes, mega can only be used on 3D meshes, and only in conjunction with a user-supplied subroutine fadpt or with a user specified attribute field. If adaption is to an attribute field, then radapt may be instructed to use the interpolation mode associated with the attribute to refresh the attribute values. The default is stale in which case the attribute value will not be updated to reflect the new node position. In either case, the user is cautioned to carefully consider the validity of the data used for the adaption. mega can be used to adapt hybrid meshes as well as tetrahedral meshes. Ref.: Randolph E. Bank and R. Kent Smith, “Mesh Smoothing Using A Posteriori Error Estimates”, SIAM J. Num. Anal. Vol. 34, Issue 3, pp. 979-997, 1997. If field adaption is used, the user has specified a valid field from the current mesh object, and r-adaption is to be based upon this field. Typically, if the field has large gradients or curvature in a particular region, r-adaption using this field will cause nodes to be attracted to the region of interest. (esug adapts especially to large gradients, mega adapts especially to large second derivatives—“curvature”.) If adaption is to an attribute field, then radapt may be instructed to use the interpolation mode associated with the attribute field to refresh the attribute values. The default is stale in which case the attribute value will not be updated to reflect the new node position adaption. In this case, the user should reduce the number of adaption iterations to less than 4, since r-adaption with stale data becomes meaningless. If refresh is specified, the r-adaption routine will automatically interpolate the new field values every iteration, using a call to the doping command. In this case, the number of adaption iterations need not be reduced from the default value of 25. In either case, the user is cautioned to carefully consider the validity of the data used for the adaption. If user is specified, the mesh will r-adapt to the function returned by the subroutine fadpt which must be supplied by the user. If position is specified, it signifies that the x-y-z values of the nodes in the current mesh object will be altered. (Other argument values allow for modification options that are not yet implemented.) If esug is used (currently available in 2D only), the degree of node adaption will depend on the scale of the specified field. In this case, the results of adaption of the grid to the field can be altered by using one or more field commands beforehand to modify the field. For example, by increasing the scale of a field using field /scale, the esug algorithm will produce grids with increased numbers of nodes in the regions where the field experiences relatively large gradients. By volume averaging a field using field/volavg, esug will cause a more gentle form of adaption with a better grading of elements. By composing the values of the field with log or asinh using field /compose, one can cause esug to shift nodes to where the logarithm (or hyperbolic arcsine) of the field has interesting features, rather than where the field itself has interesting features. Note: Since the* mega adaptive smoothing algorithm is rigorously based on error minimization, it is in general of little or no value to modify the adaption function for this algorithm. In particular, rescaling has no effect on the output. The variable MAXITER_SM (Default: 25) can be set using the ASSIGN command before calling RADAPT. This controls the maximum number of adaption iterations to be performed. If convergence is detected beforehand, less iterations will be performed. If field data is allowed to become “stale” during the course of r-adaption, MAXITER_SM should be reduced (e.g. less than 5). EXAMPLES radapt / / esug / 1,0,0 / density Using esug, adapt all nodes in 2dmesh to the density field. Do not update data. radapt / / / 1,0,0 / user doping / user / density / set /1,0,0/ Assuming a default 3D cmo, use mega to adapt the mesh to the adaption function supplied by the user via subroutine fadpt. Afterwards dope (interpolate) the density field with the fadpt function values. assign / / / maxiter_sm / 50 This changes the maximum number of iterations to 50. If radapt detects a sufficient amount of convergence, it will terminate smoothing in less than maxiter_sm iterations. DEMOS with SAMPLE FUNCTIONS The following demonstrate adaptive smoothing using mega. 1. Boron density function Load the file fadpt_boron.f ahead of the LaGriT libraries; this will cause the default fadpt subroutine to be displaced by the one in this file. The result is that now 3D adaptive smoothing will attempt to adapt 3D tetrahedral or hybrid meshes to the boron density function devised by Kent Smith of Bell Labs. This function has a maximum value of 1.1 x 1018, and drops rapidly to zero; the function attains its largest values on a T-shaped region in space and provides very challenging isosurfaces to capture. Two input decks use this function: input.boron.3dtet. This deck generates and adapts a tetrahedral mesh to the boron function. A snapshot of the adapted grid may be seen at boron.png . input.boron.3dhex. This deck generates and adapts a hexahedral mesh to the boron function. A snapshot of the adapted grid may be seen boron_hex.png Fortran subroutine fadpt_boron.f LaGriT command file input.boron.3dtet LaGriT command file input.boron.3dhex 2. Gyroscope function This function fadpt_gyro.f, has large second derivatives near three rings of unit diameter which are aligned with each of the three coordinate planes which pass through the origin. Adaption to this function results in the pulling of the grid towards the rings when running the following two input decks: input.gyro.3dtet. This deck generates and adapts a tetrahedral mesh to the “gyroscope” function. A snapshot of the adapted grid may be seen at gyro.png input.gyro.3dhex. This deck generates and adapts a hexahedral mesh to the “gyroscope” function. A snapshot of the adapted grid may be seen at gyro.hex.png Fortran subroutine fadpt_gyro.f LaGriT command file input.gyro.3dtet LaGriT command file input.gyro.3dhex",
    "tags": "radapt, adaptive smoothing",
    "url": "/pages/docs/commands/RADAPT.html"
  },{
    "title": "READ",
    "text": "READ This command reads data or a mesh into the active Mesh Object. AVS, LaGriT, and GMV formats are supported.  The other formats may be used, but no guarantees are made about their capabilities. read/ avs read AVS UCD format files read/ lagrit read lagrit restart file with mesh object defined read/ gmv read General Mesh Viewer GMV format files read/ gmvfreeformat ascii gmv files to be read with read(*) read/ sheetij read elevations into quad surface cmo / readatt/… read tabular data spreadsheet style into node attributes read/ zone or zonn or zone_element read node numbers from zone or zonn file read/ gocad read GOCAD file, single instance of mesh only read/ iges_grid IGES file with surfaces, curves, points in NURBS format read/ ngp read/ vrml read/ datex EXAMPLES read / avs / myfile / mesh_object_name read / myfile.inp / mesh_object_name read / mesh.gmv / mesh_object_name Short form syntax does not require file type as the second token. This is supported for the suffixes avs inp gmv lg lagrit See links to various formats for more detailed explanations and examples.",
    "tags": "",
    "url": "/pages/docs/commands/READ.html"
  },{
    "title": "RECON",
    "text": "RECON This command flips connections in the mesh to get restore the Delaunay criterion or to improve element shapes. The standard method used by recon is to flip connections based on the in-sphere test (the circumsphere of a tetrahedral element should contain no other nodes). Additional flipping criteria are available. SYNTAX recon / [1 or 0] / [damage] / [checkaxy] 0 or no arguments is the default and specifies that no points are to be added on the boundaries. 1 adds points on the boundaries if needed to make Delaunay (recommended for 2D meshes only). If damage is specified then flips on exterior boundaries are checked to verify that the maximum depth of deformation of the external boundary does not exceed the value of damage. The default value of damage is 1% of the problem size. This setting prevents connecting across corners if the external boundary is a reflective box. If checkaxy is provided, then 2D flips are suppressed if the new triangles would have xy-projected areas less than EPSILONA. Additional Settings cmo/setatt//ivoronoi/-2 The Minimum Error Gradient Adaption (mega) can be invoked by changing the value of the mesh object variable ivoronoi to -2. The effect of this option is to generate well shaped elements; however the grid will not be Delaunay. cmo/setatt//ivoronoi/ 2 If the user has a function to used for adaptive reconnection this option is available by setting the code variable ivoronoi to 2. The user will have to supply an external function. cmo/setatt//ivoronoi/ 5 recon is called by other LaGriT commands such as massage. To disable recon set ivoronoi to 5. cmo/setatt//iopt2to2/ 0 recon will by default reconnect across interface edges. To restrict reconnection to interior faces and exterior boundary faces, set iopt2to2 to 0. EXAMPLES recon attempt to restore Delaunay recon / 1 for 2d meshes add nodes on boundaries to guarantee Delaunay recon / / .001 reconnect limit interface and boundary damage to a maximum of .001 recon/0/ .001 / checkaxy for 2d meshes reconnect, limiting damage to a maximum of .001 and preventing creation of any negatively oriented or small triangles (with respect to the xy-plane).",
    "tags": "recon, Delaunay",
    "url": "/pages/docs/commands/RECON.html"
  },{
    "title": "REFINE",
    "text": "REFINE The refine command is used to create more elements. The method in which these new elements are formed is based on the refine_method chosen. The refine criteria used in these methods are defined at Grid Refinement Section. SYNTAX refine/refine_method/ [field]/ [interpolation]/refine_type /ifirst,ilast,istride/xvalue/xvalue2/xvalue3/inclusive_flag/ refine/roughness ///edge/ifirst,ilast,istride/distance/surface_name/exclusive or inclusive refine/edge_list ///edge/ end_points refine/interface /// edge/pset,get,psetname refine / eltset or element_set / eltset,get,esetname Refine Methods junction will refine object where field crosses xvalue constant will refine object where field &gt; xvalue delta will refine object where delta(field) &gt; xvalue lambda will refine object where lambda(field) &lt; xvalue maxsize will refine object where object &gt; xvalue. Size refers to volume for tets, area for face, and length for edges. aspect will refine where aspect ratio &lt; xvalue addpts will refine explicitly by adding a set of nodes defined in pset,get,psetsname rivara edges longer than xvalue will be refined according to the principle that a refined edge candidate is the longest edge in any element that contains it. This results in a recursive refinement procedure that adds neighboring edges to the refinement candidate list until no neighbor edge is longer then the candidate. refine_type must be edge. Arguments field and interpolation are ignored. This method of refinement, when used with a pset, produces a nicely graded mesh. rivara_boundary applies the rivara algorithm, but will only bisect edges on external boundaries. rivera_truncated applies the rivara algorithm, but restricts the neighborhood search to the edges in the selected pset. If the pset is the entire mesh, this method has the same behavior as rivara. roughness will refine based on the distance of the endpoint of an edge to the plane determined by the synthetic normal with respect to a specified surface at the other endpoint of the edge. This is intended to increase refinement on surfaces near corners or around sharp bends in surfaces. xvalue is the distance, the surface_name must follow the xvalue distance argument. edge_list will bisect a set of edges specified by the node numbers of the endpoints of the edges. refine_type must be edge followed by a list of end_points making up the edge_list. element_set or eltset will refine all elements in a specified element set. The mesh object may be tri, quad, tet or hex. Internally a node set will be created from the chosen elements. Because of the conversion from element set to point set, it is possible that some element not in the original element set will have all of its nodes as members of the internally constructed points set and hence will be refined. The default refine_method is constant; refine_type is element; inclusion_flag is exclusive. Their are no other arguments after the element set name. interface will bisect a set of non-interface edges of tets all of whose vertices are interface nodes. Valid only for 3D tetrahedral grids and is useful to ‘unlock’ tetrahedra that are stuck because all of their vertices lie on interface surfaces.  After the refine operation these tetrahedral will be replaced by tetrahedra containing a vertex that is not on the surface - thus allowing later smooth or massage operations more freedom to improve the grid. The following are unavailable or untested: spawn spawns new nodes at the locations given. It finds the existing edge that is closest to the desired node It then refines that edge and moves the resulting node to the desired location provided that the move does not invert any elements. cel calls CEL (create on edge length). Takes a mesh object and bisects edges that (i) have both endpoints in the list of selected mass points, and (ii) have length greater than TOLLENGTH. The process is recursive in that new nodes are added to the list of mass points, meaning that newly created edges can be refined until all the edges in the mesh have length less than TOLLENGTH. This leads to recursive refinement with nondegrading element aspect ratios. minsize, lambdade, and rmelements are no longer supported. Refine Type refine_type specifies what object will be refined and how that object will be refined: element or tet in 3D will refine elements by placing a point in the center of the element. element in 2D (triangle) will refine element by refining all edges of the triangle. face in 3D will refine facets by placing a point in the center of the facet. face in 2D (triangle) will refine face by refining all edges of the face. edge will refine edges by placing a point on the midpoint of the edge. faceedge will refine facets by refining all edges of the facet. tetedge will refine elements by refining all edges of the element. Refine Options field must refer to a previously defined attribute of the current Mesh Object. interpolation specifies how to interpolate the field to give field values to the new nodes created. The valid types are linear, log, and sinh. range is the selection of points designated by node numbers for ifirst,ilast,istride or pset,get,pname. 1,0,0 will select all nodes in the Mesh object. xvalue [/xvalue2/xvalue3/] is the real number usually indicating a size for the different refine methods. Most of the refine methods do not use the second and third values so their argument positions will be empty ///. inclusion_flag is an optional flag specifing if refinement is an inclusive or an exclusive operation. By default, all operations are exclusive. For inclusive, if an edge refinement is specified restricted to a pset, then an edge is eligible for refinement if either or both of the end points belong to the pset selected. If the inclusion_flag is exclusive then both end points must be in the pset. The implemented values are inclusive and exclusive. QUADTREE and OCTREE REFINEMENT Quad and hexahedral elements may be refined creating quad tree and octree meshes. Three new Mesh object attributes are added during this operation. The refine_type must be element. The refine_method must be constant, junction or maxsize. The values for /xvalue/xvalue2/xvalue3/ should be /-1.,0.,0./. For an element set, use the shortened syntax refine/element_set/eltset,get,esetname. The element attributes added to the Mesh object are: itetlev is an integer attribute with the level of refinement. An unrefined mesh element has itetlev(ie)=0, one level of refinement itetlev(ie)=1, etc. itetkid is a pointer to a child element number. If nothing has been done to change element numbering, it is element number of the first child element created and the rest of the children are in sequence after the first child. If itetkid(ie)=0 , the element has not been refined further. itetpar is a pointer to the parent element at refinement level. itetlev(ie)-1. Quad meshes will have 4 children for each refined element. Hex meshes will have 8 children. The children are generated sequentially; The first child will contain the first local node of the parent element, the other elements are created in the order shown in this diagram. For example in the picture below, element e1 is refined to create 8 children, c1, c2, c3, c4, c5, c6, c7, c8. The table gives the octree attribute values for each of the elements. Element # itetlev itetkid itetpar   c1 1 0 2 0 c1 2 1 0 1 c2 3 1 0 1 c3 4 1 0 1 c4 5 1 0 1 c5 6 1 0 1 c6 7 1 0 1 c7 8 1 0 1 c8 9 1 0 1 One can control refinement so that a hex is broken into either 8, 4 or 2 elements and a quad is broken into either 4 or 2 elements. This is controlled with the principal refine direction choice prd_choice parameter. This syntax works assuming imt values are greater or equal to zero with principal refine direction chosen through a combination of “123” prd_choice indicators as defined below. The command line used is: refine/constant/itetclr/linear/element/1,0,0/-1.,0.,0./exclusive/amr prd_choice or with element selection (based on pset and inclusive/exclusive options): refine/constant/imt1/linear/element/pset,get,pname/-1.,0.,0./inclusive/ amr prd_choice The parameter prd_choice indicates the chosen principal refinement direction based on the local hex element topology as defined by edge numbers, for instance, quad edge 1 is in the x direction relative to the local topology. 1 refine along x direction, 1 hex-&gt;2 hex, 1 quad-&gt;2 quad (quad edges 1 and 4) 2 refine along y direction, 1 hex-&gt;2 hex, 1 quad-&gt;2 quad (quad edges 2 and 3) 3 refine along z direction, 1 hex-&gt;2 hex, 1 quad-&gt;4 quad 12 refine along x and y direction, 1 hex-&gt;4 hex, 1 quad-&gt;4 quad 13 refine along x and z direction, 1 hex-&gt;4 hex, 1 quad-&gt;4 quad 23 refine along y and z direction, 1 hex-&gt;4 hex, 1 quad-&gt;4 quad 123 refine xyz with prd amr routines, 1 hex-&gt;8 hex, 1 quad-&gt;4 quad 0 refine xyz with default amr refinement, 1 hex-&gt;8 hex, 1 quad-&gt;4 quad EXAMPLES pset / prefine / union / prefine1 prefine2 prefine3 eltset / erefine / inclusive / pset get prefine refine/ eltset / eltset,get,erefine will octree refine hex elements belonging to the set of points named prefine refine / maxsize ///edge /pset,get,something / .25 will refine element where edge is longer than .25 refine/constant/concentration/log /edge/1,0,0/25.0 /// inclusive will refine where concentration is greater than 25. refine /addpts///tet /pset,get,newpoints/ refine explicitly by adding the new nodes defined in the set newpoints refine /rivara///edge/pset,get,p1/.5///inclusive refine all edges containing at least one node in pset p1 that are longer than .5. Using the ‘rivera’ algorithm may result in edges not containing nodes in the pset to be refined. refine/rivara_truncated///edge/pset,get,p1/.5///exclusive rivera_truncated, exclusive will refine only edges both of whose endpoints are in the selected pset named p1 refine/rivara_boundary///edge/1,0,0/.25 rivara_boundary will only refine boundary edges. refine/roughness///edge/1,0,0/.28/ptop/inclusive will refine based on .28 distance to the surface named ptop. refine/edge_list///edge/1 2 23 47 will refine the edge with end points 1 and 2 AND the edge with end points 23 and 47. eltset / elem3 / id_elem1 / eq / 3 refine/eltset / eltset,get, elem3 will create a node set from the element set named elem3 and refine using the constant option. refine/constant/imt1/linear/element/pset,get,pbox/-1.,0.,0./inclusive create a quadtree refined quad mesh eltset / elm2 / itetclr / eq / 2 pset/ pelm2 / eltset elm2 refine/constant/imt1/linear/element/pset,get,pelm2/-1.,0.,0./inclusive/amr 12 refine the material 2 elements of a hex mesh , do not refine in the Z vertical direction refine/constant/imt1/linear/element/pset,get,pelm2/-1.,0.,0./inclusive/amr 3 refine the material 2 elements of a hex mesh , refine only in the Z vertical direction",
    "tags": "refine, junction, addpts, rivara, interface",
    "url": "/pages/docs/commands/REFINE.html"
  },{
    "title": "Section Grid Refinement Criteria and Algorithms",
    "text": "Grid Refinement and Criteria - Algorithms The Refine command for the grid generation code LaGriT uses various criteria to tag grid elements for refinement or derefinement. When utilizing unstructured grids generated by LaGriT for applications such as solution of partial differential equations (PDE) for physical systems, it is desirable to modify the grid in order to optimize it for the particular problem based on several principles. The goal is to produce a better solution by creating better grid elements in various regions of the domain of the PDE’s. This can involve physical criteria such as choosing smaller elements where physical variables are rapidly changing or larger elements where the variables are relatively constant in order not to waste computational effort. Grid elements can also be chosen on various geometric criteria related to their shape such as different formulations of an aspect ratio. In time dependent problems, it may be necessary to refine and derefine the grid after each time step in order to follow various changing phenomena such as moving concentration fronts, shock waves, or advancing oxide layers. These factors make mesh refinement crucial to the practical solution of physical modeling problems. We therefore will detail several algorithms that are currently implemented for identifying which grid elements should be refined or derefined based on geometric and physical criteria. New algorithms will be added to this list and the current ones modified as we obtain feed back from users. I. Edges: Each edge is tested separately to see if it should be tagged for refinement or derefinement II. Faces: Each face is tested separately for refinement or derefinement. III. Tets: Each tetrahedron is tested separately for refinement or derefinement IV. Face Edges: Same algorithms of the Faces category except all edges of the face are tagged for refinement or derefinement if the condition is met for the  face. V. Tet Edges: Same algorithms of the tet category except all edges of the tet are tagged for refinement or derefinement if the condition is met for the tet.",
    "tags": "Grid Refinement Criteria Algorithms",
    "url": "/pages/docs/REFINE1.html"
  },{
    "title": "REGION",
    "text": "REGION Define a geometric region from a set of surfaces by logically combining surfaces names. REGION is used together with SURFACE and MREGION to set mesh object geometry and materials. See Examples below. Defining a  region will cause the information associated with this geometry region to be stored under the name of the geometry of the current mesh object.  Releasing the region will remove this information. The defined mesh object geometry can be named with the GEOMETRY command. SYNTAX region/ region_name/ region_operators region/ region_name/ release To define a geometry region, use operators with surfaces according to the following rules. The operators or, and, and not mean union, intersection, and complement respectively and are applied to surfaces. Parentheses are operators and are used for nesting. Spaces are required to separate operators and parentheses. The operators lt, le, gt, and ge are applied to mesh object surfaces according to the following rules: lt if the surface following is a volume then lt means inside not including the surface of the volume. If the surface is a plane or a sheet lt means the space on the side of the plane or sheet opposite to the normal not including the plane or sheet itself. le if the surface following is a volume then le means inside including the surface of the volume. If the surface is a plane or a sheet le means the space on the side of the plane or sheet opposite to the normal including the plane or sheet itself. gt if the surface following is a volume then gt means outside not including the surface of the volume. If the surface is a plane or a sheet gt means the space on the same side of the plane or sheet as the normal not including the plane or sheet itself. ge if the surface following is a volume then ge means outside including the surface of the volume. If the surface is a plane or a sheet ge means the space on the same side of the plane or sheet as the normal including the plane or sheet itself. Internal interfaces should be included in exactly one region (using le and ge). In the event of conflicting region commands, the one occurring last in the input stream takes precedence. EXAMPLES region/reg1/ le sphere1 and ( lt plane1 or gt plane2 ) region/reg2/ le sphere1 and ( ge plane1 and le plane2 ) region/reg1/release Define regions named reg1 and reg2 inside sphere1 and relative to plane1 and plane2. Release the regions named reg1. cmo/create/cmo surface/outside/reflect/box/0,0,0/3,2,1 region/all/le outside mregion/all/le outside createpts/xyz/3,3,3/0,0,0/3,2,1/1,1,1 setpts connect Very simple application of the region and mregion commands to create a single material box shaped mesh. # Define geometry cmo / select / CMO_IN geometry / create / stack_geom # define surfaces for CMO_IN cmo / select / CMO_IN surface / s0 /reflect / sheet / mo0 surface / s1 /reflect / sheet / mo1 surface / s2 /reflect / sheet / mo2 surface / s3 /reflect / sheet / mo3 surface / s4 /reflect / sheet / mo4 surface / s5 /reflect / sheet / mo5 surface / s6 /reflect / sheet / mo6 # define geometry regions # all internal interfaces are defined # and are included once only region / r_below / le s0 region / r1 / ge s0 and lt s1 region / r2 / ge s1 and lt s2 region / r3 / ge s2 and lt s3 region / r4 / ge s3 and lt s4 region / r5 / ge s4 and lt s5 region / r6 / ge s5 and lt s6 region / r_above / ge s6 # define material regions # internal interfaces not included mregion / mr_below / lt s0 mregion / mr1 / gt s0 and lt s1 mregion / mr2 / gt s1 and lt s2 mregion / mr3 / gt s2 and lt s3 mregion / mr4 / gt s3 and lt s4 mregion / mr5 / gt s4 and lt s5 mregion / mr6 / gt s5 and lt s6 mregion / mr_above / gt s6 # Finished building geometry Define geometry and material regions based on surface grids read into mesh objects named mo0, mo1, … mo6. The result are regions stacked in layers such that nodes found equal to surface s0 are the interface nodes between regions r1 and r2. Nodes between surfaces s0 and s1 are in region r1 and have the material labeled mr1. And so on. This mesh geometry has the name stack_geom.",
    "tags": "region, mregion, surface",
    "url": "/pages/docs/commands/REGION.html"
  },{
    "title": "REGNPTS",
    "text": "REGNPTS Generates points in a region previously defined by the region command. The points are generated by shooting rays through a user specified set of points from an origin point, line, or plane and finding the intersection of each ray with the surfaces that define the region. The region must exist for the current mesh object and defined with surfaces using SURFACE and REGION commands. Points are distributed on boundaries if the region was defined using ge or le to define the interface or boundary. Only surface intersection points are created if ptdist is a keyword as defined below. If another region intrudes upon the regnpts region so that the regpts region is divided into more than one piece, points that fall inside the intruding region are not distributed. SYNTAX regnpts/region_name/ptdist/ifirst,ilast,istride/geom/ray_points /irratio,rrz,maxpenetr regnpts/region_name/ptdist/ifirst,ilast,istride/xyz/x1,y1,z1/x2,y2,z2/x3,y3,z3/irratio,rrz/maxpenetr regnpts/region_name/ptdist/ifirst,ilast,istride/rtz/x1,y1,z1/x2,y2,z2/irratio,rrz/ regnpts/region_name/ptdist/ifirst,ilast,istride/rtp/xcen,ycen,zcen/irratio,rrz,maxpenetr regnpts/region_name/ptdist/ifirst,ilast,istride/pointsifirst2,ilast2,istride2/irratio,rrz/ maxpenetr region_name must exist for the current mesh object as described above. ifirst,ilast,istride are the points to shoot rays through. The range 1,0,0 means all points, a named set may also be used with pset,get,psetname. Actions Based on pdist Type If ptdist is a one of the keywords inside, in, out, outside, or both surface points are created regardless of region ownership of the interface or boundary surface – if a ray encounters a region more than once, the appropriate surface intersection point(s) is generated for each encounter. If ptdist if a real value, then points are distributed at that distance along the ray, up to a maximum of maxpenetr points along the ray (in addition to any interface points that may be created). If the ray encounters a region more than once, multiple sets of points are generated. irratio / rrz is ignored when ptdist is a real value. If ptdist is an integer, then that many points are evenly distributed along the ray in the region. irratio / rrz defines the ratio zoning used to distribute the points. irratio = 1: the point distribution is adjusted so that the ratio between successive pairs of points is rrz. irratio = 2: points are distributed by equal volumes depending on the geometry type. irratio = 3: ratio zoning is calculated on the longest ray; then this length is applied to all the rays. Ray Start Based on geom xyz shoot rays from normal of plane defined by cartesian coordinate points 1, 2, and 3. rtz shoot rays perpendicular from the cylinder line defined at point 1 to point 2. rtp shoot rays from spherical center from the given point. EXAMPLES region/top/ ge pbot and le ptop and ge plft and le prgt &amp; and ge pbck and le pfrt and gt cutplane / regnpts/top/3/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/0,0/ Create rays between points in rayend and the plane. Distribute 3 points along these rays in the region top add one point at the upper external boundary for each ray. Then add one point at the upper external boundary for each ray. regnpts/InWF_SOIL_REGION/10/pset,get,InWF_SOIL_RAYEND/rtz/-0.5000000,42.42380,2 &amp; 9.98730/-0.5000000,82.67780,29.98730/-0.5000000,82.67780,100.0000/0,0/ ` Create cylindrical points in region defined as InWF_SOIL. # define surfaces surface/lay1/intrface/plane/ 0 0 119 / 10 0 119 / 10 100 119 # create regions region/reg1/ le box1 and le lay1 # create ray end points createpts/xyz/ 1 3 14 / -5 0 0 / -5 100 119 / 1 1 1 pset/rayend/seq/1 0 0 # remove duplicate points if they exist filter/1,0,0 ; rmpoint/compress # shoot points into volume in region reg1 regnpts/reg1/100/pset get rayend/xyz/ 300 0 0/ 300 10 0/ 300 10 1/ 1 1. # remove ray end points rmpoint/pset get rayend filter/1,0,0 rmpoint/compress # color point imt and connect setpts connect Typical set of commands using regions and ray shooting to create a mesh. Click here for Examples Click here for Tutorial using ray shooting methods",
    "tags": "regnpts, create points, ray shooting",
    "url": "/pages/docs/commands/REGNPTS.html"
  },{
    "title": "REORDER",
    "text": "REORDER This command will reorder a mesh object according to a designated permutation vector. This can be used after the SORT command to reorder a mesh based on a sort key. The command will decide to reorder nodes or elements based on the length of the permutaion vector. When elements are reordered all element attributes are also reordered. Mesh object arrays itet and jtet are updated. When nodes are reordered, all node based attributes are also reordered. Permanent mesh object attribute arrays such as isn are also updated. SYNTAX reorder/mo_name/sort_key/ reorder / -def- /sort_key/ sort_key is the permutation vector - i.e. an integer node/element based mesh object attribute. The permutation attribute can be any integer vector nnodes or nelements long with min value = 1, max value = nnodes/nelements and no repeated entries. EXAMPLES createpts / median sort/ mo_pri /index/ascending/ ikey /itetclr xmed ymed zmed reorder / mo_pri / ikey sort and reorder the mesh mo_pri based on itetclr values and cell center location xmed, ymed, zmed. This will arrange into columns (after itetclr sort).",
    "tags": "reorder, sort",
    "url": "/pages/docs/commands/REORDER.html"
  },{
    "title": "RESETPTS",
    "text": "RESETPTS Reset values for node imt material color, itp type, or isn parent-child for doubly defined nodes. SYNTAX resetpts resetpts/parent resetpts/itp resetpts/cell_color/ [1,0,0 or integer_node_color] resetpts or resetpts/parent remove child points. the parent child flags are reset. All child points are eliminated and the connectivity list isn is corrected to reference only the parent points. This parent-child relationship is established by the settets command. resetpts/itp set node type itp from connectivity of the mesh object. The node itp (also known as itp1) array is reset to indicate whether each node is in the interior (0), on an interior interface (2), on a reflected boundary (10), or on a reflected interface boundary (12) . It is good practice to update this array anytime the mesh object is changed, or to be certain that boundary and interfaces are correctly set for a command that depends on it. resetpts/cell_color/ set node imt values from element colors itetclr. If no arguments are given, then, loop through all itetclr values in ascending order, and reset node imt to associated element itetclr value. Note that if parent-child nodes do not exist, then an interface node will have its imt value set to the largest value of itetclr of all elements that contain this node. 1,0,0 is the range of element itetclr values itetclr_min, itetclr_max, itetclr_stride where 1,0,0 means all. This will loop through and reset node imt values. Node colors are reset only for nodes in elements that fall in the range selected. integer_node_color reset node imt for nodes with imt equal to integer_node_color, use the itetclr of the element containing the node. Only nodes with node color imt equal to this value will be set to its element itetclr value. This will introduce a bias since the nodes are modified in the order of the element numbering. To give some control over the bias the user can specify a negative value for integer_node_color. In that case, the element loop is reversed and goes from largest to smallest element number. EXAMPLES: resetpts/itp Set node type array itp from connectivity of mesh includes outside boundary and interior interface nodes based on itetclr values. resetpts/cell_color/ 1 Replace node color for nodes that currently have imt value of 1 by the cell color of an element containing the node; this is done by looping through all the elements in cell color order, so that the value of imt will be the largest itetclr of the set of elements containing this node. resetpts/cell_color/ resetpts/cell_color/ -1 resetpts/cell_color/1,3,1 Thi first command will loop through all element colors and reset all node imt values and replace node color for nodes that currently have imt value of 1 by the cell color of an element containing the node; this is done by looping through all the elements in desending cell color order, so that the value of imt will be the smallest itetclr of the set of elements containing this node. The second command does the same thing as the first, in reversed order. The third command loops through colors from itetclr=1 to itetclr=3. cmo/select/cmotet resetpts/parent rmpoint compress filter/1,0,0 These commands will reset double defined nodes in a mesh to be singly defined. This is used when writing mesh files for applications that can not handle duplicate nodes. This will reset the parent-child arrays, then remove duplicate nodes from the mesh object records so they are not written to files.",
    "tags": "resetpts, itp",
    "url": "/pages/docs/commands/RESETPT.html"
  },{
    "title": "RM",
    "text": "RM Removes any points that are within the specified point range and specified volume of space. This command is seldom used but included here for backward compatibility. A more typical set of commands for removing points is the combination of PSET with RMPOINT/pset,get,pname. Note that the points that are removed become dudded out (point itp set to 21) and are not removed from the mesh object data arrays. SYNTAX rm / xyz /ifirst,ilast,istride/xmin,ymin,zmin/xmax,ymax,zmax/ [xcen,ycen,zcen] rm / rtp /ifirst,ilast,istride/ r1,t1,p1 / r2/t2/p2/ [xcen,ycen,zcen] rm / rtz /ifirst,ilast,istride/ r1,t1,z1 / r2,t2,z2/ [xcen,ycen,zcen] Geometry Options xyz Cartesian coordinates defined by minimum and maximum of the coordinates. rtp Spherical coordinates defined by the center point. The sperical shell or sperical section given by radius r1 to r2, and angles theta t1 to t2 and angles phi p1 to p2. The value of theta is the angle with respect to the Z-axis and phi is the angle in the XY-plane with respect to the X-axis. rtz Cylindrical coordinates defined by the center line points. The cylinder or cylindrical shell given by radius r1 to r2, angle theta t1 to t2 and height z1 to z2. The value of theta is the angle in the XY- plane with respect to the x-axis. In cylindrical coordinates the cylinder always lines up along the z axis; use the coordsys command before issuing the rm command if the points to be removed are not aligned with the z-axis; then issue a final coordsys command to return to normal. ifirst,ilast,istride is the selected point set range where 1,0,0 means all. The pset,get, pname convention can be used. EXAMPLES rm/ xyz /1,0,0/ 2.,2.,2./4.,4.,4./ 0.,0.,0. rm/ rtz /1,0,0/ 0.,0.,0./1.,360.,10./ 0.,0.,0.",
    "tags": "rm, remove",
    "url": "/pages/docs/commands/RM.html"
  },{
    "title": "RMMAT",
    "text": "RMMAT This routine is used to remove points that are of a specified material value (itetclr for elements or imt for nodes). Elements with the specified material value are flagged by setting the element material type negative. They are not removed from the mesh object. Remove the dudded elements and update the mesh object arrays with the command RMPOINT/compress. SYNTAX rmmat/material_number/ rmmat/material_number/[all or node or element]/ [exclusive] material_number is the itetclr integer value to remove from the mesh object. Elements with the itetclr=material number are flagged by setting the element material value negative. no arguments or all removes nodes with imt = material number and removes elements with itetclr= material number. node removes nodes with imt = material number. element removes elements with itetclr= material number. exclusive removes everything except nodes with imt =material and removes everything except elements with itetclr= material number. EXAMPLES rmmat/ 2 rmpoint/compress Tag elements in mesh object with material values of 2 then remove elements and update the mesh object. Click here for Examples",
    "tags": "rmmat, remove material",
    "url": "/pages/docs/commands/RMMAT.html"
  },{
    "title": "RMPOINT",
    "text": "RMPOINT Tag or remove nodes and elements from a mesh.   Dudded nodes, or nodes marked for removal have their  itp array mareked with ifitpdud (21). Dudded elements have a negative value for the first entry in the itet vertex list.  The tagged mesh object nodes and elements are treated as invisible until they are removed from the mesh object.  SYNTAX rmpoint/ifirst,ilast,istride/[exclusive or inclusive ] rmpoint/compress/ rmpoint/zero_volume/threshold rmpoint/element [tet_list or eltset,get,esetname] rmpoint/womesh rmpoint/sparse /ifirst,ilast,istride / [exclusive or inclusive ] does not remove but marks the selected nodes and elements for removal. If exclusive (default), an element is marked only if all of its nodes are in the selection. If inclusive, any element with a node from the selected set will be marked.   compress remove and update all tagged nodes and elements. This will update arrays and material-wise resequences all remaining nodes. This will change the node ordering and numbers of the mesh. zero_volume will remove elements whose volumes are less than or equal to the specified threshold.  element will remove all marked (negative itet) elements from the mesh. Elements can be specified by a tet_list or eltset,get,esetname. womesh will delete stray nodes that are not connected to any element and that are not parent nodes. sparse is to be used with caution and requires reconnection when done. EXAMPLES rmpoint/ pset,get,pset1 rmpoint/compress Mark all the nodes in pset1 for removal.  Remove elements all of whose vertices are members of pset1. Remove all marked nodes and update the mesh object arrays. rmpoint/zero_volume/1.e-16 rmpoint/compress Remove all elements with volumes less than 1.e-16 rmpoint/element/27 259 1009 rmpoint/compress Remove the three specified elements rmpoint/element/eltset,get,e_mat1 rmpoint/compress Remove the elements in the element set named e_mat1",
    "tags": "rmpoint",
    "url": "/pages/docs/commands/RMPOINT.html"
  },{
    "title": "RMREGION",
    "text": "RMREGION Removes points that lie within the specified region. See REGION. SYNTAX rmregion / region_name / region_name is the name of the previously defined geometry region. EXAMPLES surface/insurf/intrface/sphere/0.,0.,0./.1/ region/sph_inside/ le insurf / rmregion/sph_inside rmpoint/compress resetpts/itp Remove nodes and elements defined by the sphere shaped region sph_inside. First the region nodes are marked for removal, rmpoint/compress removes the marked nodes. The command resetpts/itp updates the itp boundary array.",
    "tags": "rmregion",
    "url": "/pages/docs/commands/RMREGION.html"
  },{
    "title": "RMSPHERE",
    "text": "RMSPHERE Removes a sphere of points from a point distribution. SYNTAX rmsphere / inner_radius/ outer_radius/ xcen,ycen,zcen/ inner_radius and outer_radius are the distances from sphere center point. xcen,ycen,zcen is the sphere center point. EXAMPLES rmsphere / 0. .1 / 0. 0. 0. rmpoint/compress resetpts/itp Remove nodes and elements defined by the sphere at zero coordinates and within a distance of .1. First the nodes are marked for removal, rmpoint/compress removes the marked nodes. The command resetpts/itp updates the itp boundary array.",
    "tags": "rmsphere",
    "url": "/pages/docs/commands/RMSPHERE.html"
  },{
    "title": "RMSURF",
    "text": "RMSURF Removes points that lie in, on or in and on the specified surface. The surface must be defined for the current mesh object, see SURFACE. SYNTAX rmsurf / surface_name / operation surface_name is the name of the previously define surface. operation can be one of the following: lt only points inside the surface are removed eq only points on the surface are removed le all points inside or on the surface are removed",
    "tags": "rmsurf",
    "url": "/pages/docs/commands/RMSURF.html"
  },{
    "title": "ROTATELN",
    "text": "ROTATELN Rotates a point distribution about a line. SYNTAX rotateln/ifirst,ilast,istride/[no]copy / x1,y1,z1/x2,y2,z2/ theta/xcen,ycen,zcen/ ifirst,ilast,istride is the node range selected by node numbers or pset,get,pname. nocopy keeps only the rotated points, the node count does not change. copy keeps a copy of the original unrotated points, as well as the rotated points. The new points will have the rotated coordinate values but no other mesh attributes will be set for these points. x1,y1,z1 / x2,y2,z2 are the end points of the rotation line and must extend beyond the boundaries of the selected point set. theta in degrees is the angle of rotation whose positive direction is determined by the right-hand-rule, that is, if the thumb of your right hand points in the direction of the line (1 to 2), then your fingers will curl in the direction of rotation. xcen,ycen,zcen is the point where the line can be shifted to before rotation takes place. EXAMPLES define / SIZE / 10.0 cmo / create / mo01 / / / hex createpts / xyz / 2, 2, 10 / 0, 0, 0 / SIZE, SIZE, SIZE / 1 1 1 rotateln / 1 0 0 / nocopy / 0 0 0 / 0 0 5 / 90 / 0, 0, 0 Create a cube of points and rotate it 90 degrees about the z-axis. createpts/brick/xyz/NX NY NZ /X0 Y0 Z0 / X1 Y1 Z1 /1,1,1 cmo/setatt/mohex imt 1 # Define Degree of rotation around line along y axis # Color each set after it is rotated define ROTDEG 20. rotateln/1,0,0/copy/ 0. 500. 0./ 0. -1. 0. / ROTDEG pset/ prot1 / seq /0,0,0/ cmo/setatt/mohex/imt/pset,get,prot1 2 define ROTDEG 110. rotateln/1,0,0/copy/ 0. 500. 0./ 0. -1. 0. / ROTDEG pset/ prot2 / seq /0,0,0/ cmo/setatt/mohex/imt/pset,get,prot2 3 Rotate points using copy to keep each rotation. Blue is the original set of points laying flat along the X axis. Green is the second rotation of 20 degress. Red is the third rotation of 110 degrees which includes both the original and second rotations. DEMOS Demo of rotated cylinder in a box: ROTATELN",
    "tags": "rotateln, rotate line",
    "url": "/pages/docs/commands/ROTATELN.html"
  },{
    "title": "ROTATEPT",
    "text": "ROTATEPT Rotates a point distribution about a point. rotatept/ifirst,ilast,istride/[no]copy /xcen,ycen,zcen/theta/phi ifirst,ilast,istride is the node range selected by node numbers or pset,get,pname. nocopy keeps only the rotated points, the node count does not change. copy keeps a copy of the original unrotated points, as well as the rotated points. The new points will have the rotated coordinate values but no other mesh attributes will be set for these points. xcen,ycen,zcen is the point center of rotation. theta in degrees is the angle of rotation toward the negative z-axis. phi in degrees is the angle of rotation of the XY plane around the Z-axis, where positive phi is measured from the positive x-axis toward the positive y-axis. EXAMPLES define x1 38. define x2 170. define y1 17. define y2 81. cmo/create/cmosink/ / /quad quadxy/ 133 65 / x1 y1 0./ x2 y1 0./ x2 y2 0. / x1 y2 0. rotatept/1,0,0/nocopy/ x2 y1 0./0. -16.5 rotate from right lower corner xmax and ymin define XTRANS 55. define YTRANS 30. define ROT 30. trans/1,0,0/0. 0. 0./ XTRANS YTRANS 0./ rotatept/1,0,0/nocopy/0. 0. 0./0. ROT translate then rotate a grid Click here for demos",
    "tags": "rotatept",
    "url": "/pages/docs/commands/ROTATEPT.html"
  },{
    "title": "RZ",
    "text": "RZ (deprecated, see CREATEPTS ) This command adds points to the mesh. It can distribute points evenly or according to a ratio zoning method. SYNTAX rz /xyz rtz rtp/ni,nj,nk/xmin,ymin,zmin/xmax,ymax,zmax/ iiz,ijz,ikz/[iirat,ijrat,ikrat/xrz,yrz,zrz/] rz/line/np///xmin,ymin,zmin,xmax,ymax,zmax/iiz,ijz,ikz/ xyz specifies Cartesian coordinates. rtz specifies cylindrical coordinates. rtp specifies spherical coordinates. line this option implies xyz and will distribute n1 nodes from (xmin,ymin,zmin) to (xmax,ymax,zmaz) When using the rtz or rtp coordinate systems the center is at (0,0,0). Use a trans command to move the center. For the rtz command, minimum and maximum coordinates are the triplets: radius from the cylinder’s axis, angle in the xy-plane measured from the x-axis and height along the z-axis. For the rtp command minimum and maximum coordinates are the triplets: radius from the center of the sphere axis, angle in the zy-plane measured from the positive z-axis and the angle in the xy-plane measured from the positive x-axis (see II.a.11). Note that the rtz always results in a (partial) cylinder of points centered around the z axis. Use the rotateln command to orient the cylinder. For example, to center the cylinder around the y axis, specify the x axis as the line of rotation in the rotateln command. ni,nj,nk number of points to be created in each direction. xmin,ymin,zmin minimums for coordinates. xmax,ymax,zmax maximums for coordinates. iiz,ijz,ikz if =0 then mins and maxs are used as cell centers, if =1 then mins and maxs are used as cell vertices iirat,ijrat,ikrat ratio zoning switches (0=off,1=on) xrz,yrz,zrz ratio zoning value - distance is multiplied by this value for each subsequent point. EXAMPLES rz /xyz /5,3,10 /0.,2.,0. /5.,6.,2. /1,1,1/ This results in a set of 150 points, five across from x=0. to x=5., 3 deep from y=2. to y=6. and 10 high from z=0. to z=2. rz/rtz/4,6,11 /0.,0.,0. /3.,360.,10. /1,0,1/ This results in 264 points arranged around the z- axis. There are 3 rings of points at distances r=1., r=2. and r=3. from the z-axis. There are 11 sets of these three rings of points and heights z=0., z=1., z=2.,…,z=10. In each ring there are 6 points where each pair of points is separated by 60°; note that ijz=0 requests that points be placed at cell centers, hence the first point will be at 30° not at 0°. Corresponding to r=0, there will be 6 identical points at 11 intervals along the z-axis at heights z=0., z=1., z=2.,…z=10. Filter should be used to remove these duplicate points.",
    "tags": "rz, create points",
    "url": "/pages/docs/commands/RZ.html"
  },{
    "title": "RZAMR",
    "text": "RZAMR (deprecated, see CREATEPTS/AMR ) RZAMR uses an octree type refinement applied to an existing hexahedral mesh to all nodes in a specified region.  No additional elements are kept,  the intention is that the resulting node distribution will be passed to connect to generate a tetrahedra mesh. SYNTAX rzamr/region_name/number_of_levels region_name is the    name of region to refine.  If blank,  all regions will be refined.  An element will be refined if any node of the element is in the specified region. number_of_levels    is the number of times the refinement will be performed.  After each level, the code will determine which of the new nodes are in the specified region and will refine the associated elements.  Default is 1.   EXAMPLES rzamr    refine the entire mesh rzamr /r1/3    refine elements with nodes in the region r1 three times DEMO TET MESH Create a hex mesh, refine with rzamr, connect into a tet mesh. cmo/create/cmo///hex * define geometry surface/inside/reflect/box/0,0,0/1,1,1 surface/diag/intrface/plane/0,0,0/1,0,1/1,1,1 region/lin/ le inside and ge diag / region/rin/ le inside and lt diag / mregion/mlin/ le in=side and gt diag / mregion/mrin/ le inside and lt diag / * distribute nodes quadxyz/2,2,2/0.,0.,0./1.,0.,0./1.,1.,0./0.,1.,0./ &amp; 0.,0.,1./1.,0.,1./1.,1.,1./0.,1.,1./ * set node types and materials setpts * connect up the hex mesh rzbrick/xyz/2,2,2/1,0,0/connect * refine the hex mesh rzamr/lin/1 rzamr/rin/3 * create the tet mesh cmo/create/cmot///tet * define geometry again for tet mesh surface/inside/reflect/box/0,0,0/1,1,1 surface/diag/intrface/plane/0,0,0/1,0,1/1,1,1 region/lin/ le inside and ge diag / region/rin/ le inside and lt diag / mregion/mlin/ le inside and gt diag / mregion/mrin/ le inside and lt diag / * copy in the nodes from the hex mesh to the tet mesh copypts/cmot/cmo cmo/select/cmot cmo/release/cmo * reset node types and materials so that setpts will use * geometry to figure out the correct values cmo/setatt/cmot/itp/1,0,0/0 cmo/setatt/cmot/imt/1,0,0/0 * set node types and materials setpts * connect up the tet mesh connect * set element materials * and create parent/child nodes on interfaces settets dump/gmv/gmvtet finish  ",
    "tags": "rzamr, create points",
    "url": "/pages/docs/commands/RZAMR.html"
  },{
    "title": "RZBRICK",
    "text": "RZBRICK This command is deprecrated, see CREATEPTS. Builds a brick mesh and generates a nearest neighbor connectivity matrix. This command is similar to the rz command format except here we have symmetry flags to input. A second format specifies that a mesh be created and connected. Use the connect option with quadxyz to connect logically rectangular grids. SYNTAX rzbrick /xyz rtz rtp/ni,nj,nk/xmin,ymin,zmin/xmax,ymax,zmax/ &amp; iiz,ijz,ikz/[iirat,ijrat,ikrat/xrz,yrz,zrz/isym,jsym,ksym] rzbrick /xyz rtz rtp/ni,nj,nk/pset,get,pset_name/connect/ Geometry Options: xyz specifies Cartesian coordinates (default). rtz specifies cylindrical coordinates. rtp specifies spherical coordinates. Distribution Options: ni,nj,nk are the number of points to be created in each direction. xmin,ymin,zmin are the minimums for coordinates. xmax,ymax,zmax are the maximums for coordinates. iiz,ijz,ikz 0 or 1 switches: if = 0 then mins and maxs are used as cell centers if = 1 then mins and maxs are used as cell vertices iirat,ijrat,ikrat ratio zoning switches 0=off (default), 1=on xrz,yrz,zrz ratio zoning value - distance is multiplied by this value for each subsequent point. pset,get,pset_name point set selection given by name isym,jsym,ksym symmetry flags - not documented Warning: This command does not create a 2D grid, it has memory errors: rzbrick/xyz/5,10,1/0. 0. 0./10. 20. 0. /1,1,1 for 2D this will work: cmo create cmo1///quad quadxy/ 5 5/ 0. 0. 0. / 20. 0. 0./20. 20. 0. / 0. 20. 0. rzbrick/xyz/5,5,1/1,0,0/connect EXAMPLES rzbrick/xyz/3,2,3/0.,0.,0./1.,1.,1./1,1,1 creates a hex grid 2x1x2 cells in the unit cube quadxyz/5,7,5/0.,0.,0./1.,0.,0./1.5,0.5,2.0/.5,.2,2.5/-1.,1.5,0./2.0,0.,0.0/2.1,1.9,2.4/-0.2,1.8,2.3/setpts rzbrick/xyz/5,7,5/1,0,0/connect creates a hex grid inside the hexahedral specified by the 8 corners passed to quadxyz",
    "tags": "rzbrick",
    "url": "/pages/docs/commands/RZBRICK.html"
  },{
    "title": "RZRAN",
    "text": "RZRAN This command is deprecrated, see CREATEPTS. This routine is used to add random points with a given target spacing to the region of space defined by the input minimum and maximum coordinate values using the specified geometry (xyz, rtz, or rtp), and the given local origin (specified in xyz coordinates). Within the bounding geometry, the points are distributed uniformly in space, with the average separation targeted at the input value of the spacing.  Near the boundaries of the geometry, the uniform distribution is modified slightly in order to create a well defined outer boundary.  Points are added separately on the corners, edges, and surfaces of the bounding geometry, uniformly randomly distributed with the same target spacing on each of these boundary objects. Points in the interior are offset by the sepcified edge protection distance from the exterior.  This separation helps LaGriT’s connect algorithm avoid creating artificial “pits” in the interface surfaces. SYNTAX rzran /geom/spacing/ rmin1,rmin2,rmin3 / rmax1,rmax2,rmax3 rzran /geom/spacing/rmin1,rmin2,rmin3 /rmax1,rmax2,rmax3 / &amp; [ xoff,yoff,zoff / edgedist / ranseed1,ranseed2 ] Geometry Options for geom: xyz specifies Cartesian coordinates (default). rtz specifies cylindrical coordinates. rtp specifies spherical coordinates. Options: spacing is the target separation between the random points, values must be &gt; 0 (default is 1). rmin1,rmin2,rmin3 / rmax1,rmax2,rmax3 are the minimum and maximum coordinate values (defaults: rmin=0, rmax=rmin). For rtz rmax2-rmin2 must be &lt;= 360. For rtp the values should be rmax2 &lt;= 180, and rmax3-rmin3 &lt;= 360. All min values must be &gt;= 0. xoff,yoff,zoff is the local origin shift specified in xyz coordinate system (default is 0). edgedist is the edge protection distance (default and recommended: spacing/2). Note: if the spacing is larger with respect to the dimension of the geometry, the default setting may result in few or no interior nodes.  In this case decrease the value of edgedist. ranseed1, ranseed2 are seeds for the random number generator, the default is -1 (do not re-seed, recommended). If either seed is .le. zero, the seeds are ignored. Recommended values if reseed: large-ish integers, ranseed1 &gt; ranseed2 &gt; 0, ranseed2 odd. No initial seeds are needed, and repeating the command with the identical parameters and seeds should result in the identical point distribution. Repeating the command with no seeds specified should result in different point locations with the same distribution.   EXAMPLES rzran / xyz / .1 / 0 0 0 / 1 1 1 / random points with target spacing 0.1 in a 1x1x1 box rzran/ rtz / .1 /  0,0,0 / 1,,360 / 2,3,4 / 0.2 random points with target spacing 0.1 in a cylinder of radius 1 centered at xyz=(2,3,4) and with an edge protection distance of 0.2 rzran/ rtp / .5 /  5,0,0 / 5,,360 /  , ,  /  / 98765 4321/ random points with target spacing 0.5 on the surface of a sphere of radius 5 centered at the origin with new random seeds CAVEATS Filter should be used afterwards to remove possibly duplicate points. The algorithm to insure the points are uniformly distributed in space is not clever about handling values outside the allowed range for rtz and rtp geometries and so it simply truncates them to the allowed range if possible or aborts. Most importantly, angles are in degrees and theta for the rtp geometry runs from 0 to degrees, with 0 degrees being the +z axis. It does know about the angular periodicity and there should be only the “corner” point artifacts of, eg, the +x axis being the origin of phi (rtp) or theta (rtz) if a full 360 degrees for these two variables in their respective coordinate systems is used.",
    "tags": "rzran",
    "url": "/pages/docs/commands/RZRAN.html"
  },{
    "title": "RZS",
    "text": "RZS This command is deprecrated, see CREATEPTS. Builds a sphere by generating coordinates of points and also modifies zoning by ratio-zoning point distributions. See the rz command for more details. The itype flag defines what type of sphere will be generated. Use connect to generate tet or triangle connectivity from the point distribution. SYNTAX rzs / itype / nr,npt,xirad,xorad / xcen,ycen,zcen / iz / irat,rz Types for sphere itype: 1 generates a sphere by gridding the faces of a cube and then projecting the vertices onto a sphere. The number of nodes per shell is of the form 6*i**2. 2 generates a sphere by subdividing an icosahedron placed on the surface of a sphere. Icosahedral gridding is made up of 10 diamonds per shell. Each diamond is made up of n**2 nodes (where n must be of the form 2**i+1). There are 2 nodes (the poles of the sphere) at which 5 diamonds meet and 10 nodes where 3 diamonds meet; hence there are a minimum of 12 nodes per shell. The number of nodes per shell can be 12, 42, 162, 642,…etc. 8 generates a hexahedral icosahedron grid. This option distributes points and generates the grid connectivity data structures. This option does not require a connect command. diamond generates the points for one diamond of the icosahedron. Options: nr is the number of radial shells npt is the upper limit of the number of points in a shell, the number of points generated will be less than or equal to this number. xirad , xorad are the inner and outer radii of the sphere. For itype =8 reverse inner and outer radii. xcen, ycen, zcen are the coordinates of the center of the sphere iz  if =0 then mins and maxs are used as cell centers, if =1 then mins and maxs are used as cell vertices irat is ratio zoning switch (0=off,1=on) rz is ratio zoning value - distance is multiplied by the value for each subsequent point. EXAMPLES rzs/8/5/162/1.0,0.5/0.,0.,0./1,0,0.0/ rzs/2/5/162/0.5,1.0/0.,0.,0./1,0,0.0/ rzs/diamond/5/162/1,.5/0,0,0/1,0,0/",
    "tags": "rzs",
    "url": "/pages/docs/commands/RZS.html"
  },{
    "title": "RZS",
    "text": "RZV This command is deprecrated, see CREATEPTS. This routine is used to ratio zone the region of space spanned by the input number n(i) of copies of the input vector v(ij) away from the initial point v(0j) using the desired coordinate system. The j-th component of the i-th vector V(ij) is reduced by r(ij) at each step in the i-th direction away from the initial point. No attempt is made to insure that the 3 vectors are independent. SYNTAX rzv/[ xyz rtz rtp / &amp; [ n1,n2,n3 &amp; /v11,v12,v13/v21,v22,v23/v31,v32,v33 &amp; /v01,v02,v03 &amp; /r11,r12,r13/r21,r22,r23/r31,r32,r33 ] &amp; / component or vector &amp; / [f1,f2,f3] For ratio_method = component (default), the j-th component of the i-th vector vij is reduced by  rij after the ki-th step in the i-th direction away from the initial point.  For this ratio_method the ratio flags f1,f2,f3 are not used.  In this case an initial step of 1 for the j-th component of the i-th direction would become, for rij  =  1/2, a step of the j-th component of the i-th direction of 1/2 at ki =  1, 1/4 at  ki =  2, 1/8 at  ki =  3, 1/16 at ki =  4,etc. For ratio_method = vector and fj =1 (the default), the j-th vecor is reduced by rij  after the ki -th step in the i-th direction.  In this case an initial step of 1 in the j-th direction would become, for  rij  =  1/2, a setp in the j-th direction of 1/2 at ki =  1, 1/4 at  ki =  2, 1/8 at  ki =  3, 1/16 at ki =  4,etc. For ratio_method = vector and fj =0, the j-th vecor is reduced by [1 - (1-rij  ) *2/(ki +  1)] after the ki -th step in the i-th direction.  In this case an initial step of 1 in the j-th direction would become, for  rij  =  1/2, a step in the j-th direction of 1/2 at ki =  1, 1/3 at  ki =  2, 1/4 at  ki =  3, 1/5 at ki =  4,etc. default = xyz default = 0:      ni, vi, v0j default = 1:      rij default = component EXAMPLES rzv/rtz/n1,0,0/.1,10.,1/ , , / , , / , , /1.1,1,.9 spiral of points rzv/xyz/n1,n2,n3/1,0,0/0,1,0/0,0,1 rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 simple cubic point distribution, both lines have the same result rzv/xyz/n1,n2,n3/.5,.5,.5/.5,.5,-.5/.5,-.5,-.5/ rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 rz/xyz/n1 ,n2 ,n3 /0,0,0/n1,n2,n3/0,0,0 body centered cubic point distribution, compare with the rz two command sequence with different bounding box. rzv/xyz/n1,n2,n3/.5,.5,0/0,.5,.5/.5,0,.5/ rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 rz/xyz/n1?| ,n2?| ,n3+1/0,0,0/n1,n2,n3/0,0,1 rz/xyz/n1?| ,n2+1,n3?| /0,0,0/n1,n2,n3/0,1,0 rz/xyz/n1+1,n2?| ,n3?| /0,0,0/n1,n2,n3/1,0,0 face centered cubic point distribution compare with the four rz command sequence (different bounding box). rzv/xyz/n1,n2,n3/1,0,0/.5,0.866,0/0,0,1 hexagonal lattice of points in x,y plane, repeated in z direction rzv/xyz/n1,n2,n3/.5,.5,0/0,.5,.5/.5,0,.5 rzv/xyz/n1,n2,n3/.5,.5,0/0,.5,.5/.5,0,.5/.25,.25,.25 rz/xyz/n1+1,n2+1,n3+1/0,0,0/n1,n2,n3/1,1,1 rz/xyz/n1?| ,n2?| ,n3+1/0,0,0/n1,n2,n3/0,0,1 rz/xyz/n1?| ,n2+1,n3?| /0,0,0/n1,n2,n3/0,1,0 rz/xyz/n1+1,n2?| ,n3?| /0,0,0/n1,n2,n3/1,0,0 rz/xyz/n1+1,n2+1,n3+1/0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/1,1,1 rz/xyz/n1?| ,n2?| ,n3+1/0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/0,0,1 rz/xyz/n1?| ,n2+1,n3?| /0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/0,1,0 rz/xyz/n1+1,n2?| ,n3?| /0.25,0.25,0.25/n1+.25,n2+.25,n3+.25/1,0,0 diamond point distribution (two command sequence) compare the eight rz command sequence (different bounding box). rzv/xyz/n1,n2,n3/1,0,0/.5,0.866,0/0,0,1/ rzv/xyz/n1,n2,n3/1,0,0/.5,0.866,0/0,0,1/.5,0.2,.5 hexagonal close pack point distribution?| (two command sequence) rzv/xyz/10,60,0/0.1,0,0/0,60,0/0,0,1/0,0,0/1,0.5,1/1,1,1/1,1,1/vector/0,0,0 nice 2-d distribution of points in a circle of radius 1 CAVEATS::       filter should be used afterwards to remove possibly duplicate points this can create some really bizzare point distributions mistyped input after “rzv/[cgeom]” always returns successful point addition, but may be very different than desired ratio_flag might better be a scalar or a matix, and its use might want to be extended to ratio_method=component.",
    "tags": "rzs",
    "url": "/pages/docs/commands/RZV_LG.html"
  },{
    "title": "SCALE",
    "text": "SCALE Scale a point distribution according to the scale factors. SYNTAX scale/range/ relative /xyz rtz rtp/iscale,jscale,kscale/xcen,ycen,zcen scale/range/ absolute /xyz rtz rtp/iscale,jscale,kscale/ range is the selection of points designated by node numbers for ifirst,ilast,istride or pset,get,pname. 1,0,0 will select all. absolute scaling factors are constants added on to the existing coordinates.  That is, absolute is really a translation rather than a rescale. relative scaling factors are unitless multipliers with reference to geometric center xcen,ycen,zcen. iscale,jscale,kscale are the scale factors according to geometry type: xyz Cartesian coordinates. iscale,jscale,kscale = x, y, z rtz Cylindrical coordinates. iscale,jscale,kscale = radial, theta, z rtp Spherical coordinates. iscale,jscale,kscale = radial, theta, phi EXAMPLES scale/1,0, 0/ relative / xyz / 0.3048 0.3048 0.3048 Convert coordinates from feet to meters. scale / 1 0 0 / relative / xyz / 10. 10. 1. math/sin/CMO_OBJ/zic/1,0,0/CMO_OBJ/yic scale / 1 0 0 / relative / xyz / 0.1 0.1 0.1 trans / 1 0 0 / 0. 0. 0. / 0. 0. 0.5 cmo / printatt / -def- / -xyz- / minmax Use the math math and scale commands to set the z coordinates to make the shape of a sin() wave. First use scale to make x and y coordinates to 0-10 so the sin(y) goes through complete 2pi cycles. Set z(i)=sin(y(i)). A final scale factor is applied and the surface is translated up so all z values are above 0.",
    "tags": "scale",
    "url": "/pages/docs/commands/SCALE.html"
  },{
    "title": "SETPTS",
    "text": "SETPTS Set point types and imt material by calling surfset and regset routines. Assumes mesh object has geometry REGION and material MREGION defined by SURFACE commands. The node material imt attribute is set based on the previously defined mregion commands. Interior and external boundary nodes should be assigned to exactly one mregion; these nodes will be assigned an imt value that corresponds to the mregion. Node types are assigned based on whether a node is on a surface and what type the surface(s) is. A constraint table is generated and icr updated if constraint type surfaces are defined. SYNTAX setpts setpts/no_interface setpts/closed_surfaces/reflect setpts With no arguments, this command sets point types and imt materials by previously defined regions. Nodes will be assigned an imt value that corresponds to the mregion. A node which is on an interface will be assigned to any mregion and will be given an imt value of “interface” (an integer equal to one more than the number of material regions.) Node types are assigned based on whether a node is on a surface and what type the surface(s) is. This command must be executed before connect. setpts / no_interface This allows one to set the imt values of nodes without getting any nodes labeled interface. This is useful if you do not want settets to create parent child chains at interface points. The actual imt value given may be determined by roundoff error so should not be used in cases where there are a large number of interface points. This is useful for setting imt values of an rzbrick mesh in which interface points only occur due to the coincidental point very near the geometry defining surface. setpts / closed_surfaces/reflect This option works with geometries in which all regions and mregions are defined by closed surfaces. The nodes that fall on more than one surface are labeled as interface nodes. Nodes which fall on exactly one surface are labeled external reflective boundary nodes. The resetpts/itp must be called to correct the point types for external boundaries. EXAMPLES # define surfaces and regions cmo/create/mo_tet surface/s1/reflect/box/0,0,0/1,1,1 surface/p1/intrface/plane/0,0,.5/1,0,.5/1,1,.5 surface/p2/intrface/plane/.5,0,0/.5,1,0/.5,1,1 surface/p3/intrface/plane/.75,0,0/.75,1,0/.75,1,1 region/r0/ le s1 and ge p1 and gt p3 / mregion/m0/ le s1 and gt p1 and gt p3 / region/r1/ le s1 and ge p1 and le p3 / mregion/m1/ le s1 and gt p1 and lt p3 / region/r2/ le s1 and le p1 and ge p2 / mregion/m2/ le s1 and lt p1 and gt p2 / region/r3/ le s1 and le p1 and lt p2 / mregion/m4/ le s1 and lt p1 and lt p2 / # create point distribution createpts/xyz/17,17,17/0,0,0/1,1,1/1,1,1 # set point types and materials setpts # connect into tet mesh connect # set element types and materials settets resetpts/itp In general, it is good practice to use filter to remove duplicate points, setpts to set point attributes, settets to set elements, and a final resetpts/itp to set boundary. cmo/create/s1///tri read/avs/surfaces cmo/create/3dmesh surface/surface1/intrcons/sheet/s1 copyts/3dmesh/s1/ cmo/release/s1/ cmo/create/s2///tri/ read/avs/surf2.avs surface/surface2/intrcons/sheet/s2 copypts/3dmesh/s2 cmo/release/s2/ region/r1/le surface1 region/r2/le surface2 mregion/mr1/lt surface1 mregion/mr2/lt surface2 setpts/closed_surfaces/reflect connect settets resetpts/itp example using the closed_surfaces command",
    "tags": "setpts, imt",
    "url": "/pages/docs/commands/SETPTS.html"
  },{
    "title": "setsize",
    "text": "SETSIZE setsize will set the mesh object attributes xmin,xmax,ymin,ymax,zmin,zmax from the xic,yic,zic values of all ‘real’ points (dudded and merged points will be ignored). The variables epsilonl, epsilona and epsilonv are mesh object attributes; hence they may be different for all meshes in a given run.  epsilona, epsilonv and epsilonl may be set by the user with the cmo/setatt command.  setsize is called internally by some of LaGriT commands, especially those that add nodes to the mesh; copypts, createpts, regpnts, recon, scale, and translate Many LaGriT algorithms use epsilonl; for example, if a node falls on a interface or boundary surface. It uses epsilonv to determine if a node can be connected. Errors from setpts and connect may result if inconsistant or wrong values of epsilons are used. SYNTAX setsize If epsilonv is very small, it is set to epsilona epsilonl is set by a call to set_epsilon epsilonl is set to the square root of epsilona unless this number would be too small in which case epsilonl is to (( xmax-xmin) + (ymax-ymin) + (zmax-zmin)) * 1.e=8/3 epsilonv = abs(xmax-xmin) * abs(ymax-ymin) * abs(zmax-zmin) * epsilonr * 1000 epsilona = ((xmax-xmin)**2 + (ymax-ymin)**2 + (zmax-zmin)**2) epsilonr * 1000 epsilonr is set at initialization time by: x2=one do i=1,1000 x2=x2/two x1=one+x2 if(x1.le.one) go to 11 enddo 11 epsilonr = x2*2. where the values of ‘one’ and ‘two’ are obtained from the include file ‘consts.h’. The command cmo/printatt can be used to view any of these cmo attributes. e.g. cmo/printatt/xmax EXAMPLES read/avs/box.inp/ mo setsize cmo/printatt/mo/-all-/minmax setsize will set the min and max attributes for coordinates and set the epsilon values. The report from the printatt command will look like: ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH -def- 0.000000000E+00 0.000000000E+00 0.000000000E+00 132651 scalar 1 1 0 1 vector 3 3 0 1 nnodes 132651 132651 0 1 nedges 0 0 0 1 nfaces 0 0 0 1 nelements 0 0 0 1 mbndry 16000000 16000000 0 1 ndimensions_topo 3 3 0 1 ndimensions_geom 3 3 0 1 nodes_per_element 4 4 0 1 edges_per_element 6 6 0 1 faces_per_element 4 4 0 1 isetwd 0 0 0 132651 ialias 0 0 0 132651 imt1 2 2 0 132651 itp1 0 0 0 132651 icr1 0 0 0 132651 isn1 0 0 0 132651 xic 0.000000000E+00 1.000000000E+00 1.000000000E+00 132651 yic 0.000000000E+00 1.000000000E+00 1.000000000E+00 132651 zic 0.000000000E+00 1.000000000E+00 1.000000000E+00 132651 0 length attribute: xtetwd 0 length attribute: itetclr 0 length attribute: itettyp 0 length attribute: itetoff 0 length attribute: jtetoff 0 length attribute: itet 0 length attribute: jtet epsilon 1.000000004E-15 1.000000004E-15 0.000000000E+00 1 epsilonl 3.845925373E-13 3.845925373E-13 0.000000000E+00 1 epsilona 6.661338148E-13 6.661338148E-13 0.000000000E+00 1 epsilonv 2.220446049E-13 2.220446049E-13 0.000000000E+00 1 ipointi 1 1 0 1 ipointj 132651 132651 0 1 idebug 0 0 0 1 itypconv_sm 1 1 0 1 maxiter_sm 25 25 0 1 tolconv_sm 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 nnfreq 1 1 0 1 ivoronoi 1 1 0 1 iopt2to2 2 2 0 1 xmin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 ymin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 zmin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 xmax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 ymax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 zmax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 kdtree_level 0 0 0 1 max_number_sets 64 64 0 1 number_of_psets 0 0 0 1 number_of_eltsets 0 0 0 1 number_of_fsets 0 0 0 1 Note this mesh object does not have elements, therefore some element based attributes are 0 length.",
    "tags": "setsize",
    "url": "/pages/docs/commands/SETSIZE.html"
  },{
    "title": "SETTETS",
    "text": "SETTETS Set mesh object element color (itetclr) and create child points at interior interfaces. This command can also be used to set the node color from the element color. Note color values must be an integer number greater than 0. SYNTAX settets settets / color_tets settets / parents settets / geometry settets/ color_points settets/ new_tets settets / normal settets and settets/color_tets detirmines the color of all elements using the following tests; If the element contains a non-interface point, the element color is set to this value. If the element is comprised entirely of interface points, the centroid of the element is calculated and the material region containing this point is determined; the element color is set to this material. If the centroid of the element is not in any material region, the centroid must be on an interface surface. In this case all vertices of the element are examined and the material common to all vertices is selected as the element color. settets / parents has exactly the same behavior as settets except that existing values of itetclr are used for elements containing non-interface nodes. geometry sets the element itetclr based on the material region containing the centroid of the element for all elements; existing values of itetclr are ignored and overwritten. color_points sets the node material imt from the element color itetclr; existing values of itetclr are not changed. settets/newtets has the same behavior as settets except that existing positive values of itetclr are not changed. settets/normal assigns the element itetclr array of a triangle mesh to an integer value depending on the normal vector direction. There are 26 possible direction that correspond to the 6 faces, 12 edges and 8 corners of a cube.  In general most triangles will be assigned one of 6 values which correspond to the 6 sectors which are within degrees of the 6 unit vectors: 1 0 0 , 0 1 0 , 0 0 1, -1 0 0, 0 -1 0, 0 0 -1. See image and table below. NOTE: Valid for a quadrilateral or triangle mesh. EXAMPLES # Projected cube onto a sphere to capture all 26 directions cmo / create / motet_sph createpts/sphere/1/5/162/1.0,0.5/0.,0.,0./1,0,0.0/ cmo / setatt / motet_sph / imt / 1 0 0 / 1 filter / 1 0 0 rmpoint / compress connect cmo / setatt / motet_sph / itetclr / 1 0 0 / 1 resetpts / itp extract / surfmesh / 1 0 0 / motri_sph / motet_sph cmo/select/motri_sph settets/normal cmo/printatt/motri_sph/ itetclr / minmax dump / sphere_colors.inp / motri_sph Creates a sphere shaped triangulated surface with colors 1-26 based on normal directions with the view set so the min x,y,z coordinate is left,front,bottom. Direction numbering starts at bottom then top then right, back, left, front as shown in table and image. 1 bottom (blue) 2 top (red) 3 right = east (green) 4 back = north (orange) 5 left = west (aqua) 6 front = south (yellow) 7 bottom right edge (dark gray) 8 bottom front edge (dark gray) 9 front right side edge (black) 10 bottom back edge (dark gray) 11 back right side edge (black) 12 bottom left edge (dark gray) 13 left back side edge (black) 14 front left side edge (black) 15 top right edge (light gray) 16 top front edge (light gray) 17 top back edge (light gray) 18 top left edge (light gray) 19 bottom front right corner (magenta) 20 bottom back right corner (magenta) 21 bottom back left corner (magenta) 22 bottom front left corner (magenta) 23 top front right corner (magenta) 24 top back right corner (magenta) 25 top back left corner (magenta) 26 top front left corner (magenta) Image shows triangle elements colored by 26 normal values. Image materials are expanded to show all.",
    "tags": "settets",
    "url": "/pages/docs/commands/SETTETS.html"
  },{
    "title": "SMOOTH",
    "text": "SMOOTH Smooth a 2D or 3D mesh object. For adaptive smoothing see the radapt command. smooth takes a 2D or 3D mesh object and moves nodes, without changing the connectivity of the grid, in order to improve the aspect ratios and distribution of elements in the mesh. There are nine smoothing algorithms available:  2D  2D and 3D  3D  esug laplace mega elliptic aspect network random lpfilter geometry SYNTAX For all commands: position results in the positions of nodes being changed. Other options have not been implemented. ifirst,ilast,istride is the selection of points designated by node numbers or pset,get,pname. 1,0,0 will select all. The internal variable maxiter_sm (default=25) controls the maximum number of iterations and can be changed using the assign command. e.g. (assign /// maxiter_sm/10). SYNTAX 2D smooth/position/esug elliptic random/ [ifirst,ilast,istride ]/[control] esug Elliptic Smoothing for Unstructured Grids with guards against folding. This is the default for 2D mesh objects. It can only be used on triangular 2D mesh objects. Ref.: Randolph E. Bank and R. Kent Smith, “Mesh Smoothing Using A Posteriori Error Estimates”, SIAM J. Num. Anal. Vol. 34, Issue 3, pp. 979-997, 1997. elliptic similar to esug except the ‘guards’ which prevent a grid from folding are turned off. (Thus esug is preferred.) random a node’s position is set to a randomly weighted average position of its neighbors. ‘Guards’ keep the elements from inverting. control (default 0 ) from standard smoothing scheme to 1 which causes the scheme to be progressively more controlled, at 1 there is no mesh movement. SYNTAX 2D and 3D smooth/position/aspect // [ifirst,ilast,istride]/ [toldamage] smooth/position/lpfilter // [ifirst,ilast,istride] /[filtdeg]/[k_pb]/network smooth/position/laplace / [ifisrt,ilast,istride]/[rlxwt]/[ntimes]/[nwtty]/[useisn]/[extrnbr] aspect Adjusts node positions such that the aspect ratio of the elements is improved. toldamge (default is infinity) is the damage tolerance, so it can be used as a general smooth which has the effect of improving worst aspect ratio. lpfilter This smooths surface networks by a low-pass filtering of the coordinate data. fltdeg (default 30) k_pb (default 0.1) network applies to a network of curves in 2D or 3D, or to a network of surfaces in 3D. The cell materials are ignored. laplace On a 3D tetahedral mesh moves a node to the average position of its neighbors where neighbor is defined as the set of nodes connected to the candidate node by an edge where the node types (itp1) and node constraints (icr1) are a ‘subset’ of the candidate node type and constraints. A node will not be moved if the result is an inverted element. The following controls may be supplied: rlxwt (default 0.5 ) weight for underrelaxed Laplacian smothing ntimes (default 5 ) number of smoothing iterations nwttry (default 3 ) number of attempts to not tangle the mesh by halving the smoothing weight. useisn (default 1 ) means interface nodes are smoothed based along an edge with the same materials as the candidate node. 0 means interface nodes are smoothed based on all interface neighbors. extrnbr (default inclusive) means do not restrict neighbors. exclusive means restrict neighbors to pset nodes. SYNTAX 3D smooth/position/mega geometry/ [ifirst,ilast,istride ]/[control] smooth/position/network/[ifisrt,ilast,istride]/[niter]/[weight]/[check nocheck] control (default 0 ) from standard smoothing scheme to 1 which causes the scheme to be progressively more controlled, at 1 there is no mesh movement. mega Minimum Error Gradient Adaption. This option creates a smoothed grid which is adapted to the standard function with constant Hessian f(x,y,z)=x2+y2+z2. Can be used on hybrid 3D meshes and guards against mesh folding. Adaption to this function creates a uniform isotropic mesh. Ref.: Randolph E. Bank and R. Kent Smith, “Mesh Smoothing Using A Posteriori Error Estimates”, SIAM J. Num. Anal. tol. 34, Issue 3, pp. 9-9 (19) geometry Geometry (“plump element”) adaption. Default for 3D. Can be used on hybrid 3D meshes It uses the mega algorithm but retains only the leading geometry term; the term containing the Hessian has been dropped. This algorithm guards against mesh folding. network This option smooths the surface network of a 3D tetrahedral grid.  Volume nodes are not moved.  The material volumes are conserved. Combining this type of smooth with volume smoothing will help to avoid element inversions. niter (default 10 ) number of iterations weight (default 1. ) controls the amount of movement (from 0. to 1.). check (default) By default a check is performed to verify that no elements are inverted. nocheck turns off check for inverted elements. This option will not work correctly (will not conserve volume) on grids which have two areas of a material connected at a single node or edge; each material region must have face connectivity.  EXAMPLES smooth Smooth all nodes in the mesh using esug in 2D or geometry in 3D. smooth / / / 1,0,0 / 0.5 Smooth all nodes in the mesh, using controlled smoothing with control=0.5. pset/p2/attribute/itp1/1,0,0/0/eq smooth /position /network/1,0,0/3/1./check smooth/position/geometry/pset,get,p2 smooth /position /network/1,0,0/3/1./check smooth/position/geometry/pset,get,p2 Smooth a 3D grid by combining network and volume smooths. compute/distance_field/CMO_SINK mobj_sm dfield pset/pin/attribute dfield/1,0,0/ le 120. assign///maxiter_sm/6 smooth/position/esug/pset,get,pin Smooth a 2D grid within 120 distance from mobj_sm and control the number of iterations by using the assign command.",
    "tags": "smooth",
    "url": "/pages/docs/commands/SMOOTH.html"
  },{
    "title": "sort",
    "text": "SORT The sort command creates a sort key for chosen node or element attributes. Sort can be in ascending or descending order and will not alter current mesh object values. The mesh object is not re-ordered but a sort key is created. Use REORDER to change the node or element ordering of the mesh object. SYNTAX sort/mo_name/bins /[ ascending or descending]/key_name/ sort_attribute / [epsilon_user] sort/mo_name/index or rank/[ascending or descending]/key_name/ in_att1, in_att2, in_att3 ... sort/mo_name/line_graph /[ascending or descending]/key_name/[elements or nodes] For all commands: mo_name is the name of a valid mesh object or -def- which selects the currently active mesh object. sort_type sorting methods include bins, index, rank and line_graph See below. ascending or descending detirmines the ordering direction. Note this parameter is ignored by the line_graph method but must be present for consistency with other sort variations. key_name is the name of the sort key attribute created. The reorder command uses this to reorder the mesh. This is an integer vector (VINT) which will hold the output sort key values. If no name is given for key_name, a name will be created which will be ikey_ and the first attribute name in sort_attributes. For the line_graph option, the default key_name will be called ikey_line_graph. sort_attributes The name of one or more existing attribute names. Each attribute will be used as a node of element based array upon which the sorting routine will sort. Multi-key sorts can have an arbitrary number of input attributes. Attribute in_att1(n) has priority over in_att2(n) in breaking ties. Note: all attributes are put into a type real work array before being sent to the sort routine. Note the line_graph does not use attributes as it sorts line elements based on connectivity (see method below). Single-Key sort: bins is a single-key sort which assigns each in_att1 value a bin number. If in_att1 is an integer then bins each have a unique integer value associated with them. If in_att1 is a real number, bins are created with values which are within +-epsilon of each other, where epsilon=1.e-10 x abs(real_bin_value). If all array values are unique, then the maximum value of the index array will equal the number of entries in the sorted list. Otherwise, the maximum value of the index array will be less than the number of entries in the sorted list but will equal the number of unique entries in the list. With the bins method, an optional user specified epsilon multiplier, epsilon_user, will override the default value of 1.e-10. Multi-Key sort: index is a single or multi-key sort that constructs an index table such that in_att1(ikey(1)) is the first entry in the sorted array, in_att1(ikey(2)) is the second, etc. rank is a single or multi-key sort that constructs a rank table such that the tables ith entry give the rank of the ith entry of the sorted arrays. The rank table is derived from the index table by: foreach j = 1,N rank(index(j)) = j end Line Graph sort: line_graph is a sort for connected line segments for arranging into a reasonable order. The sorted order for components which are not polylines or polygons is unspecified, but it will usually be reasonable because the underlying algorithm visits the edges via depth first search. In particular, it makes the following guarantees: Each connected component will be arranged together. Polylines (chains of line segments with no branching or loops) will be in order from one end to the other. Polygons will be in order starting from one segment and looping back around to the same place. line_graph with elements generates the following three integer element attributes: cid: A component id for distinguishing separate connected components. Each connected component receives a unique positive integer starting from one. This allows you to identify all the edges in a particular component by selecting all elements with a particular component id. ctype: The component type, represented as an integer from 1 to 5. 1 (Polyline) A connected chain of segments with no branches or loops. 2 (Tree) A connected acyclic component. 3 (Polygon) A component consisting solely of a single loop. 4 (Shared Edges) A component which has a pair of cycles with a shared edge. 5 (Other) Anything which does not fit into the above categories. loop_id: This is a unique positive integer assigned to each simple cycle. Edges that are not part of a cycle receive a default value of zero. If an edge is shared (i.e. part of more than one cycle) then it will be labeled with only one of its cycles. In this case, the cycle corresponding to the label is not fully specified because there is more than one right answer. line_graph with nodes is based on the option for elements, except that it does not create extra attributes. Based on the sorted elements, the nodes will be reordered in the same sequence. This is necessary for triangulation as “TRIANGULATE” routine requires the nodes to be in either clockwise or counterclockwise order. EXAMPLES sort / cmo / line_graph / ascending / ikey / elements Sort the line segment elements into a reasonable order based on connectivity. This also creates attributes cid, ctype, and loop_id (see above). sort / cmo / index / ascending / ikey / imt zic yic xic Multi-key sort first by imt then to break ties consider z coordinate, then if there are further ties, use y coordinate. Use x coordinate as final tie breaker. sort / cmo / rank / descending / ikey / yic Produce ranking of nodes based on y coordinate in descending order. sort / cmo / index /-def-/-def-/ xic yic zic Produce index of noded coordinates. This would be like a line sweep sort where the sweep is first along x coordinate then y then z. sort / cmo / bins / ascending / i_index / xic sort/ cmo / bins / ascending / j_index / yic sort / cmo / bins / ascending / k_index / zic If the cmo were a finite difference grid of points, the above three commands would produce the finite difference indexing. All points with the same x value would be in the same i_index bin, all points with the same y value would be in the same j_index bin, etc. define MOGOOD motet define MOSORT mopts cmo/addatt/MOSORT id_mesh1 /VINT/scalar/nnodes/linear/permanent//0 interpolate/voronoi/ MOSORT id_mesh1/1,0,0/ MOGOOD id_node cmo/addatt/MOSORT id_diff /VINT/scalar/nnodes/linear/permanent//0 math/sub/MOSORT id_diff/1,0,0/ MOSORT id_mesh1 /MOGOOD id_node cmo/printatt/MOSORT/ id_diff / minmax sort/ MOSORT/ index / ascending / ikey / id_mesh1 reorder/MOSORT/ ikey Sort and reorder a set of nodes based on a source mesh, based on node id and position xyz. Use interpolate/voronoi to associate each node with the good mesh node id’s. We check to see if the ordering for both mesh objects is different by subtracting the node id of one from the second. The result would be 0 for all nodes that match position and node id. Sort mesh object using the attribute with the interpolated node id’s, then reorder using the ikey values. LINKS LaGriT command file example 1 for sort and reorder LaGrit command file example 2 for sort and reorder OLD FORMAT - No longer supported but syntax will still work. sort / xyz / [ index bins rank ] sort/xyz/index sorts the x,y,z coordinate integer arrays i_index, j_index, k_index such that xic(i_index(i)) i=1,..nnodes lists the coordinate in ascending order. sort/xyz/bins sorts the x,y,z coordinates and assigns each i_index, j_index, k_index values in ascending order of the bin number of the sorted list. sort/xyz/rank sorts the x,y,z coordinates and assigns each i_index, j_index, k_index values the ranking of the node in the sorted list. If all array values are unique, then the maximum value of the index array will equal the number of entries in the sorted list. Otherwise, the maximum value of the index array will be less than the number of entries in the sorted list but will equal the number of unique entries in the list. For example given x = 0, 1, 2, 1, 0 sort/xyz/index returns i_index = 5, 1, 4, 2, 3 sort/xyz/bins returns i_index = 1, 2, 3, 2, 1 sort/xyz/rank returns i_index = 2, 4, 5, 3, 1",
    "tags": "sort",
    "url": "/pages/docs/commands/SORT.html"
  },{
    "title": "STACK",
    "text": "STACK The stack/layers command is used to read surfaces and merge into a single stacked layers cmo. The surfaces must have the same number of nodes, and the x,y coordinates of each layer must be the same. (i.e. x_n,y_n of surface M must equal x_n,y_n of surface N), and the surfaces must be single valued functions of z. The first file listed is bottom, last file is the top surface. The lower elevation of each layer truncates the upper. The second from last surface can be made to truncate all lower surfaces, commonly done with a topographic surface. Three scalar attributes are added and used later by the stack/fill command. nlayers are the total number of layers in the stacked cmo, this includes layers added for refinement. nnperlayer are the number of nodes in each of the layers. neperlayer are the number of elements in each of the layers. layertyp is created to indicate what type of layer each node is in. Value -1 is bottom, -2 is top, 0 is the surfaces read at input, 1 is a derived interface buffer, 2 is a derived refinement layer. SYNTAX cmo/create/ cmo_stack stack/layers / [avs or gmv] [minx,miny, maxx,maxy] / &amp; file_bot(1) [matnum] &amp; file_lay(i) [matnum, refnum] &amp; file_top(n) [matnum, refnum] &amp; [ flip ] [ buffer [xdistance] ] [ pinch xthick ] trunc [ifile_no] [ dpinch xvalue / dmin xvalue ] stack/fill / cmo_3D / cmo_stack Required Options The stacked layers are read into the current mesh object. Create and name the stacked mesh object with cmo/create/cmo_stack before command stack/layers. stack/fill command creates a new mesh object cmo_3D from the stacked mesh cmo_stack. The stacked 2D layers are filled to create 3D elements. For triangulated surfaces, the elements will be prisms, and for quad sheets the filler elements will be hex. avs or gmv are the allowable file types that can be read. These must be surfaces with element type quad or tri. minx, miny, maxx, maxy is optional argument that allows a subset of the surfaces to be used. file(1) ... file(n) is the list of files to read from bottom surface to top. Each surface can be followed by an integer value to indicate a material number, and an integer value to indicate the number of layers to add as refinement between input surfaces. mat_num and ref_num material number and refinement count are optional arguments for each file so the file list can look like one of the following 3 syntax lines: file_bottom, file2, ... file_top file_bottom mat_num, file2 mat_num, ... file_top mat_num file_bottom mat_num, file2 mat_num [ref_num], ... file_top mat_num [ref_num] mat_num is the material number for the unit defined by upper and lower surface. These values will detirmine the element colors when the layers are filled with element volumes. ref_num is the number of refinement layers to add between two surfaces. Refinement is done proportionallly, creating new layers between the choosen surfaces. The first filename can not have a refinement number, units start at second file name. See examples below. Additional Options flip will flip elements so the normals point positive Z direction, no change if normals are already up direction. buffer creates buffer layers around interfaces at a distance equal to xvalue. It derives layers above and below each surface that is read in to the stack routine. Buffers are not created around refinement layers or on the top and bottom surfaces. trunc causes all layers below the choosen surface to be truncated. The truncating surface is indicated by the integer ifile_no. For instance, 5 will truncate all layers below the 5th surface by the 5th surface. pinch xthick controls how layers are made coincident where they cross and will also help to control the minimum thickness between layers. The real value xthick is mininum thickness allowed between layers. This allows upper surface elevations to be equal to lower surface elevation if the upper surface dips below lower surface. (default 0) dpinch dvalue dmin mvalue These options are used along with buffers to help elements to follow the interface boundarys. These options differ from the simple pinch option and uses the beads_ona_ring algrithm to move points vertically after all the layers are stacked. The algorithm follows these rules: If layer thickness &lt;= dvalue then thickness is set to zero. If layer thickness is &lt; dvalue &lt; mvalue, set thickness to mvalue. (default dvalue = mvalue = 0.0, no post processing) EXAMPLES cmo/create/cmo_stack stack/layers/avs/ fsrf5.inp 1/ fsrf09.inp 2/ fsrf44.inp 2 /flip/pinch 1.0 stack/fill/ mo_prism / cmo_stack This command will read 3 triangulated surface files, flip the normal from down to up, and pinch layers less than 1.0 meter apart. When converted to a 3D grid, this mesh will be two prism elements thick in the z direction. A surface is assigned the material value that occurs with it on the command line. When the surfaces are filled with volumes, the nodes on the bottom surface will detirmine the material of volume elements on and above that surface. So nodes on fsrf5.inp and above will all have imt values of 1. Nodes on fsrf09.inp and above will have imt equal to 2. The prism mesh will have a bottom layer of material 1 and a top layer of material 2. cmo/create/cmo_stack stack/layers/avs / fsrf5.inp 1/ fsrf09.inp 2/fsrf44.inp 2/ &amp; flip / buffer 3.0 / dpinch 1.0 / dmin 3.0 Three surfaces are read and buffer layers are added at 3 meters below and 3 meters above the unit interface fsrf09.inp. The units are pinched at anything less than 1 meter and the mininum distance to next layer is 3 meters. cmo create cmo_stack stack/layers/avs/ &amp; surf-12.inp 1 &amp; surf-5.inp 2 3 &amp; surf5.inp 3 &amp; surf2_slope.inp 4 &amp; surf25.inp 4 1 / trunc 4 / pinch 0. stack/fill/mohex/cmo_stack hextotet//motet/cmohex This command reads a list of quad surfaces and assigns material values 1 through 4. The first thickness (between surf-12.inp and surf-5.inp) is refined by 3, so that 3 layers are added between these file surfaces. All materials will be 1 in this refined unit. The next two units, material 2 and 3, will have no refinement layers added. The last unit is refined once, with a layer between the file surfaces surf2_slope.inp and surf25.inp. The fill option will fill the space between quad surfaces with hex elements. This hex grid will have 4 units and 10 layers. The hextotet command can be used to convert the hex grid to a tet grid. Note that the second option to hextotet is defaulted. This allows hextotet to check on the grid’s mesh type and use the appropriate tet conversion. There will be 6 tet from each hex and there are 3 tets from each prism. LINKS Simple Examples for stack Advanced Examples for stack",
    "tags": "stack layers",
    "url": "/pages/docs/commands/STACK.html"
  },{
    "title": "SURFACE",
    "text": "SURFACE Defines a boundary, interface, or geometry for a selected mesh object. Surfaces are used to create geometry REGION and material regions MREGION for a mesh object. Mesh interfaces will be assigned node constraint (icr) values corresponding to the surfaces on which nodes sit. The command SETTETS will generate parent/child node chains (isn) for nodes on intrface or intrcons surfaces. The inside/outside conventions for sheet surfaces are described below. SYNTAX surface/isurname/ ibtype / istype / istype_parameters surface/isurname/release isurname is the name of the surface and must be unique for each surface defined for the current mesh object. release will release the previously defined surface referenced by name. All references will be removed from the geometry data structures and all constraints (icr) values associated with this surface will be removed. Options for ibtype These options define the boundary type and constraints. free unconstrained, exterior reflect constrained, exterior, assigned constraint values (icr). intrface unconstrained, interior, will generate parent/child node chains (isn). intrcons constrained, internal, are assigned constraint values (icr) and will generate parent/child node chains (isn). virtual constrained, internal surfaces which have different materials on either side of the virtual interfaces do not separate material regions but are intended to identify other structural features of a geometry. Nodes on this surface will be assigned constraint values (icr). Options for istype istype are types of surfaces represented by geometric shapes. Each type has parameters specific to its geometry. box / xmin,ymin,zmin / xmax,ymax,zmax is a cube defined by min and max coordinates, i.e bottom left and top right corners. cylinder / x1,y1,z1/x2,y2,z2/radius is a cylinder defined by point 1 bottom center and point 2 top center. The radius is the length from center to cylinder edge. Cylinders are open but finite. To create a closed cylinder cap both ends with planes. cone / x1,y1,z1/x2,y2,z2/radius is a cone where point 1 is the vertex and point 2 is the base center of the cone with radius from that point. A cone is finite but does have an open end. To create a closed cone cap the open end with a plane. ellipse / x1,y1,z1 / x2,y2,z2 / x3,y3,z3 / ar,br,cr is an ellipse point 1 is the center of the ellipsoid and point 2 is on the a semi-axis (new x), point 3 is on the b semi-axis (new y). The values ar, br, cr are radii on their respective semi-axes. parallel / x1,y1,z1 / x2,y2,z2 / x3,y3,z3 / x4,y4,z4 is a parallel piped where points 1, 2, 3 are the front left, front right and back left points of the base and point 4 is the upper left point of the front face. plane or planexyz / x1,y1,z1 / x2,y2,z2 / x3,y3,z3 is a plane defined by 3 coordinate points. The direction normal to the plane is determined by the order of the points according to the right hand rule. planertz / radius1, theta1, z1, radius2, theta2, z2, radius ,zcen is a plane defined by cylindrical coordinate system. planertp / radius1,theta1,phi1, radius2,theta2,phi2, radius3,theta3,phi3/ xc, yc, zc is a plane defined by spherical coordinate system. sphere / xc, yc, zc, radius is a sphere defined by the center point and the radius distance from center point to sphere surface. sheet / cmo_name is a surface defined by a mesh object that is a 2D quad or triangle connected mesh. See inside/outside conventions below for a description of inside/outside or left/right with respect to sheet surfaces. tabular / x1,y1,z1/x2,y2,z2/ rz or rt / is a rotated tabular profile where point 1 and point 2 define the axis of rotation for the tabular profile with point 1 as the origin. This is followed by pairs of profile descriptors depending on the value of rz or rt. If rz, then the r value is a radius normal to the axis of rotation and z is the distance along the new axis of rotation. If set to rt then theta is the angle from the axis of rotation at point 1 and r is the distance from point 1 along theta. The first pair must start on a new line and all lines must contain pairs of data. The last pair of data must be followed by end. surface/s_name/ibtype/tabular / x1,y1,z1 / x2,y2,z2 / rz / &amp; r1,z1 &amp; r2,z2 &amp; .... rn,zn &amp; end or surface/s_name/ibtype/tabular / x1,y1,z1 / x2,y2,z2 / rt / &amp; r1,theta1 &amp; r2,theta2 &amp; ... rn,thetan &amp; end EXAMPLES surface / s_box / reflect / box / -1. -1. -1. / 1. 1. 1. region/ r_box / le s_box Define a region inside or equal to a box with lower left corner (-1. -1. -1.) and upper right corner at (1. 1. 1.). read avs surfmesh_input.inp mosurf cmo/select/motet surface/surf_bndry/intrface/sheet/mosurf region/ rout / ge surf_bndry eltset/ eout / region / rout Read a triangulated surface to truncate a mesh. Use the surface to find elements outside the surface and name the set “eout”. surface / s_cone / reflect / cone / .1 .1 .1 / .5 .5 .5 / .3 Define a cone surface with tip at (.1 .1 .1) and center at (.5 .5 .5) with .3 radius. define XC 498.0 define YC 539.0 define ZBOT -500.0 define ZTOP 500.0 define RAD 42.0 surface/ s_cyl /intrface/cylinder/XC,YC,ZBOT/XC,YC,ZTOP/ RAD Use define variables to create a cylinder shaped surface. surface / s_ellipse / reflect / ellipse / &amp; 552250.0 4121975.0 1275.0 / &amp; 552251.0 4121975.0 1275.0 / &amp; 552250.0 4121976.0 1275.0 / &amp; 500.0 225.0 125.0 region / r_ellipse / le s_ellipse eltset/ereset/region/r_ellipse Define an ellipsed shaped region and select elements. define x1 497000. define y1 540612. define x2 499300. define y2 540100. define x3 497000. define y3 541316. surface/SSBOX/intrface/parallel/x1,y1,1700./ &amp; x2,y2,1700./x3,y3,1700./x1,y1,5000./ define x1 499029.5961 define x2 500174.3616 define y1 538579.7712 define y2 539378.5612 define uleft 1779.9725 define uright 1778.7472 define lleft 1779.7481 define lright 1778.5228 surface/ swtr / intrface /plane/ x2, y1, lright / x2, y2, uright / x1, y2, uleft surface / bbox / reflect / box / .1 .1 .1 / .9 .9 .9 surface / s1 / intrface / sheet / cmo_2 surface / s2 / intrface / sheet / cmo_3 region / r1 / lt bbox and gt s1 and gt s2 region / r2 / lt bbox and gt s1 and lt s2 region / r3 / lt bbox and lt s1 and gt s2 region / r4 / lt bbox and lt s1 and lt s2 Set up a parallel piped and plane surfaces then define sheet surfaces from the triangulations in cmo_2 and cmo_3. Define geometry regions relative to the surfaces. Sheet surfaces inside/outside Convention Inside/outside will be determined by the following algorithm: For the point being considered, p, find the nearest sheet triangle and the closest point, q, to p that lies on that triangle. Construct the vector , from q to p. Construct the outward normal to the triangle, The outward normal is constructed using the right hand rule and the order of the points in the sheet. Sheets may be specified as quad Mesh Object (i.e. a 2 dimensional array of points containing the coordinates of the corners of each quad). Either two triangles (divide each quad in two using point (i,j) and (i+1,j+1)) or four triangles (add a point in the center of the quad) are generated by each quad. Applying the right hand rule to the points (i,j), (i+1,j), (i+1,j+1) gives the direction of the normal for all triangles created from the quad. If &lt; 0 then the point is inside. If  &gt;0 the point is outside. If * n = 0, and if p is on the triangle then p=q and p in on the triangle. If = 0 and p is not on the triangle then p is outside. One implication of this definition is that the concept of shadows cast by open sheets no longer is valid. Sheets may be considered to extend to the boundary of the geometry.",
    "tags": "surface, geometry",
    "url": "/pages/docs/commands/SURFACE.html"
  },{
    "title": "SURFTPTS",
    "text": "SURFPTS Generates points on boundary surfaces previously defined by the SURFACE or REGION command. The points are generated by shooting rays through a user specified set of points from an origin point, line or plane and finding the surface intersection of each ray. SYNTAX surfpts/ itype/iname/ inside outside both/ifirst,ilast,istride/geom/ray_origin itype is the name of the surface or region. ifirst,ilast,istride or pset,get,psetname define the set of points to shoot rays through. inside outside or both indicates the point location for a region relative to the surface. Options for Ray Geometry The parameters geom / ray_origin are the geometry and ray origin with parameters based on the geometry. xyz/ x1,y1,z1/x2,y2,z2/x3,y3,z3 where points 1, 2, 3 define the plane to shoot rays from that are normal to the plane. rtz/ x1,y1,z1/x2,y2,z2 where points 1, 2, define the line to shoot rays from that are perpendicular to the line. rtp/ xcen,ycen,zcen where point is the center. points / iffirst,iflast,ifstride define a set of points to shoot rays from. EXAMPLES * coordinates and elevations for watertable plane define x1 499029.5961 define x2 500174.3616 define y1 538579.7712 define y2 539378.5612 define uleft 1779.9725 define uright 1778.7472 define lleft 1779.7481 define lright 1778.5228 * point distribution for ray shooting define / XMIN / 498400. define / YMIN / 538900. define / XMAX / 500200. define / YMAX / 540400. define / NZ / 1 define / NX / 61 define / NY / 51 cmo/create/cmos surface/swtr/intrface/plane/x2 y1 lright/x2 y2 uright/x1 y2 uleft createpts/xyz/NX NY NZ / XMIN YMIN ZMAX / XMAX YMAX ZMAX pset/rayend/seq/1 0 0 * SURFPTS/CTYPE/INAME/IREGPT/IPFIRST,IPLAST,ISTRIDE/GEOM/RAY ORIGIN * ctype = surface or region * iname = name of surface or region * iregpt = inside, outside, or both (ignored for surface) * geom = center pt, line, or plane * surfpts/surface/swtr/inside/pset,get,rayend/ &amp; xyz /0. 0. 0./1. 0. 0./1. 1. 1./ * remove ray points and duplicate points rmpoint/pset get rayend filter/1 0 0 rmpoint/compress Generate a set of points on a plane",
    "tags": "surfpts",
    "url": "/pages/docs/commands/SURFPTS.html"
  },{
    "title": "TRANS",
    "text": "TRANS Translate a mesh object from old to new coordinates. SYNTAX trans/ifirst,ilast,istride/xold,yold,zold/xnew,ynew,znew trans/ifirst,ilast,istride/enter zero original/[xyz rtp rtz]/ [xdim,ydim,zdim] ifirst,ilast,istride is the range of points to translate. They can be defined as pset,get, pset_name or node numbers where 1,0,0 means all. First form of this command: translates a set of points from point xold,yold,zold to new coordinate xnew,ynew,znew with a linear translation. This will then cause the remaining points in the set to be moved by the same translation. Second form of this command: zero point set is translated so that (0,0,0) is located at the midpoint of min x,y,z and max x,y,z of the mesh. center point set is translated so that (0,0,0) is located at the min x,y,z of the mesh. original point set is translated to the original location before enter or zero was called. xyz is the default (rtp and rtz are reserved for future implementation). xdim,ydim,zdim indicate the axes along which to translate. For example, 1,1,0 or x,y will translate along the x and y axes, the z values will not change. EXAMPLES trans/pset,get,mypoints/ 0.,0.,0./2.0,2.0,0./ The points in the set mypoints will be moved 2 in the positive x direction and 2 in the positive y direction. cmo/create/motet copypts/motet/mopts cmo/select/motet trans/1,0,0/ zero connect trans/1,0,0/ original Moving points close to zero coordinates will improve accuracy where coordinate numbers are large. Here we move the points to zero, connect, and them move back to original coordinates. Click here for demos",
    "tags": "trans, translate",
    "url": "/pages/docs/commands/TRANS.html"
  },{
    "title": "TRIANGULATE",
    "text": "TRIANGULATE triangulate will take an ordered set of nodes in the current 2d mesh object that define a perimeter of a polygon and create a trangulation of the polygon. The nodes are assumed to lie in the xy plane; the z coordinate is ignored. The code will exit early if orientation or node ordering is not correct. Use REFINE and SMOOTH to break triangles into desired resolution. No checks are performed to verify that the nodes define a legal perimeter (i.e. that segments of the perimeter do not cross). The code will connect the last node to the first node to complete the perimeter. This code supports triangulation of self-intersecting polygons (polygon with holes), assuming that the order of the nodes are correct. Moreover the connectivity of the polyline must also be defined correctly. No checks are made. One disadvantage of the algorithm for triangulating self-intersecting polygons is that it does not always work. For example, if the holes have complicated shapes, with many concave vertices, the code might fail. In this case, the user may try to rotate the order of the nodes: Issue 57 is a known difficulty in the case where polygon points have a large number of co-linear points. SYNTAX triangulate / triangulate / clockwise or counterclockwise clockwise or counterclockwise (default clockwise) Orientation is defined with the viewer above the xy plane. EXAMPLES triangulate triangulate/clockwise Both examples will triangulate the points in the clockwise direction. cmo/create/2dmesh /// tri read/avs/2dfile.avs triangulate/counterclockwise refine/rivara///edge/1 0 0/ 0.05 ///inclusive Triangulate a polygon and then use refine/rivara to refine mesh to desired element size. Click here for demos",
    "tags": "triangulate",
    "url": "/pages/docs/commands/TRIAGN.html"
  },{
    "title": "UNG2AVS",
    "text": "UNG2AVS This routine is used to convert files in UNGenerate FORMAT to AVS format. UNGenerate files are produced by ARCINFO. The UNG format is described below, see AVS format at READ/AVS. SYNTAX ung2avs/avs_file_out/ung_file_in ung2av/avs_file_out/ung_file_in/[constant]/ &amp; [xy, xz, yx, zx, yz, zy] avs_file_out is the name of the AVS file to write ung_file_in is the name of the UNG file to read Options constant (default 0.) is the value to assign to z or the second axis indicated by axis options. xy xz yx zx yz zy (default xy) detirmines axis values to write. EXAMPLES ung2avs/avs_file_out/ung_file_in converts ung_file_in to avs_file_out with a constant default z value of 0.0 ung2avs/avs_file_out/ung_file_in/7.0 converts ung_file_in to avs_file_out with a constant default z value of 7.0 in xy order ung2avs/avs_file_out/ung_file_in/15.0/xz converts ung_file_in to avs_file_out with a constant y value of 15.0 in xz order UNG file format The UNG format contains a file of xy values, in groups of sequentially numbered sets, of connected line segments, each ending with END. The format for connected lines that form polygons or that do not form polygons is very similar. To make sets of connected lines that are polygons the first xy pair for each set of lines must be on the same line as the set number. Closed polygons will be formed by connecting the last point of a point set to the first point of the  point set. The set number is on a line by itself for non-polygons. Spacing on a line must not contain tabs. FORMAT for connected lines that do not form polygons: 1 x y x y x y ... END n x y x y x y END END FORMAT for polygons: 1 x y x y x y ... END n x y x y x y END END File SAMPLE of connected, non-polygon, lines: UNG File AVS File --------------------------------------------- 1 10 7 0 0 0 10.00 15.00 1 10.0000 15.0000  0.0000 10.50 15.50 2 10.5000 15.5000  0.0000 11.00 16.00 3 11.0000 16.0000  0.0000 END 4 20.0000 25.0000  0.0000 2 5 20.5000 25.5000  0.0000 20.00 25.00 6 21.0000 26.0000  0.0000 20.50 25.50 7 22.0000 27.0000  0.0000 21.00 26.00 8 30.0000 35.0000  0.0000 22.00 27.00 9 30.5000 35.5000  0.0000 END 10 31.0000 36.0000  0.0000 3 1  1 line    1   2 30.00 35.00 2  1 line    2   3 30.50 35.50 3  2 line    4   5 31.00 36.00 4  2 line    5   6 END 5  2 line    6   7 END 6  3 line    8   9 7  3 line    9   10 --------------------------------------------- File SAMPLE of polygons: UNG File AVS File --------------------------------------------- 1 11.00 16.00 10  10  0 0 0 10.00 15.00 1   10.0000 15.0000  0.0000 10.50 15.50 2   10.5000 15.5000  0.0000 11.00 16.00 3   11.0000 16.0000  0.0000 END 4   20.0000 25.0000  0.0000 2 22.00 27.00 5   20.5000 25.5000  0.0000 20.00 25.00 6   21.0000 26.0000  0.0000 20.50 25.50 7   22.0000 27.0000  0.0000 21.00 26.00 8   30.0000 35.0000  0.0000 22.00 27.00 9   30.5000 35.5000  0.0000 END 10   31.0000 36.0000  0.0000 3 31.00 36.00 1   1 line    1    2 30.00 35.00 2   1 line    2    3 30.50 35.50 3   1 line    3    1 31.00 36.00 4   2 line    4    5 END 5   2 line    5    6 END 6   2 line    6    7 7   2 line    7    4 8   3 line    8    9 9   3 line    9   10 10  3 line   10    8 ---------------------------------------------",
    "tags": "ung2avs",
    "url": "/pages/docs/commands/UNG2AVS.html"
  },{
    "title": "UPSCALE",
    "text": "UPSCALE The upscale command is used to interpolate attribute values from nodes of a fine source mesh to node attributes of a coarse sink mesh. This is most often used to assign geostatistical property values from an application to the computational mesh for modeling. This command finds dense source nodes that are within the Voronoi cell of every node in the coarser sink mesh. The voronoi volume around each sink node is the bucket that captures all node values to compute. Nodes on the voronoi boundaries are assigned to two or more sink nodes. Then the attributes of all the source nodes within a source node’s cell are upscaled into a single value based on the chosen method. A kdtree node search is used to find the source mesh nodes located in each of the Voronoi sink point volumes. It is possible for source nodes to occur on the boundary of multiple Voronoi volumes. By default, all nodes found in each Voronoi volume are used to upscale to the enclosed sink node. In this case, source nodes on multiple Voronoi boundaries will be included in upscale calculations more than once. It is important that the source points be denser than the sink mesh node spacing. If no source points are found within a voronoi volume, the source point is given a value of 0. Geostat data sometimes generate very small values close to zero that are not appropriate for modeling. It is recommended that a mininum reasonable value be assigned. Be sure the range of source values are what is intended. For the averaging methods, make sure there are no source values of 0. SYNTAX upscale / scale_method / cmosink, attsink / range / cmosrc, attsrc / &amp; [boundary_choice] [keepatt] [set_id] Required: scale_method is the choice of upscale calculation applied to each set of source nodes within each sink Voronoi cell where x(1) to x(n) are the values of source nodes 1 to n found for the sink point. The following are valid scale methods: ariave For each sink point, calculate the arithmetic mean of n values from source attribute attsrc sink_val = (x(1) + x(i)… + x(n)) / n example: for 4 values; 1,2,3,4 ariave = 2.5 geoave For each sink point, calculate the geometric average of n values found in attsrc sink_val = ( x(1) * x(i)… * x(n) ) * *(1/n) example: for 4 values; 1,2,3,4 geoave = 2.21336 harave For each sink point, calculate the harmonic mean of n values from source attribute attsrc sink_val = n / ( 1/x(1) + 1/x(i)… + 1/x(n) ) example: for 4 values; 1,2,3,4 harave = 1.92 min or max For each sink point, assign the min or max source attribute from n values found in attsrc sink_val = min(x(1),x(i),x(n)) example: for 4 values; 1,2,3,4 min = 1 sink_val = max(x(1),x(i),x(n)) example: for 4 values; 1,2,3,4 max = 4 sum For each sink point, calculate the sum of n values from source attribute attsrc sink_val = x(1) + x(i)… + x(n) example: for 4 values; 1,2,3,4 sum = 10 cmosink, attsink are the cmo name and attribute name to write sink values into. The scale method detirmines which calculation is applied to the source attribute value and written to the sink attribute. All integer attributes are converted to double for the calculations. The resulting values are then converted to the nearest integer if the sink attribute is integer. range is the set of sink nodes to write scaled values to. 1,0,0 will select all sink nodes cmosrc, attsrc are the cmo name and attribute name are the cmo and attribute to interpolate from. Points from the source grid will be located within the Voronoi volumes of sink nodes. Boundary options Optional parameters appearing after the source cmo attribute name are optional and may appear in any order. boundary_choice provides a method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes. By default, each set of souce nodes found within each volume are used to calculate an upscale value for the sink node. In this case if duplicate nodes occur on multiple cells, the sum number of nodes used in upscale calculations will exceed the sum total of nodes in the source mesh. If the number of source nodes used must equal the number of source mesh nodes, choose an boundary_choice to detirmine which sink volume an boundary node should be assigned to. The result is a one-to-one correspondence with each source point assigned to a single sink node id which is stored in source attribute pt_gtg. Source nodes that are found on shared Voronoi boundaries are flagged in source attribute dups_gtg. single selects the Voronoi volume of the first sink node encountered and does not use any after that. This method can be used for situations that require the sum of nodes in each Voronoi space to equal the total of source points used. This one-to-one correspondence is written to the source cmo attribute pt_gtg. This attribute can be reused during multiple calls to the upscale command and will greatly reduce CPU time. divide not implemented. multiple uses all source nodes found in each sink Voronoi volume. Added Attribute options The following options are used with multiple calls to upscale with the same two grids. It keeps source attributes created during the search routines and uses these attributes to look up associated node numbers. The upscale command uses kdtree to create the source attribute pt_gtg that associates source nodes to sink node volumes. Note that this correlation is one-to-one and source nodes sharing multiple Voronoi volume boundary are tagged in a second source attribute called dups_gtg. delatt deletes any attributes created during the kdtree searches. By default these attributes are removed. keepatt keeps attributes pt_gtg and dups_gtg created during the kdtree searches. The source node attribute pt_gtg has the first found sink node id. The node attribute dups_gtg is flagged each time the source node occurs in a sink Voronoi cell, allowing the user to find source nodes on cell boundaries. Use of this attribute will greatly reduce CPU time. set_id creates and keeps the source attribute pt_gtg containing sink id numbers found from the sink mesh. This is the same attribute created and kept for the keepatt option except that if the attribute already exists, it is deleted and re-created with a new search. This is recomended if the pt_gtg attribute exists, but user is not sure the current sink mesh is the same as used to create the attribute. EXAMPLES upscale / sum / cmo_sink icount /1,0,0/ cmo_src ival upscale / sum / cmo_sink icount /1,0,0/ cmo_src ival/ single keepatt upscale / min / cmo_sink imin /1,0,0/ cmo_src ival/ single keepatt set_id upscale / max / cmo_sink imax /1,0,0/ cmo_src ival/ keepatt upscale / ariave / cmo_sink ave_val /1,0,0/ cmo_src xval/ upscale / harave / cmo_sink har_val /1,0,0/ cmo_src xval/ upscale / geoave / cmo_sink geo_val /1,0,0/ cmo_src xval/ upscale / sum / cmo_sink icount /1,0,0/ cmo_src ival In this example, search will find the sets of source nodes enclosed within each sink Voronoi cell.The ival attribute values are added for each set and written to the sink icount attribute. Because the attribte ival has all values set to 1, the icount attribute will contain the number of source nodes found in each Voronoi volume. The source node values will be counted regardless if they are on a Voronoi boundary and are in multiple Voronoi volumes. The result with duplicate boundary points will be a sum of points used greater than the total number of source mesh points. upscale / sum / cmo_sink icount /1,0,0/ cmo_src ival/ single keepatt This is the same as above except that duplicate boundary points will be counted for the first found Voronoi volume and skipped thereafter. This one-to-one correspondance of source nodes to sink Voronoi volume will be stored in the source attributes pt_gtg with sink node numbers, and dups_gtg containing flags of the duplicate boundary points. These attributes will not be deleted. These images show the 10 numbered sink points and the 1221 source points. In this example all source points have an imt1 value of 1. The sink points each have a value in icount equal to the number of nodes used for the associated Voronoi volume. The red lines show the Voronoi cell boundaries for the 10 sink points. Source points all equal to 1, Sink points colored by upscaled value. Source points colored by associated sink node id, attribute pt_gtg. Source points colored by number of duplicates cell boundaries, attribute dups_gtg.",
    "tags": "upscale",
    "url": "/pages/docs/commands/UPSCALE.html"
  },{
    "title": "ZQ",
    "text": "ZQ (deprecrated) Deprecated command, replaced by cmo/setatt and cmo/printatt . Set or print node attribute values of a selected set of nodes. SYNTAX zq / att_name / ifirst,ilast,istride/ value zq / att_name / ifirst,ilast,istride/ att_name is the name of the attribute to set or write ifirst,ilast,istride is the range of nodes to set or write where 1,0,0 are all nodes. value set attribute of selected nodes to this value. If value is ommited, the command will print values instead of set values. To print, specify any one of a group and all will be printed. To set an attribute value, set value and all selected nodes will be set to this value. For printing, attributes are grouped as follows: Group1: isq,imt,itp (material type and point types) Group2: x,y,z (coordinates) EXAMPLES zq/imt/1,100,2/ 1/ will set imt attribute to 1 for all odd numbered nodes between 1 and 100 to 1. zq/xic/1,0,0/ will print coordinates of all points",
    "tags": "zq, deprecrated",
    "url": "/pages/docs/commands/ZQ.html"
  },{
    "title": "Fortran Accessing the Mesh Object",
    "text": "Accessing the Mesh Object using Fortran LaGriT code is written mostly in Fortran, but also includes C and C++ codes. See the files in src and lg_util for more examples. The following template is a Fortran code example of using the an existing mesh object and of creating a new mesh object. The existing mesh object is a 3d object. The object to be created is a 2d object. It is first necessary to set up the pointer statements for both the existing and new mesh objects. All these mesh object attributes are integers except for xic,yix,zic which are real*8. C Definitions for incoming (existing) cmo pointer (ipimt1, imt1) pointer (ipitp1, itp1) pointer (ipicr1, icr1) pointer (ipisn1, isn1) integer imt1(1000000), itp1(1000000) integer icr1(1000000), isn1(1000000) pointer (ipxic, xic) pointer (ipyic, yic) pointer (ipzic, zic) real*8 xic(1000000), yic(1000000), zic(1000000) pointer (ipitetclr, itetclr) pointer (ipitettyp, itettyp) pointer (ipitetoff, itetoff) pointer (ipjtetoff, jtetoff) pointer (ipitet, itet) pointer (ipjtet, jtet) integer itetclr(1000000), itettyp(1000000) integer itetoff(1000000), jtetoff(1000000) integer itet(4,1000000) , jtet(4,1000000) C Definitions for cmo that is to be created pointer (ipimt1a, imt1a) pointer (ipitp1a, itp1a) pointer (ipicr1a, icr1a) pointer (ipisn1a, isn1a) integer imt1a(1000000), itp1a(1000000) integer icr1a(1000000), isn1a(1000000) pointer (ipxica, xica) pointer (ipyica, yica) pointer (ipzica, zica) real*8 xica(1000000), yica(1000000), zica(1000000) pointer (ipitetclra, itetclra) pointer (ipitettypa, itettypa) pointer (ipitetoffa, itetoffa) pointer (ipjtetoffa, jtetoffa) pointer (ipiteta, iteta) pointer (ipjteta, jteta) integer itetclra(1000000), itettypa(1000000) integer itetoffa(1000000), jtetoffa(1000000) integer iteta(3,1000000), jteta(3,1000000) C Get the existing cmo - its name is in the variable cmoin call cmo_get_name(cmoin,ier) C Get the scalar mesh variables call cmo_get_intinfo('nnodes',cmoin,npoints,lencm,itypcm,ier) call cmo_get_intinfo('nelements',cmoin,ntets,lencm,itypcm,ier) call cmo_get_intinfo('ndimensions\\_topo',cmoin,ndt,lencm,itypcm,ier) call cmo_get_intinfo('ndimensions\\_geom',cmoin,ndg,lencm,itypcm,ier) call cmo_get_intinfo('nodes\\_per\\_element',cmoin,npe,lencm,itypcm,ier) call cmo_get_intinfo('faces\\_per\\_element',cmoin,nfpe,lencm,itypcm,ier) call cmo_get_intinfo('mbndry',cmoin,mbndry,lencm,itypcm,ier) C Get pointers to the vector variables call cmo_get_info('ialias',cmoin,ipialias,lenialias,ictype,ier) call cmo_get_info('imt1',cmoin,ipimt1,lenimt1,ictype,ier) call cmo_get_info('itp1',cmoin,ipitp1,lenitp1,ictype,ier) call cmo_get_info('icr1',cmoin,ipicr1,lenicr1,ictype,ier) call cmo_get_info('isn1',cmoin,ipisn1,lenisn1,ictype,ier) call cmo_get_info('xic',cmoin,ipxic,lenxic,ictype,ier) call cmo_get_info('yic',cmoin,ipyic,lenyic,ictype,ier) call cmo_get_info('zic',cmoin,ipzic,lenzic,ictype,ier) call cmo_get_info('itetclr',cmoin,ipitetclr,lenitetclr,ictype,ier) call cmo_get_info('itettyp',cmoin,ipitettyp,lenitettyp,ictype,ier) call cmo_get_info('itetoff',cmoin,ipitetoff,lenitetoff,ictype,ier) call cmo_get_info('jtetoff',cmoin,ipjtetoff,lenjtetoff,ictype,ier) call cmo_get_info('itet',cmoin,ipitet,lenitet,ictype,ier) call cmo_get_info('jtet',cmoin,ipjtet,lenjtet,icmotype,ier) C Create the new 2d cmo - call it cmoout. call cmo_exist(cmoout,ier) C ier.eq.0 means that the cmo already exists - if so release it. if(ier.eq.0) call cmo_release(cmoout,idelete) C Set active cmo to cmoout call cmo_set_name(cmoout,ier) C set scalar mesh variables call cmo_set_intinfo('nnodes',cmoout,npoints,1,1,ier) call cmo_set\\intinfo('nelements',cmoout,ntets,1,1,ier) C the following scalars need to be set for a 2d cmo call cmo_set_info('ndimensions_topo',cmoout,2,1,1,ier) call cmo_set_info('ndimensions_geom',cmoout,3,1,1,ier) call cmo_set_info('nodes_per_element',cmoout,3,1,1,ier) call cmo_set_info('faces_per_element',cmoout,3,1,1,ier) C allocate memory for vector variables call cmo_newlen(cmoout,ier) C now get the pointers to the allocated memory for the vector data call cmo_get_info('imt1',cmoout,ipimt1a,lenimt1a,icmotype,ier) call cmo_get_info('itp1',cmoout,ipitp1a,lenitp1a,icmotype,ier) call cmo_get_info('icr1',cmoout,ipicr1a,lenicr1a,icmotype,ier) call cmo_get_info('isn1',cmoout,ipisn1a,lenisn1a,icmotype,ier) call cmo_get_info('xic',cmoout,ipxica,lenxica,icmotype,ier) call cmo_get_info('yic',cmoout,ipyica,lenyica,icmotype,ier) call cmo_get_info('zic',cmoout,ipzica,lenzica,icmotype,ier) call cmo_get_info('itetclr',cmoout,ipitetclra,lenclra,icmotype,ier) call cmo_get_info('itettyp',cmoout,ipitettypa,lentypa,icmotype,ier) call cmo_get_info('itetoff',cmoout,ipitetoffa,lenoffa,icmotype,ier) call cmo_get_info('jtetoff',cmoout,ipjtetoffa,lenoffa,icmotype,ier) call cmo_get_info('itet',cmoout,ipiteta,leniteta,icmotype,ier) call cmo_get_info('jtet',cmoout,ipjteta,lenjteta,icmotype,ier) C now the values for the components of the 2d mesh object can be assigned.",
    "tags": "",
    "url": "/pages/docs/accessing.html"
  },{
    "title": "Applications",
    "text": "LaGriT Applications Visit meshing.lanl.gov for examples of mesh applications in geological applications: porous flow, hydrology, carbon dioxide sequestration, oil and gas, crustal deformation, hydrothermal systems, and more. The following are graphics and software output formats used with LaGriT and may be obtained from their respective sources. Mesh and Simulation Visualization Software AVS (commercial) ParaView (free) GMV (General Mesh Viewer) Tecplot (commercial) VISIT (free) Mesh Tools GRIDDER - a simple grid generation tool for creating orthogonal quadralateral and hexahedral grids. GRIDDER open source LA-CC-15-082 https://github.com/lanl/gridder MSTKLA - Mesh ToolKit using the functionality of LaGriT MSTK open source LA-CC-04-010 https://github.com/MeshToolkit/MSTK LASETUP - interface for generating and viewing LaGriT geometries. Modeling Software Used with LaGriT generated files FEHM (Subsurface Flow and Transport) PFLOTRAN (Parallel Reactive Flow and Transport) GEOFEST (Geophysical Finite Element Simulation Tool)",
    "tags": "ok",
    "url": "/pages/applications.html"
  },{
    "title": "BUBBLE",
    "text": "BUBBLE This command takes a topologically 2d mesh (a planar or non-planar surface), extrudes it into three dimensions along either the normal to the surface (default) or along a user defined vector, and then takes the external surface of the volume created and returns that to the user. This operation will result in a closed surface. SYNTAX bubble/mesh1/mesh2/const or min/offset/[norm x1,y1,z1] mesh1 is the name of the resulting mesh. mesh2 is the name of the initial mesh. This mesh must be either made up of tris, quads, or hybrids. const is a keyword that indicates that the distance from each of the points in the initial mesh along the extruding vector will be equal to offset.Therefore, if you wanted the closed surface mesh to have the same surface characteristics as the original mesh on both the initial and newly formed surface or edge, you would use const. min is a keyword that indicates that the minimum distance along the extruding vector to a reference plane that is perpendicular to the extruding vector will be equal to offset. This means that if you want a closed surface mesh with at least one flat side, you would use min. This also means that if you use min, bubble computes the “bottom point” on the initial mesh, or the point closest to the reference plane, and then extrudes that point by min, all the other points will be extruded by a larger distance. This avoids the problem of having the initial surface intersect the reference plane that forms the other side of the closed surface mesh. offset is the length of extrusion. It can either be an integer or a real. The final argument is optional. It must either be the keyword norm, or a three valued vector (in cartesian space) specifying a direction. The default, if no argument is provided, is norm. If norm is chosen, the element weighted average normal to the surface or curve is computed, and the initial mesh is extruded in that direction. Otherwise, if a vector value is specified, the vector is normalized, and its direction used to extrude the initial mesh. NOTES It is very possible to create an invalid mesh object with this command, especially if the initial mesh is a multivalued surface, or if the extruding vector is in a direction parallel to the plane that contains the initial surface is in. You have been warned. There is an analog to this code that creates the volume enclosed by the surface as opposed to the surface itself. It is called extrude. This code is a wrapper for extrude. There are plans to integrate bubble’s functionality with extrude and to eliminate bubble from the commands recognized by LaGriT. EXAMPLES bubble/cmo_bigbox/cmo_quad/const/5.0/ This would result in a surface surrounding an amalgamation of parallelopipeds created from the initial quad sheet. First, since const is used the quads will be extruded a constant amount from each point in the quad sheet. Second, since the extruding vector and norm are omitted, the extrusion will occur on the average normal to the plane. Therefore, this command will result in a mesh of tris that form the surface of a group of parallelopipeds extruded 5.0 units in an orthogonal direction. bubble/cmo_arbshape/cmo_tri/min/ 7.5/3,-2.5,-6 This command would result in a mesh of tris that form a surface enclosing a volume of prisms being created out of the initial tri sheet. First, since min is used, the “bottom” of the surface would be a plane. Second, because the vector 3, -2.5, -6 is specified, the extrusion will be in that direction (again the magnitude is not important, the vector is normalized to a unit vector), not in the direction of the average normal of the initial tri surface.",
    "tags": "bubble, extrude",
    "url": "/pages/docs/commands/bubble.html"
  },{
    "title": "Building an executable with LaGriT",
    "text": "Building an executable with LaGriT The executable is built by linking a driver routine with the code and utility libraries. The driver routine must contain a call to initLaGriT and a call to control_command_lg and must contain a subroutine called user_sub.  The input arguments to initLaGriT are: mode - set to ‘noisy’ for output to be echoed to the screen - set to ‘silent’ for no echo log_file - name of log file (if ‘ ‘ or ‘-def-‘ use default name which is lagrit.log)  This file will contain a list of commands. batch_file - name of batch file (if ‘ ‘ or ‘-def-‘ use default name which is lagrit.out). This file will contain a list of commands and the error, warning and informational messages generated by the command. User_sub is used to implement user commands, see User Commands. A sample Fortran driver routine is listed below (C++ examples are in examples/liblagrit/): program adrivgen C PURPOSE LaGriT driver implicit none integer ierror_return call initLaGriT('noisy',' ',' ') call control_command_lg(ierror_return) stop end C Subroutine user_sub C C PURPOSE C Process user supplied commands C C INPUT ARGUMENTS C C imsgin - integer array of tokens returned by parser C xmsgin - real array of tokens returned by parser C cmsgin - character array of tokens returned by parser C msgtyp - int array of token types returned by parser C nwds - number of tokens returned by parser C C OUTPUT ARGUMENTS C C ierr1 - 0 for successful completion - -1 otherwise subroutine user_sub(imsgin,xmsgin,cmsgin,msgtyp,nwds,ierr1) character*32 cmsgin(nwds) integer imsgin(nwds),msgtyp(nwds) integer nwds,ierr1,lenc real*8 xmsgin(nwds) C set default error return to fail ierr1=-1 C Insert code here to handle user coded subroutines C For example if(cmsgin(1).eq.'my_cmnd') then call my_rtn(imsgin,xmsgin,cmsgin,msgtyp,nwds,ierr1) else ierr1=-1 endif return end Sample build scripts LaGriT can be compiled on most modern machines including Linux, and Mac. WINDOWS is still under development, but pre-cmake versions were successful under Cygwin. LaGriT now uses cmake to build with or without external libraries such as Seacas Exodus. The most recent instructions can be found on the github pages. Simple install, build, and test: LaGriT Github README Build options and instructions for developers: LaGriT Github cmake README Running LaGriT To execute, use standard unix file redirection for standard input and output. LaGriT will produce two additional files, lagrit.out and lagrit.log. The user can change the names of these files by supplying new names as arguments in the call to initLaGriT before compiling.  These files contain detailed output information and the list of commands respectively. LaGriT may also be run interactively in which case the user will be prompted to enter commands at the machine prompt. lagrit &lt; lagrit_command_file The following are examples to build old releases (pre V3.2) but may be helpful on older machines. Sun OS and Sun Solaris forte version 7 compiler: f90 -O2 -lf77compat -o LaGriTgen adrivgen.f libLaGriT.a libutil.a if the user wishes to link in user subroutines that contain CRAY type pointer statements, these routines must be compiled using the f77 compiler and then the .o files linked in with f90: f77 -c -O2 user_routines.f f90 -O2 -lf77compat -o LaGriTgen adrivgen.f user_routines.o libLaGriT.a libutil.a older sun compilers: f90 -O2 -o LaGriTgen adrivgen.f libLaGriT.a libutil.a IBM RISC xlf -g -o LaGriTgen -qintlog -qcharlen=500 -brename:.fdate,.fdate_ adrivgen.f libLaGriT.a libutil.a SGI f90 -O2 -n32 -r10000 -o LaGriTgen adrivgen.f libLaGriT.a libutil.a Compile for 64 bit I8 SGI: f90 -O2 -64 -i8 -o LaGriTgen adrivgen.f  libLaGriT.a libutil. HP: f90 +U77 -R8 -lm -o LaGriTgen adrivgen.f libLaGriT.a libutil.a DEC COMPAQ compiler fort -i8 -O -fast -pipeline -transform_loops -o LaGriTgen  adrivgen.f  libLaGriT.a libutil.a ABSOFT compiler: f90 -YTEXT_NAMES=LCS  -o LaGriTgen adrivgen.f fdate.f libLaGriT.a libutila. -lm -lu77 where fdate.f is subroutine fdate(string) character*(*) string call fdate_(string) return end LINUX if ($OSTYPE == 'Linux') then set OSTAG = _lin set F77FLAG = \"-c -f -m32 -YEXT_NAMES=ASIS\" set F90FLAG = \"-m32 -YEXT_NAMES=ASIS\" set LINKFLAG = \"-lm -lU77\" set F90DIR = /opt/absoft10.0/bin else if ($OSTYPE == 'Darwin') then set OSTAG = _mac set F77FLAG = \"-c -f -N113 -N90 -B19 -q\" set F90FLAG = \"\" set LINKFLAG = \" -lU77\" set F90DIR = /Applications/Absoft/bin else if ($OSTYPE == 'SunOS') then set OSTAG = _sun source /n/env/local.forte.7 set F77FLAG = -c set F90FLAG = \"-lf77compat \" set LINKFLAG = \" \" set F90DIR = /n/local_SunOS/forte7/SUNWspro/bin else echo 'OS $OSTYPE not recognized ' exit 1 endif set FFILES = \"lagrit_main.f lagrit_fdate.f\" set OFILES = \"lagrit_main.o lagrit_fdate.o\" set binname = lagrit$OSTAG$COPT set binname_date = lagrit$OSTAG$COPT$DATETAG set liblagrit = lagrit$OSTAG$COPT.a set libutil = util$OSTAG$COPT.a 'rm' -f *.o $F90DIR/f77 $CFLAG $F77FLAG $FFILES $F90DIR/f90 $CFLAG $F90FLAG -o $binname $OFILES $LAGRIT_LIBS/$liblagrit $UTIL_LIBS/$libutil $LINKFLAG",
    "tags": "",
    "url": "/pages/docs/build.html"
  },{
    "title": "CALC_RDIST",
    "text": "CALC_RDIST This command is a macro command that calculates the radial distance from a specified point to a set of points. That set of points can be defined using the standard LaGriT syntax of psets and range. If the specification for a set of points is omitted, the whole grid is used. The command operates on the current mesh object. This operation will (often) result in two attributes being added to the current mesh object. The first, a real named rdist, contains the radial distance from the point of interest. The second, an integer named ictrpt, contains an index that specifies the center point that was used for this calculation. SYNTAX calc_rdist/x0,y0,z0/ [radius_index] / [pset,get, pset_name, ifirst,ilast,istride] x0,y0,z0 are the coordinates of the center point used in the calculation. radius_index is an optional integer. It serves as an index for a specific center point.  Its value is placed in the attribute ictrpt throughout the range affected by the command. If it is not specified, no changes are made to the attribute ictrpt. The non-value for this attribute is 0 (i.e., if there is no radius index, the value of ictrpt will be 0). calc_rdist takes specifies the range over which the command will be executed. If it is omitted, the whole mesh is assumed. EXAMPLES calc_rdist/0,0,0 This command would calculate the distance from the origin to all points in the mesh, and place the values in rdist. It would not modify ictrpt in any way. calc_rdist/ 1,0.25,1/ 10/ pset,get,big_sphere This command would calculate the distance from the point 1,0.25,1 to all the points within the pset big_sphere. It would place those distances into rdist within that pset, and would replace the value of ictrpt with 10 within that pset as well.",
    "tags": "calc_rdist radial distance",
    "url": "/pages/docs/commands/calc_rdist.html"
  },{
    "title": "cmo/addatt",
    "text": "cmo/addatt The cmo/addatt command is used to add and initialize a mesh object attribute. The general version of the cmo/addatt adds and initializes a new mesh object attribute. The keyword version of the command recognizes keywords to create and/or fill attribute as defined by the keyword being used. If the named attribute already exists, values in the attribute will be overwritten. Valid Keywords:            scalar    vector    median      edge_connections    num_node_diff    xyz_rtp    xyz_rtz    volume    voronoi    voronoi_volume    hybrid_volume    sumnode    avgnode    minnode    maxnode    ang_mind    ang_minr    ang_maxd    ang_maxr    ang_mind_solid    ang_minr_solid    ang_maxd_solid    ang_maxr_solid Valid Keywords for 2D: Some calculations are only supported for mesh objects of type line, tri, and quad. If one wants to compute the normals to, for example, the outside nodes of a hex or tet mesh, one must first extract a surface mesh and then compute the normals to the surface mesh.            area_normal    unit_area_normal    synth_normal_area    synth_normal_angle    area    length    voronoi_varea    quad_quality GENERAL SYNTAX cmo/addatt/mo_name/ att_name / [ type / rank / length / interpolate / persistence / ioflag / value ] mo_name is the name of the mesh object to add attribute to. att_name is the name of the new attribute for the mesh object. type / rank / length / interpolate / persistence / ioflag / value are parameters for the new attribute. The defaults are: type (vdouble), rank (scalar), length (nnodes), interpolation (linear), persistance (temporary), ioflag (agl), value (0.0). See MODATT for descriptions of mesh object attribute parameters. KEYWORD SYNTAX cmo/addatt/mo_name/ keyword / keyword_parameters / cmo/addatt/-def-/ keyword / keyword_parameters / KEYWORDS for 4th parameter: scalar / att_1snk att_2snk att_3snk / att_v_src creates three node or element scalar attributes from a vector attribute. vector / att_v_snk / att_1src att_2src att_3src creates node or element attribute of rank vector from three existing scalar attributes. The new attribute will have a length = rank x nnodes (or nelements). Note: vector type attributes are not supported in many of the dump formats including AVS and GMV. Convert a vector attribute to multiple scalar attributes before writing to file. median / [xmed ymed zmed] creates three element attributes that are the coordinates of the median point (average value of the vertices) of each element. This is valid for all element types. (default attribute names are xmed, ymed, zmed) edge_connections / att_sink creates an integer node attribute with the number of edge connections to each node. node_num_diff / att_sink creates an integer attribute with the maximum difference in node number between the node and any node it is connected to. That is for node i connected to nodes j_1, j_2, …j_n, the attribute will contain attribute=max(i-j_1,i-j_2, … i-j_n) volume or area / att_name creates an element attribute of type VDOUBLE. For volume the attribute is filled with volume(if 3D), area(if 2D) or length(if lines). Currently implemented for triangle areas. voronoi / xvor, yvor, zvor creates three element attributes that are the x y z coordinates of the Voronoi point (center of circumscribed circle or sphere) of each element. This is only valid for elements of type tri and tet. This command does not check if a mesh is Delaunay, so a better keyword might be circumscribed_center. (Default attribute names are xvor, yvor, zvor). voronoi_volume / att_name creates a node attribute of type VDOUBLE. Currently implemented for a tetrahedral mesh by calling the build stor function to form the Voronoi bounding area for each node. See more about build stor in dump/stor. hybrid_volume / att_name creates a node attribute of type VDOUBLE which contains the volume of each hybrid median-Voronoi control volume. This is currently implemented for a tetrahedral mesh by calling the build stor function with the hybrid option. See dump/stor for details on what hybrid median-Voronoi volumes are. Currently this option is only available for 3D tetrahedral meshes. sumnode / att_name_elem / att_name_node creates an element attribute and fills it with the sum of each elements’ node attribute values. avgnode / att_name_elem / att_name_node creates an element attribute and fills it with the average of each elements’ node attribute values. minnode / att_name_elem / att_name_node creates an element attribute and fills it with the minimum of each elements’ node attribute values. maxnode / att_name_elem / att_name_node creates an element attribute and fills it with the maximum of each elements’ node attribute values. xyz_rtp / [ [att_node_r att_node_theta att_node_phi ] creates three node attributes and fills them with the node coordinate, x y z in spherical coordinates, radius, theta, phi. (Defaults are c_r, c_theta, c_phi). xyz_rtz / [ c_r, c_theta, c_z ] creates three node attributes and fills them with the node coordinate, x y z in cylindrical coordinates, radius, theta, z. (Defaults are c_r, c_theta, c_z). area_normal / normal_type / att_v_name creates an element attribute of rank vector and fills with the x y z components of area normals for each face. The normal_type choices include xyz, rtz, and rtp. The area normal is a vector perpendicular to the triangle face with length equal to the area of the triangle. Currently implemented for xyz on triangles only. unit_area_normal / normal_type / att_v_name creates an element attribute of rank vector and fills with the x y z components of vector perpendicular to the face and with length equal to one. The normal_type choices include xyz, rtz, and rtp. The area normal is a vector perpendicular to the triangle face with length equal to the area of the triangle. Currently implemented for xyz on triangles only. voronoi_varea / att_name_xn att_name_yn att_name_zn creates three node attributes with type VDOUBLE. The attributes represent each of the x y z components for the Voronoi areas formed by surrounding nodes. Currently implemented for a triangle mesh by calling the same routine that is used to compute the Voronoi areas for the external faces of a tetrahedral mesh. Works only on a triangle mesh. See more in dump/zone_outside. synth_normal_area creates three node attributes, x_n_norm, y_n_norm, z_n_norm, and fills them with the area weighted normal of each node. synth_normal_angle creates three node attributes, x_n_norm, y_n_norm, z_n_norm, and fills them with the angle weighted normal of each node. The synthetic normal is computed by computing the normal to all elements incident upon a node and then taking the weighted average of all the normals. The weight factor is based on area or incident angle depending upon which option is selected. quad_quality / att_name_quality / att_name_regularity / att_name_flag creates element attributes att_name_quality, att_name_regularity, and att_name_flag. These three attributes all describe the quality of each quadrilateral in a quad mesh. See example below. The following commands create element attributes related to element angle measurments. The Dihedral angle calculations are supported for tri, quad, tet, pyramid, prism, hex. The Solid angle calculation is only supported for tet elements. See also the command QUALITY for adding attributes such as element aspect ratio(quality/aratio) and edge length ratio (quality/edge_ratio), minimum edge length (quality/ edge_min) and maximum edge length (quality/edge_max). ang_mind / att_name create a scalar element attribute and fill it with the minimum dihedral angle (degrees) of the element ang_minr / att_name create a scalar element attribute and fill it with the minimum dihedral angle (radian) of the element ang_maxd / att_name create a scalar element attribute and fill it with the maximum dihedral angle (degrees) of the element ang_maxr / att_name create a scalar element attribute and fill it with the maximum dihedral angle (radian) of the element These dihedral angles will be between 0 and 2pi. ang_mind_solid / att_name create a scalar element attribute and fill it with the minimum solid angle (degrees) of the element ang_minr_solid / att_name create a scalar element attribute and fill it with the minimum solid angle (radian) of the element ang_maxd_solid / att_name create a scalar element attribute and fill it with the maximum solid angle (degrees) of the element ang_maxr_solid / att_name create a scalar element attribute and fill it with the maximum solid angle (radian) of the element These solid angles will be between 0 and 4pi. EXAMPLES of GENERAL FORMAT cmo/addatt/ cmo1 / boron1 /VDOUBLE/scalar/nnodes/asinh/permanent Create node attribute named boron1 with interpolate method of asinh. cmo/addatt/ cmo1 /z_save/VDOUBLE/scalar/nnodes/linear/permanent/ cmo/copyatt/ cmo1 cmo1 / z_save zic Create node attribute named z_save then use copyatt to copy values from zic to z_save. cmo/addatt/ cmo1 /boron3 /VDOUBLE/scalar/nnodes/user/temporary/ .1 Create temporary node attribute named boron3 and fill with value .1 cmo/addatt/-default-/boron3 Create attribute named boron3 with default mesh object settings. EXAMPLES of KEYWORD FORMAT cmo/addatt/ cmotri / area_normal / anorm Create and fill element vector named anorm with the x,y,z components for area normals of each triangle. cmo/addatt/ cmotri / unit_area_normal / n_face Create and fill element vector named n_face with the x,y,z components for unit area normals of each triangle. cmo/addatt/cmo1/ scalar / xnorm, ynorm, znorm / anorm Create attributes xnorm, ynorm, znorm from the three components of the vector attribute anorm. cmo/addatt/cmo1/ vector / vnorm /xnorm, ynorm, znorm Create vector attribute vnorm from the three attributes xnorm, ynorm, znorm with length nnode (or nelement) x 3. cmo/addatt/ cmotri / area / darea Create and fill attribute named darea with area of each triangle. cmo/addatt / cmotet / voronoi_volume / vor_vol Create and fill attribute named vor_vol with Voronoi volume of each node in tetrahedral mesh. cmo/addatt / cmotet / hybrid_volume / hybrid_vol Create and fill an attribute named hybrid_vol with the hybrid median-Voronoi volume of each node in a tetrahedral mesh. cmo/addatt/cmotri/ voronoi_varea / xvarea yvarea zvarea Create and fill attributes xvarea, yvarea, and zvarea with xyz components of the Voronoi areas for each node in triangle mesh. cmo / addatt / cmo / ang_mind / ang_mind cmo / addatt / cmo / ang_minr / ang_minr cmo / addatt / cmo / ang_maxd / ang_maxd cmo / addatt / cmo / ang_maxr / ang_maxr cmo / addatt / cmo / ang_mind_solid / sang_mind cmo / addatt / cmo / ang_minr_solid / sang_minr cmo / addatt / cmo / ang_maxd_solid / sang_maxd cmo / addatt / cmo / ang_maxr_solid / sang_maxr cmo / addatt / cmo / synth_normal_area cmo / addatt / cmo / synth_normal_angle cmo / addatt / cmo / sumnode / elem_sum_imt / imt cmo / addatt / cmo / maxnode / elem_max_boron / boron Various examples. EXAMPLE quad_quality: cmo/addatt/cmoquad / quad_quality / quality regularity flag Create attributes named quality, regularity, and flag with several quad quality measures. The first attribute represents the measure: where is a normalization constant and is the longest length among the fouredges and the diagonals. is the mininum area of the four triangles constructed by adding a diagonal to the quad. This metric ranges from zero (poor) to one (good). The second attribute represetns the regularity of each quad ABCD, defined as where and This is a measure of the extent to which the quad is planar. The values range from zero (non-planar) to one (planar). The third and final attribute is an integer flag which gives information about the quad: 0 (good) = the quad is non-degenerate. For drawing a diagonal across it, the area vectors of the triangles have a positive dot product. 1 (degenerate) = at least one of the triangles detirmined by three of the vertices of the quad has zero area. That is the quad has degenerated into a triangle or worse. 2 (warped) = one of the quad's diagonals divides it into two triangles whose area vectors have a negative dot product. If the quad is planar, then this is self-intersecting or vertices are in wrong order by mistake.",
    "tags": "cmo addatt",
    "url": "/pages/docs/commands/cmo/cmo_addatt.html"
  },{
    "title": "cmo/addatt - add an attribute to a mesh object",
    "text": "cmo/attribute_derive cmo/attribute_union SYNTAX cmo/attribute_derive / sink_mo_name /  [ src_mo_name ] cmo/attribute_union / sink_mo_name /  src_mo_name cmo/attribute_derive is used to give one mesh object (at least) the same set of attributes as another mesh object. This is useful, for example, for merging two mesh objects. Specifically, it looks at the set of attributes present in the source mesh, compares it to the set of attributes in the sink mesh, and adds to the sink mesh any attributes that it is missing. cmo/attribute_union is a wrapper and executes attribute_derive twice, once in each direction and is used to give two mesh objects the same set of attributes as each other. This is useful, for example, for merging two mesh objects. Specifically, it looks at the set of attributes present in each mesh, compares it to the set of attributes in the other mesh, and makes it so each mesh posesses the union of the two sets of attributes. sink_mo_name is the new or modified mesh object. src_mo_name is mesh object to derive from. If no source mesh is given, it will use the current mesh object. The attribute_union command needs both the sink and source meshes to be designated. EXAMPLES cmo/attribute_derive/cmo_sink/cmo_src cmo/attribute_derive/empty_cmo cmo/attribute_union/ cmo2 / cmo1",
    "tags": "cmo addatt",
    "url": "/pages/docs/commands/cmo/cmo_att_derive.html"
  },{
    "title": "cmo/compress",
    "text": "cmo/compress Shortens all memory managed arrays for Mesh Object to their actual lengths. SYNTAX cmo/compress/ mo_name mo_name is type character, default is the current mesh object. EXAMPLES cmo/compress/ mo_tet2 cmo/compress/-cmo- cmo/compress cmo/compress/-all-",
    "tags": "cmo compress",
    "url": "/pages/docs/commands/cmo/cmo_compress.html"
  },{
    "title": "cmo/constraint",
    "text": "cmo/constraint Associate the surface constraint information of the mesh object cmo_src with cmo_sink.  The number of constraints and the constraint table ( nconbnd, icontrab) are copied from the source mesh object to the sink mesh object.  Since nconbnd and icontab are mesh object attributes, they must be explicity copied if a new mesh is to use an existing geometry. See Mesh Object  for descriptions. SYNTAX cmo/constraint/ cmo_sink/ cmo_src          EXAMPLES cmo/create/cmotet geometry/create/boxg surface/s1/ surface/s2 region mregion ... cmo/create/cmohex///hex cmo/geometry/boxg cmo/constraint/cmohex/cmotet This example will use the geometry (surfaces regions and material regions) defined when creating cmotest and apply the geometry to the mesh object cmohex.",
    "tags": "cmo constraint",
    "url": "/pages/docs/commands/cmo/cmo_constraint.html"
  },{
    "title": "cmo / copy",
    "text": "cmo / copy Makes an exact copy of a Mesh Object including all data. SYNTAX cmo / copy/ mo_name /master_mo mo_name is type character, required. This will be the new mesh object and will become the Current Mesh Object. If mo_name exists it is over written. master_mo is type character, default is ‘-cmo-‘. This is the mesh that will be copied. If mo_name is the same as master_mo nothing happens. EXAMPLES cmo/copy/mo_tet2/mo_tet1 cmo/copy/-cmo-/mo_tet1 cmo/copy/mo_tet2 cmo/copy/mo_tet2/-cmo- All examples will create the new mesh object mo_tet2 copied from master mo_tet1 assuming mo_tet1 is current mesh object. cmo/ copy/ mopts / motet cmo/ create / mopts copypts / mopts / motet These examples have different behaviors. cmo/copy will create a duplicate cmo from motet and name it mopts. Assuming motet is a tet mesh, mopts will also be a tet mesh. The example command copypts will copy all nodes into the empty new mesh object named mopts. No elements will be copied.",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_copy.html"
  },{
    "title": "cmo/copyatt",
    "text": "  cmo/copyatt The cmo/copyatt command is used to copy one attribute field to another. There is currently no provision for indexed sets. FORMAT: cmo / copyatt / cmo_sink / cmo_src / attname_sink / attname_src cmo_sink / cmo_src : are the mesh object names to write to(sink) and from (source). The two names can represent the same mesh object. attname_sink / attname_src : are the mesh object attributes to write to (sink) and from (source). If the two attributes differ in type or length, a message will be written. The routine does allow the values of an element attribute to be written to the nodes of that belong to each element. To create a mesh object where each element has its own unique set of nodes, create parent-child chains for each element. This can be done using commands mo/set_id and settets. EXAMPLES: cmo / copyatt / cmo1 / cmo2 / itetclr / itetclr cmo / copyatt / cmo1 / cmo2 / itetclr Both versions will copy itetclr from cmo2 to cmo1. cmo / addatt / cmotet / elevation cmo / copyatt / cmotet cmotet / elevation zic In the mesh object cmotet, attribute zic is copied to attribute elevation. cmo / copyatt cmotri cmotri/ itetsav itetclr cmo / set_id / cmotri / element / itetclr settets cmo / copyatt / cmotri cmotri / imt itetsav Copy element itetclr values into attribute itetsav. Create parent-child chains so each element has its own set of nodes. Copy the saved itetsav values into node attribute imt for each element. Each element will have nodes where the imt values match element itetsav values.",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_copyatt.html"
  },{
    "title": "cmo/create",
    "text": "cmo/create Creates a new Mesh Object which becomes the Current Mesh Object. SYNTAX cmo/create/mo_name/[npoints/nelements/ mesh_type]/ If a Mesh is created using the first (mesh_type) format, then values are supplied for the other parameters as follows: mesh name ndimension geom ndimension topo   nodes per element faces per element edges per element tet    3    3    4    4    6 hex    3    3    8    6    12 pri(sm)    3    3    6    5    9 pyr(amid)    3    3    5    5    8 tri(angle)    3    2    3    3    3 qua(d)    3    2    4    4    4 hyb(rid)    3    3    10    10    12 lin(e)    3    1    2    2    1 triplane    2    2    3    3    3 mo_name required. If mo_name exists nothing happens. If values are supplied for npoints and/or nelements then space is allocated, but values are not entered for the mesh object attributes: nnodes and nelements EXAMPLES cmo/create/mo_tet2 cmo/create/mo_tet2/0/0/hex",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_create.html"
  },{
    "title": "cmo/delatt",
    "text": "cmo/delatt Deletes an attribute from a Mesh Object. SYNTAX cmo / delatt / mo_name / att_name cmo / DELATT / mo_name / att_name delatt delete attribute from the current Mesh Object. This will not delete an attribute with a persistence of ‘permanent’. DELATT delete attribute from the current Mesh Object even if it has a persistence of ‘permanent’. mo_name is the mesh object. The mesh object name must be specified, but keywords can be used, such as -cmo- for current mesh object. att_name is the name of the attribute to delete from the mesh object. The attribute name must be specified, but keywords can be used, such as -all- for all attributes in the mesh object. EXAMPLES cmo/delatt/ mo_tet /boron cmo/delatt/ -cmo- / boron If mo_tet is the current mesh object, both commands will delete the attribute named boron from mo_tet. cmo/delatt/ -cmo- / -all- This will delete all attributes from the current mesh object with persistence of temporary. cmo/DELATT/ mo_tet/ imt1 cmo/DELATT/ mo_tet/ itp1 cmo/DELATT/ mo_tet/ icr1 cmo/DELATT/ mo_tet/ isn1 Even though imt1, itp1, icr1, and isn1 are permanent, they are removed from mesh object named mo_tet. This can be useful when writing mesh files where these attributes are not needed and can reduce the written file size.",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_delatt.html"
  },{
    "title": "",
    "text": "Create a new mesh object derived from an existing mesh object. cmo/derive SYNTAX cmo/derive/ mo_name / master_mo/ mo_name is the new mesh object to create, it will be an image of the master mesh object but will contain no data. This mesh object will become the current mesh object. If mo_name is the same as master_mo nothing happens. If mo_name exists it is over written. master_mo is the template for deriving a new Mesh Object. (default is -cmo- or current mesh object).   EXAMPLES cmo/derive/ mo_tet2/mo_tet1 cmo/derive/-cmo-/ mo_tet1 cmo/derive/ mo_tet2 cmo/derive/ mo_tet2/-cmo- cmo/derive/-default-/-cmo- cmo/derive/ mo_tet2/-default- cmo/derive/-default-/ mo_tet1",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_derive.html"
  },{
    "title": "cmo/geometry",
    "text": "cmo/geometry Associate a geometry with a mesh object. The geometry is created with surface and region commands. All geometry information will be updated to the geometry information of the named geometry.  This includes number of surfaces, regions, material regions, current geometry name, and definitions of active surfaces, regions and material regions. Geometries for a discussion of geometry.  The cmo/constraint command might also be required. SYNTAX cmo/geometry /cmo_name / geom_name cmo_name is the mesh object whose attribute geometry_name will be assigned geom_name. The mesh object and geometry must have been previously created.  EXAMPLES geometry/create/blobgeom/ cmo/create/mo1 cmo/geometry/mo1/blobgeom/ cmo/constraints/mo_sink/cmo_src",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_geom.html"
  },{
    "title": "cmo/length",
    "text": "cmo/length Returns the memory length of an attribute for a Mesh Object. SYNTAX cmo/length/ mo_name / att_name mo_name is the name of the mesh object, default is -all- att_name is the name of the attribute, default is -all- EXAMPLES cmo/length/ mo_tet2/boron cmo/length/-cmo-/boron cmo/length/-default-/boron cmo/length/-cmo-/-all- cmo/length/ mo_tet2/-all- cmo/length cmo/length/-all-/-all- cmo/length/-all-/boron",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_length.html"
  },{
    "title": "cmo/list",
    "text": "cmo/list Returns the name of the Current Mesh Object and a list of all defined Mesh Objects cmo/list",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_list.html"
  },{
    "title": "cmo/memory",
    "text": "cmo/memory Allows the user to preset the size of the memory managed arrays for the named Mesh Object. SYNTAX cmo/memory/ mo_name / number_nodes/ number_elements mo_nameis the name of the mesh object, required. The keyword -cmo- may be used to act on current mesh object. number_nodes is the size for the nnodes mesh object arrays, required. number_elements is the size for the nelements mesh object arrays, required. EXAMPLES cmo/memory/ mo_tet2/1000/10000 cmo/memory/ -cmo- /1000/10000",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_memory.html"
  },{
    "title": "cmo modatt",
    "text": "CMO/MODATT Modifies a field for a mesh object attribute. For more descriptions of the mesh object attributes, see Mesh Object Definition modatt/ cmo_name/ cmo_att_name /cmo_field_name/ new_values cmo_name is the mesh object name. cmo_att_name is the mesh object attribute. cmo_field_name is type character, required new_values is new field or fields as appropriate for that field. Mesh Object Fields name (character) Attribute name type (character) Attribute type INT Integer number REAL Real number CHARACTER character variable of length 32 VINT Vector of integer VDOUBLE Vector of real *8 (this is the default) VCHAR Vector of character *32 rank (character) Attribute rank (must be an attribute for this Mesh object), default is scalar length (character) Attribute length (must be an attribute for this Mesh object), default is nnodes interpolation (character) Interpolation option: constant Constant value sequence Set to the node number copy Copy values linear Linear interpolation, this is the default user User provides a subroutine named user_interpolate log Logarithmic interpolation asinh Asinh interpolation min Set to the minimum max Set to the maximum incmin Set to the minimum plus one (vint attribute only) incmax Set to the maximum plus one (vint attribute only) and ‘and’ the bits or ‘or’ the bits persistence (character) Attribute persistence: permanent Can not be deleted. temporary Temporary attribute, this is the default ioflag (character) Attribute IO flag: default is agl (avs,gmv, and lagrit) a Put this attribute on avs dumps g Put this attribute on gmv dumps f Put this attribute on fehm dumps l Put this attribute on LaGriT dumps L Do not write this attribute to LaGriT dumps default (real) Attribute value EXAMPLES define CMO cmo1 cmo / modatt / CMO / itp1 / ioflag / l cmo / modatt / CMO / icr1 / ioflag / l cmo / modatt / CMO / isn1 / ioflag / l This is often used to reduce the amount of data written to an AVS format file. By default, the attributes imt,itp,icr,isn are written to the file.If not needed, modify the IO output so attributes will not be written unless it is an l type for lagrit file formats. This example uses a define variable to set the mesh object variable CMO to “cmo1”. Note the command parser recogizes these AVS attribute names with or without the letter “1” on the name. cmo/select/ mo_tet cmo/modatt/-cmo-/boron/length/ nnodes cmo/modatt/-def-/boron/default/ 10.0 cmo/modatt/-def-/boron/interp/ user These set of commands are used to modify the attribute “boron” in the mesh object named “mo_tet”. The attribute length is changed from nelements to nnodes. The default value is set to 10. and the interpolation type is set to user.",
    "tags": "cmo, modatt, attibute",
    "url": "/pages/docs/commands/cmo/cmo_modatt.html"
  },{
    "title": "cmo/move",
    "text": "cmo/move Moves or rename a mesh object to a new name. SYNTAX   cmo/move/ mo_name / master_mo / mo_name is the new name for master mesh object, required. master_mo is the mesh object to move or rename, default is -cmo-. If mo_name is the same as master_mo nothing happens. If mo_name exists it is over written. EXAMPLES cmo/move/ mo_tet2/mo_tet1 cmo/move/-mo-/mo_tet1 cmo/move/ mo_tet2 cmo/move/ mo_tet2/-cmo-",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_move.html"
  },{
    "title": "cmo/newlen",
    "text": "cmo/newlen Changes the length of all memory managed arrays for Mesh Object to the proper length. SYNTAX cmo/newlen/ mo_name / mo_name is the name of the mesh object, default is -cmo-     EXAMPLES cmo/newlen/ mo_tet2 cmo/newlen/-cmo- cmo/newlen",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_newlen.html"
  },{
    "title": "cmo/printatt",
    "text": "cmo/printatt SYNTAX cmo/printatt/ mo_name/ attribute_name cmo/printatt/ mo_name/ attribute_name / [ print_option ] [ index_set ] cmo/printatt/ mo_name/ [-all- -xyz- node element ] / [ minmax list value ] / [ index_set ] attribute_name -  name of valid cmo attribute or category of attributes. The category selections are: -all- will printall attributes in the mesh object -xyz- will print attributes xic,yic,zic node will print all attributes of length nnodes element will print all attributes of length nelements print_option is the print display option. value  this is default, prints attribute values list   will print attribute name along with its length minmax will print name and the min and max of the attribute field and length index_set is the range istart,istride,ilast using pset, eltset, or index numbers where 1,0,0 are all.   EXAMPLES cmo/printatt/mo1/zic/3,8,0 cmo/printatt/mo1/itetclr/eltset,get,eset1 print values for attribute zic for nodes between index 3 and 8 print values for attribute itetclr for elements in the element set eset1 cmo printatt/mo1/-all-/list cmo printatt/mo1/node/list print attribute names for all attributes in the mesh object mo1 print attribute names for all attributes of length nnodes cmo/printatt/mo1/-all-/minmax cmo/printatt/mo1/-xyz-/minmax cmo/printatt/mo1/xic/ minmax/7,10,0 cmo/printatt/mo1/itp1/minmax/pset,get,pset1 cmo/printatt/mo1/itetclr/minmax/eltset,get,e_small print min and max of attributes  ",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_printatt.html"
  },{
    "title": "CMO / READATT",
    "text": "CMO / READATT Read field style data from file. Expects same number of values each line. Any line starting with “#” will be ignored. Any line starting with a character string will be ignored. SYNTAX cmo/readatt /cmo_name/attr1/[attr2..] operation / filename cmo_name is type character, required. The data will be read into the node attributes of this mesh object. attr1 is the data to read the first field into, attr2 would be the second field, etc. Not all fields need to be read, but they will be read in the order they occur. Attributes are assumed to be node length, see example below how to copy values into element length attributes. operation is either add which will cause new nodes to be added to the mesh object or ifirst, islast, istride which specifies the nodes whose values will be replaced. filename is type character required and specifies the ASCII file to be read. EXAMPLES cmo / create / mo_name / / / tet cmo/readatt/mo_name/ xic,yic,zic,node_val1,node_val2 / 1,0,0 / input_tab.dat Read x,y,z coordinates and some values into node attributes node_val1 and node_val2 from a file of tabular data. The first three lines are ignored. None of the tagged information is retained. Ignored lines can be indicated by either a # in column one or anything other than a real or integer as the first token in a line. Input file input_tab.dat can be a TecPlot format file something like: TITLE=\"Heterogeneity of TMCM #39, 1=newzone 81, 2=newzone 82\" variables=\"x\",\"y\",\"z\", \"zone\", \"element\" zone t=\"facies\" I=191, J=136, K= 57 0.53600E+06 0.41020E+07 0.00000E+00 2 1 0.53610E+06 0.41020E+07 0.00000E+00 2 2 0.53620E+06 0.41020E+07 0.00000E+00 2 3 ... cmo/readatt /mo_tet2/xic,yic,zic/add /// myfile New nodes will be added to mo_tet2, and their coordinates will be supplied from the file. The value of nnodes will be updated. For this example 2 nodes and their values will be added to mo_tet2. Contents of myfile: 0.017 12.65 7.25 1.1 10.2 3.4 cmo/readatt /mo_tet2/itp1/new_node_attr/pset,set,p1/myfile The values of itp1 will be replaced. If new_node\\attr does not exist it will be created as a VDOUBLE node based attribute. # read values into temporary mesh node attributes cmo / create / mo_temp cmo / readatt / mo_temp / permx permy permz por / 1 0 0 / file.table read/avs/dfm_tet_mes.inp/mo # create element attributes # nelements should be equal to the node length of mo_temp cmo / addatt / mo / permx / vdouble / scalar / nelements cmo / addatt / mo / permy / vdouble / scalar / nelements cmo / addatt / mo / permz / vdouble / scalar / nelements cmo / addatt / mo / por / vdouble / scalar / nelements cmo / copyatt / mo / mo_temp / permx / permx cmo / copyatt / mo / mo_temp / permy / permy cmo / copyatt / mo / mo_temp / permz / permz cmo / copyatt / mo / mo_temp / por / por cmo / delete / mo_temp Read data into temporary mesh object with attribute nnodes long. The data is copied into element attributes of length equal to the mo_temp node attributes. define MINX 498000. define MAXX 500500. define MINY 537000. define MAXY 540500. define NX 101 define NY 141 cmo/create/cmoquad///quad quadxy NX NY/MINX MINY 0./MAXX MINY 0./MAXX MAXY 0./MINX MAXY 0. rzbrick/xyz/NX,NY,1/1,0,0/connect cmo/readatt/cmoquad/ xic,yic,zic /1,0,0/input_ev.dat Read into created quad mesh of known spacing 14261 coordinate values. This is useful for grid files where the connectivity is implied but not included in the coordinate file.",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_readatt.html"
  },{
    "title": "cmo/release",
    "text": "cmo/release Delete a mesh object and release memory. SYNTAX cmo/ release / mo_name/ mo_name is type character, required. EXAMPLES cmo/release/ mo_tet2 cmo/release/-cmo-",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_release.html"
  },{
    "title": "cmo/select",
    "text": "cmo/select Select named mesh object to be the Current Mesh Object. SYNTAX cmo/select/ mo_name / mo_name is the name of the mesh object to make current. If a mesh object does not exist with this name, a new Mesh Object will be created using the Default Mesh Object as the template.   EXAMPLES cmo/select/ mo_tet",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_select.html"
  },{
    "title": "cmo/setatt",
    "text": "cmo/setatt Operation to set mesh object attributes with values. See the description of mesh object and attributes for setting options. [Mesh Object}(../../meshobject.md) SYNTAX cmo/setatt / mo_name / attribute_name /ifirst,ilast,istride/ value cmo/setatt / mo_name / attribute_name / value mo_name is the name of the mesh oject to set values attribute_name is the name in the mesh object to operate on ifirst,ilast,istride is the selection where 1,0,0 will operate on all members of the attribute. The node or element set syntax can be used instead of the integer range. See pset and eltset commands. If the range selection is not present, all members are applied. value is type integer or real depending on the type of the attribute. The value is assigned to the selected range of `attribute_name’. EXAMPLES cmo/setatt/mo/imt/1,0,0/1 cmo/setatt/mo/itp/1,0,0/0 Will set all values of node attribute imt to 1 and itp1 to 0, this is often done to set defaults before using connect. cmo/setatt/ 3dmesh /itetclr /eltset,get,blue/ 3 Will set all elements of attribute itetclr and in the element set ‘blue’ to have the value of 3 cmo/setatt // ndimensions_geom / 2 Will reset the ndimensions geometry attribute of the active mesh object to 2 define ATT_RESET xfield cmo/setatt/ -def- / ATT_RESET /pset,get,p_reset/ 0.0d0 The attribute name is defined in a variable call ATT_RESET. The value zero is assigned to the p_reset node selection. This will operate on the current active mesh object, use cmo/select to make a mesh object current.",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_setatt.html"
  },{
    "title": "cmo/set_id",
    "text": "This command creates integer attributes that contain the node and/or element number. This is useful if later operations delete nodes or elements causing renumbering, these attributes will contain the original node or element number. cmo/set_id cmo/set_id /mo_name/ both node element /[attribute_name1]/[attribute_name2] mo_name is the name of the mesh object. both or node or element indicate which attributes to create, node numbers, element numbers, or both. If no attribute name is given on the command line, the default attribute names id_node or id_elem will be used.   EXAMPLES cmo/create/cmo1///hex createpts/brick/xyz/11,11,11/0.,0.,0./1.,1.,1./1,1,1 cmo/set_id/cmo1/node cmo/set_id/cmo1/element cmo/set_id/cmo1/both cmo/set_id/cmo1/node/id_node2 cmo/set_id/cmo1/element/id_elem2 These set_id commands will add node and element attributes to the mesh object cmo1. Node and element id numbers will be written to default node attribute names id_node id_elem and another set of id numbers will be written to user attributes with names id_node2 id_elem2 cmo/set_id/cmo1/both/id_node1/id_elem1 pset/p_xgthalf/geom/xyz/1,0,0/.5,0,0/1,1,1 rmpoint/pset,get,p_xgthalf rmpoint/compress dump/set_id.inp/cmo1 This example copies node id numbers into node attribute id_node1 and element id numbers into element attribute id_elem1. A set of points are selected within a box shaped geometry and then deleted. The rmpoint/compress will remove the nodes tagged for removal and reorder the mesh nodes and element to their new size. The original node and element id numbers are preserved in the added attributes.      ",
    "tags": "cmo set_id",
    "url": "/pages/docs/commands/cmo/cmo_setid.html"
  },{
    "title": "cmo/status",
    "text": "cmo/status Prints the status of a selected Mesh Object or all Mesh Objects.  This includes a header with information about the type of mesh object and the size of the mesh object.  After the header information, a table lists all variables associated with a mesh object and includes the variable’s type, rank, length, interpolation mode, persistence, ioflag and default value.  SYNTAX cmo/status/ [mo_name] / [ brief ] mo_name is the name of the mesh object, default is -all-. brief will print a brief version of the status and show only the header information. EXAMPLES cmo/status/ mo_tet2 cmo/status/-cmo- cmo/status/ mo_tet2/brief cmo/status cmo/status/-all- cmo/status/-default- An example of header information follows: 1 Mesh Object name: cmo1 number of nodes= 143988  number of elements = 314159 dimensions geometry = 3  element type = tet dimensions topology = 3  4 nodes   4 faces   6 edges boundary flag = 16000000  status = inactive",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_status.html"
  },{
    "title": "cmo/verify",
    "text": "cmo/verify Verify that Mesh Object is consistent. SYNTAX   cmo/verify/ mo_name / mo_name is the mesh object, default is -all-.   EXAMPLES cmo/verify/ mo_tet2 cmo/verify/-cmo- cmo/verify cmo/verify/-all- cmo/verify/-default-",
    "tags": "",
    "url": "/pages/docs/commands/cmo/cmo_verify.html"
  },{
    "title": "Command Interface",
    "text": "Command Interface LaGriT runs on the command line as interactive mode or with an input command file. LaGriT will write two output files upon completion, by default they are lagrit.out (summary and reports for each command) and lagrit.log (saved commands). Run on the command line with either method: lagrit lagrit &lt; input_commands.lgi Run the Tutorial and see Example command files at Tutorials and Examples To get started with the commands, the user must create a mesh object. The mesh object can be defined by reading in a mesh file, or by creating one. To create an empty mesh object use the command cmo/create mesh_name. There is no limit on the number of Mesh Objects that can be defined, but at any time there is only one ‘current’ or ‘active’ Mesh Object. For more advanced problems, such as those requiring more than one Mesh Object or requiring extensions to the basic Mesh Object template, the Mesh Object(s) is(are) manipulated via the cmo commands. For example, additional user defined attributes may be added to a Mesh Object by using the cmo/addatt command, or the ‘active’ Mesh Object can be changed using the cmo/select command. This example session reads 2 mesh files into 2 mesh objects mo_tet and cmo_1. The command cmo/list reports all mesh objects including the default template and the 2 new mesh objects. The last mesh object created is the current mesh object. The command cmo / status / -all- / brief gives a brief description of each mesh object. The command finish will exit the command line interface. A command file MUST have a finish for a clean exit. The following is an example of the screen output during a session, this will also be recorded in file lagrit.out read / avs / tet.inp / mo_tet read / avs / test_tet_small.inp / cmo_1 cmo / list The current-mesh-object(CMO) is: cmo_1 0 Mesh Object name: -default- 1 Mesh Object name: mo_tet 2 Mesh Object name: cmo_1 cmo / status / -all- / brief The current-mesh-object(CMO) is: cmo_1 1 Mesh Object name: mo_tet number of nodes = 1110 number of elements = 5031 dimensions geometry = 3 element type = tet dimensions topology = 3 4 nodes 4 faces 6 edges boundary flag = 16000000 status = inactive 2 Mesh Object name: cmo_1 number of nodes = 5 number of elements = 2 dimensions geometry = 3 element type = tet dimensions topology = 3 4 nodes 4 faces 6 edges boundary flag = 16000000 status = active finish The output file lagrit.out will save the same information you see on the screen while running LaGriT. The output file lagrit.log will save the commands and you can copy this file and possibly edit to run again. % cat lagrit.log read/avs/tet.inp/mo_tet read/avs/test_tet_small.inp/cmo_1 cmo/list cmo/status/-all-/brief finish",
    "tags": "",
    "url": "/pages/docs/commandi.html"
  },{
    "title": "LaGriT Commands - Alphabetical",
    "text": "Alphabetic Listing of LaGriT Commands                                                      A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z  ADDMESH (join meshes) ASSIGN (set global mesh object variables) BOUNDARY (set boundary attributes on surfaces) BOUNDARY_COMPONENTS (count boundary components) BUBBLE (extrude to 3D and extract boundary) CALC_RDIST (calculate radial distance) CMO (mesh object operations) COLORMAP (build adjacency map) COMPUTE (compute a new mesh attribute value) CONNECT (connect points into tetrahedral mesh) COORDSYS (change coordinate system) COPYPTS (copy points into mesh object) CREATEPTS (create point distribution) CREATE_GRAPH (create adjacency graph) CRUSH_THIN_TETS (reduce number of thin tets) DEFINE (assign value to variable name) DEREFINE (merge nodes away) DOPING (deprecated, see interpolate) DUMP (write output files) DUMP_RECOLOR (use adjacency map) EDIT (print some mesh info) ELMTEST (validate connectivity) ELTSET (set of elements for mesh object) EXTRACT (extract 2D from 3D) EXTRACT SURFMESH (extract boundary surface) EXTRUDE (extrude a surface) FIELD (manipulate a field attribute) FILTER (filter duplicate nodes) FINISH (end processing, EXIT) FSET (set of faces for mesh object) GENIEE (make or check element connectivity) GEOMETRY (name geometry for mesh object) GRID2GRID (convert elements) HELP (print global variable) HEXTOTET (convert elements, see grid2grid) INFILE (read commands from a file, also input) INPUT (read commands from a file, also infile) INTERSECT (intersect 2D meshes to get line) INTERSECT_ELEMENTS (intersect meshes) INTERPOLATE(values from nodes or elements) KDTREE (represent mesh as kd-tree) LOG (turn log file off and on) LOOP (execute command multiple times) LOWER_D (create lower dimension structures) MASSAGE(optimize the grid) MASSAGE2 (optimize based on gradient field) MATH (math operations on attributes) MEMORY (query state of memory) MERGE (remove nodes) METIS (graph partition algorithms) MODE (set modes) MREGION (define material region for mesh object) NEGATIVE_AIJ (test bndry for neg. coef.) OFFSETSURF (offset a triangulated surface) PERTURB (perturb node locations) PSET (set of nodes for mesh object) PSTATUS (operate on point set) QUADXY (define a logical X,Y node set) QUADXYZ (define a logical X,Y,Z node set) QUALITY (report mesh quality values) RADAPT (adaptive smoothing) RANKVOLUME(list small volume elements) READ (read input file) RECON (swap edges/faces) REFINE (refine elements, edges) REFINE2D (refine a triangle) REGION (define a geometric region) REGNPTS (distributes nodes in region) REORDER (reorder nodes in a mesh) RESETPTS (reset node type values) RM (remove nodes in area) RMMAT (remove a material) RMPOINT (remove nodes or elements) RMREGION (remove a geometric region) RMSPHERE (remove nodes in a sphere) RMSURF (remove nodes in or on a surface) ROTATELN (rotate nodes about a line) ROTATEPT  (rotate nodes about a point) RZ (deprecated, see createpts) RZAMR (deprecrated, see createpts) RZBRICK (create a brick, hex mesh) RZRAN (deprecrated, see createpts) RZS (deprecrated, see createpts) RZV (deprecrated, see createpts) SCALE (scale node coordinates) SETPTS (set node type and material) SETSIZE (set epsilon values based on space size) SETTETS (make parent-child nodes, set element material) SMOOTH (optimize with node smoothing) SORT (sort an attribute) STACK (read and merge surfaces) SURFACE (define a geometric surface) SURFPTS (make nodes on a surface) TRANS (translate node coordinates) TRIANGULATE (triangulate inside polygon) UNG2AVS (UNGenerate to AVS) UPSCALE (attributes from a fine grid to a coarse grid) ZQ (deprecrated, see cmo/setatt) Back to Top Tutorials and Examples",
    "tags": "command list all options",
    "url": "/pages/commands.html"
  },{
    "title": "CREATE_GRAPH",
    "text": "CREATE_GRAPH SYNTAX create_graph / metis / [node dual] / [nxadj] / [nadjncy] create_graph/ lagrit / dual / jtetoff / jtet ` Create a node or dual (element) adjacency graph. If node option is selected, the graph of node adjacency is created, if dual option is selected, the graph of element adjacency (dual graph) is created. For details of METIS algorithms and descriptions of the third command line argument see: See METISdocumentation for description of graph format. The default name of the attributes that are created are different depending on which option (metis or lagrit) is used. See the dump command for options to output the adjacency graph to a file. LIMITATIONS lagrit will only produce the dual adjacency graph. The only option for the name of the graph arrays are jtetoff and jtet. The present implementation is just a wrapper on the geniee command. metis will not work on a hybrid mesh. Supported element types are tri, tet, quad, hex. Note: current versions of metis are 32 bit code. See instructions in documentation of the metis command. EXAMPLES create_graph / lagrit / dual / jtetoff / jtet create_graph / metis / dual / -def- / -def- create_graph / metis / node / -def- / -def- create_graph / metis / dual / ie1 / ieadj1 create_graph / metis / node / in1 / inadj1 METIS Interface to LaGriT METIS can be freely distributed provided that: A reference to the following paper is included: “A Fast and Highly Quality Multilevel Scheme for Partitioning Irregular Graphs”. George Karypis and Vipin Kumar. SIAM Journal on Scientific Computing, Vol. 20, No. 1, pp. 359—392, 1999. The original documentation &lt;a href=\"http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf\"&gt; (download PDF file of manual) &lt;/a&gt; and copyright notice is included METIS 4.0 Copyright 2001-06, Regents of the University of Minnesota",
    "tags": "create_graph, adjacency, dual graph",
    "url": "/pages/docs/commands/create_graph.html"
  },{
    "title": "CREATEPTS",
    "text": "CREATEPTS This command adds points to a mesh object. For some special cases, it will also produce element connectivity. The createpts command is a wrapper for the deprecated rz type commands. createpts/xyz rtz rtp line Create points and distribute by coordinate type selection. No connectivity created. createpts/brick Create points in a rectangular distribution and create finite element hexahedral or quad connectivity. createpts/interp Creates points by linear interpolation between two point sets. createpts/poisson_disk Use Poisson Disk sampling to create uniform or variable spaced points inside a polygon. createpts/sphere Create points for a sphere. createpts/random Add random points within region. createpts/vector Create points in region of space spanned by input vectors. createpts/voronoi Creates element attributes xvor, yvor, and zvor. createpts/median Creates element attributes xmed, ymed, and zmed. createpts/amr Create points using octree type refinement on hexahedral mesh. Click here for demos",
    "tags": "createpts, options",
    "url": "/pages/docs/commands/createpts.html"
  },{
    "title": "CREATEPTS/INTERP",
    "text": "  CREATEPTS/INTERP This command adds points to a mesh object. It creates points by linear interpolation of coordinates between two point sets. For some cases, it produces element connectivity between the point sets. The interpolation will create projections resulting in the following valid combinations: Input Output point point line quad tri prism quad hex hybrid quad tri hybrid hex prism SYNTAX createpts/interp /npoint/i1,i2,i3/j1,j2,j3/cmo_new npoint specifies the number of points to create between the specified point sets. i1,i2,i3 specifies the point set coordinate interpolation starts FROM. j1,j2,j3 specifies the point set coordinate interpolation goes TO. mo_new  is the name of the output mesh object the result goes into. The source input mesh object is the current mesh object. i1,i2,i3 and j1,j2,j3 point sets can be defined by istart, ilast, istride or pset,get,pset_name. It is up to the user to insure that the number of nodes for both sets are equal. An Error will be reported if the set counts differ. If the 1, 0, 0 format is used the code will use: i1 = 1, i2 = nnodes/2, i3 = 1, j1 = (nnodes/2)+1, j2 = nnodes, j3 = 1 EXAMPLES createpts/line/10///-1.,0.,0.,1.,0.,0. createpts/line/10///0.,-1.,1.,0.,1.,1. createpts/ interp / 10 / 1 0 0 / 1 0 0 / cmo_pts Creates a point distribution between the two point sets created by the createpts/line commands EXAMPLE QUADS projected to HEX Create a hex mesh by linear interpolation between two quad surfaces (from bottom to top in image). It is up to the user to be sure that the ordering of the quads are as intended. The first node of first quad surface (cmo1) is interpolated to the first node of the second quad surface (cmo2) cmo create cmo1///quad quadxy 5 5/ 0. 0. 0. / 20. 0. 0./20. 20. 0. / 0. 20. 0. createpts/brick/xyz/5,5,1/1,0,0/connect cmo create cmo2///quad quadxy 5 5/ 0. 0. 10. / 20. 0. 25./20. 20. 15. / 0. 20. 35. createpts/brick/xyz/5,5,1/1,0,0/connect addmesh / merge / cmo3 / cmo1 / cmo2 cmo / select / cmo3 createpts / interp / 6 / 1 0 0 / 1 0 0 / cmo_hex Starting with cmo3 from above, this will interpolate from node 1 of cmo3 to node 49 of cmo3 and interpolate from node 2 of cmo3 to node 50 of cmo3. createpts / interp / 20 / 1 2 1 / 49 50 1 / cmo_pts DEMOS Spherical Quad to Hex Sphere to Stacked Hex Cylinder  ",
    "tags": "CREATEPTS/interp",
    "url": "/pages/docs/commands/createpts/createpts_interp.html"
  },{
    "title": "CREATEPTS / MEDIAN #",
    "text": "CREATEPTS / MEDIAN This routine creates new mesh object attributes called xmed,ymed and zmed if they do not already exist. They contain the x,y,z coordinates of the median point of each element in the mesh. These attributes have length nelements and rank scalar. The median point is defined for all supported element types. SYNTAX createpts / median EXAMPLES define/NX/3 define/NY/3 define/NZ/3 define/MINX/0.0 define/MAXX/1.0 define/MINY/0.0 define/MAXY/1.0 define/MINZ/0.0 define/MAXZ/1.0 cmo/create/cmo_quad///quad quadxy NX NY/MINX MINY 0./MAXX MINY 0./MAXX MAXY 0./MINX MAXY 0. rzbrick/xyz/NX,NY,1/1,0,0/connect cmo / select / cmo_quad createpts / median cmo/ printatt / cmo_quad / -all- / minmax",
    "tags": "",
    "url": "/pages/docs/commands/createpts/createpts_median.html"
  },{
    "title": "CREATEPTS/POISSON_DISK",
    "text": "CREATEPTS/POISSON_DISK Create a uniform or variable spaced points on/in a 2D planar polygon (convex or nonconvex) using Poisson Disk sampling. Optionally connect the vertices using Delaunay triangulation. This poisson_disk command is available for LaGriT versions V3.3.3 or greater. The 3D option for poisson_disk is under development and will be available in a future release. SYNTAX createpts /poisson_disk / [2d_polygon | 3d_box] / mo_out / mo_polygon / h_spacing_scalar / [connect | no_connect] / [user_resolution.mlgi] / [ poisson_seed integer ] [ number_of_samples integer ] [ resample_sweeps integer ] Argument 3. Geometry Options 2d_polygon character type indicating geometry for a 2D planar polygon, convex or nonconvex, in the XY plane. If the polygon you wish to distribute points in is not in XY plane, user must rotate it into XY plane.If the polygon is nonconvex, the algorithm may alter some small features depending on the details of the polygon and the user controlled input parameters. See examples below. 3d_box character type indicating geometry for 3D orthogonal box defined by (x,y,z) minimum and (x,y,z) maximum. (Under Development) Argument 4. and 5. Mesh Object Names mo_out name of output mesh object. This user defined mesh object will contain the vertex distribution or triangulation created by the poisson_disk algorithm. mo_polygon name of input mesh object that contains a 2D planar polygon in the XY plane. Argument 6. Spacing h_spacing_scalar of type real. In the case of uniform resolution, this user provided real number defines the target spacing between vertices created by the Poisson-Disk algorithm. If the mesh is connected, the triangle edges will be approximately equal to h_spacing_scalar. In the case of variable resolution, h_spacing_scalar is used as a multiplier in the function defined in user_resolution.mlgi. Argument 7. Output Options connect will connect the vertices generated by Poisson disk algorithm connected. The output mesh object mo_out will be a Delaunay triangulation. no_connect the output mesh object mo_out will contain the vertices generated by Poisson disk algorithm without triangle connectivity. Optional Resolution Arguments Default if this option is not used, the mesh will be uniform resolution defined by Argument 6 h_spacing_scalar. user_resolution.mlgi is the name of a LaGriT control file for user defined resolution. The control file defines a function h(x,y) that will be used to control vertex spacing in a variable resolution mesh. See examples below. When the variable option is utilized, internal to the module a mesh object, ** mo_poi_h_field, with a real scalar attribute, **h_field_att, is created. By default for uniform resolution, h_field_att, is set to a constant value of h_spacing_scalar, however, when this option is exercised, the user must fill h_field_att with their own scalar field h(x,y). In addition, internal to the code the command: define / POI_H_FACTOR / h_spacing_scalar so one can access the value of h_spacing_scalar by using the variable POI_H_FACTOR in the LaGriT control file user_resolution.mlgi for setting variable resolution. Advanced Options There are three optional parameters that are for advanced users only. They are keyword driven and can come in any order beginning as token 8 or 9. The user can specify none, one, two, or all three keyword driven parameters. poisson_seed* (integer default 1) is the seed for the random number generator. If once runs this module with the same input, by default each run will give the same result. However, if the user would like to produce multiple realizations with the same input (same input polygon, same resolution, etc.) but a different output mesh, then the user can change the value of poisson_seed for each realization. number_of_samples (integer default:10) Number of new candidate points that are sampled around an accepted node. Lower values reduce overall sampling time, but can lead to holes in the final point distribution. Higher value lead to better density and converge but takes more time. resample_sweeps (integer default:1) Number of additional sampling attempts in the domain. If there exists holes in the point distribution, increasing this value should fill in these holes. It is suggested that the user should have the minimum value of h(x,y)= h_spacing_scalar, and then vary resolution by setting values greater than h_spacing_scalar. If one intends to have high resolution near objects and features and lower resolution away from the objects, then use of the compute/distance_field is a good way to define h(x,y). Advanced Option Examples createpts / poisson_disk / 2d_polygon / mo_poisson_pts / mo_polygon &amp; / 0.01 / connect / user_h_field_att.mlgi &amp; poisson_seed 3 / resample_sweeps 4 / number_of_samples 20 createpts / poisson_disk / 2d_polygon / mo_poisson_pts / mo_polygon &amp; / 0.01 / connect / user_h_field_att.mlgi &amp; poisson_seed 3 createpts / poisson_disk / 2d_polygon / mo_poisson_pts / mo_polygon &amp; / 0.01 / connect / poisson_seed 3 EXAMPLES for Uniform and User Defined Resolutions Polygon input file: unit_square.poly 4 0 0 0 0 1 -0.5 -0.5 0 2 0.5 -0.5 0 3 0.5 0.5 0 4 -0.5 0.5 0 LaGriT control file # # Mesh a unit square with uniform and variable resolution tringles. # # Read polygon from a file. # read / avs / unit_square.poly / mo_polygon # # Uniform resolution, unit square polygon, vertex spacing 0.05: # createpts / poisson_disk / 2d_polygon / mo_poisson_pts / mo_polygon &amp; / 0.05 / connect dump / avs / output01_unit_square_uniform.inp / mo_poisson_pts cmo / delete / mo_poisson_pts # # Variable resolution, unit square polygon, vertex spacing 0.01: # # WIDTH_FACTOR is used in user_h_field_att.mlgi # define / WIDTH_FACTOR / 10.0 createpts / poisson_disk / 2d_polygon / mo_poisson_pts / mo_polygon &amp; / 0.01 / connect / user_h_field_att.mlgi dump / avs / output02_unit_square_var.inp / mo_poisson_pts cmo / delete / mo_poisson_pts define / WIDTH_FACTOR / 20.0 createpts / poisson_disk / 2d_polygon / mo_poisson_pts / mo_polygon &amp; / 0.01 / connect / user_h_field_att.mlgi dump / avs / output03_unit_square_var.inp / mo_poisson_pts cmo / delete / mo_poisson_pts finish Variable resolution defined in LaGriT control file: user_h_field_att.mlgi Used in the example above, the resolution is set using the X coordinate (xic), the user defined POI_H_FACTOR = h_spacing_scalar = 0.01, and a floor function to ensure no values are below h_spacing_scalar. ##################################################### # User defined h field function assignment ##################################################### # # h_field_att is already set to POI_H_FACTOR # define / MO_H_FIELD / mo_poi_h_field # # x**2 math / power / MO_H_FIELD / h_field_att / 1,0,0 / &amp; MO_H_FIELD / xic / 2.0 cmo/printatt/MO_H_FIELD/h_field_att/minmax # sqrt(x**2) math / power / MO_H_FIELD / h_field_att / 1,0,0 / &amp; MO_H_FIELD / h_field_att / 0.5 cmo / printatt/MO_H_FIELD/h_field_att/minmax # POI_H_FACTOR*sqrt(x**2) math/multiply/MO_H_FIELD/h_field_att/1,0,0/ &amp; MO_H_FIELD/h_field_att/ POI_H_FACTOR math/multiply/MO_H_FIELD/h_field_att/1,0,0/ &amp; MO_H_FIELD/h_field_att/ WIDTH_FACTOR cmo / printatt/MO_H_FIELD/h_field_att/minmax math / floor / MO_H_FIELD/h_field_att/1,0,0/ &amp; MO_H_FIELD/h_field_att/POI_H_FACTOR cmo/printatt/MO_H_FIELD/h_field_att/minmax cmo / status / brief # # As a diagnostic one can output MO_H_FIELD and view # the h(x,y) attribute that will be used to set resolution. # dump / avs / h_field_out.inp / MO_H_FIELD # finish  ",
    "tags": "createpts poisson_disk",
    "url": "/pages/docs/commands/createpts/createpts_poisson.html"
  },{
    "title": "CREATEPTS / VORONOI #",
    "text": "CREATEPTS / VORONOI This routine creates new mesh object attributes called xvor, yvor, and zvor if they do not already exist. They contain the x,y,z coordinates of the voronoi point of each element in the mesh.  These attributes have length nelements and rank scalar.  The voronoi point is defined only for triangular and tetrahedral meshes. SYNTAX createpts / voronoi EXAMPLES define/NX/3 define/NY/3 define/NZ/3 define/MINX/0.0 define/MAXX/1.0 define/MINY/0.0 define/MAXY/1.0 define/MINZ/0.0 define/MAXZ/1.0 cmo/create/cmo_hex ///hex createpts/brick/xyz/NX,NY,NZ/MINX,MINY,MINZ/MAXX,MAXY,MAXZ/1,1,1 hextotet / 6 / cmo_tet / cmo_hex cmo / select / cmo_tet createpts / voronoi cmo/ printatt / cmo_tet / -all- / minmax",
    "tags": "",
    "url": "/pages/docs/commands/createpts/createpts_voronoi.html"
  },{
    "title": "CREATEPTS/SPHERE",
    "text": "CREATEPTS/SPHERE Builds a sphere by generating coordinates of points and also modifies zoning by ratio-zoning point distributions. See the rz command for more details. Use connect to generate tet or triangle connectivity for all types except option 8 which generates the hex connectivity. SYNTAX createpts /sphere / itype / nr,npt,xirad,xorad / xcen,ycen,zcen / iz / irat,rz Types for sphere itype: 1 generates a sphere by gridding the faces of a cube and then projecting the vertices onto a sphere. The number of nodes per shell is of the form 6*i**2. 2 generates a sphere by subdividing an icosahedron placed on the surface of a sphere. Icosahedral gridding is made up of 10 diamonds per shell. Each diamond is made up of n**2 nodes (where n must be of the form 2**i+1). There are 2 nodes (the poles of the sphere) at which 5 diamonds meet and 10 nodes where 3 diamonds meet; hence there are a minimum of 12 nodes per shell. The number of nodes per shell can be 12, 42, 162, 642,…etc. 8 generates a hexahedral icosahedron grid. This option distributes points and generates the grid connectivity data structures. This option does not require a connect command. diamond generates the points for one diamond of the icosahedron. Options: nr is the number of radial shells npt is the upper limit of the number of points in a shell, the number of points generated will be less than or equal to this number. xirad , xorad are the inner and outer radii of the sphere. For itype =8 reverse inner and outer radii. xcen, ycen, zcen are the coordinates of the center of the sphere iz  if =0 then mins and maxs are used as cell centers, if =1 then mins and maxs are used as cell vertices irat is ratio zoning switch (0=off,1=on) rz is ratio zoning value - distance is multiplied by the value for each subsequent point. EXAMPLES createpts/sphere/8/5/162/1.0,0.5/0.,0.,0./1,0,0.0/ createpts/sphere/2/5/162/0.5,1.0/0.,0.,0./1,0,0.0/ createpts/sphere/diamond/5/162/1,.5/0,0,0/1,0,0/ Various spherical point distributions. cmo / create / motet_sph createpts/sphere/1/5/162/1.0,0.5/0.,0.,0./1,0,0.0/ cmo / setatt / motet_sph / imt / 1 0 0 / 1 filter / 1 0 0 rmpoint / compress connect Projected cube onto a sphere connected into tets (Image clipped at half) Number of nodes = 750 Number of elements = 4175 cmo / create / motet_sph createpts/sphere/2/5/162/1.0,0.5/0.,0.,0./1,0,0.0/ cmo / setatt / motet_sph / imt / 1 0 0 / 1 filter / 1 0 0 rmpoint / compress connect Icosohedron tet sphere connected into tets (Image clipped at half) Number of nodes = 812 Number of elements = 4187  ",
    "tags": "createpts sphere",
    "url": "/pages/docs/commands/createpts/cresphere.html"
  },{
    "title": "crush_thin_tets",
    "text": "CRUSH_THIN_TETS This algorithm can be used to reduce sliver shaped tetrahedrals from a mesh. SYNTAX crush_thin_tets/ cmo_name / [ TOLCRUSH ] / [pset,get,psetname] cmo_name is the mesh object name. TOLCRUSH is the optional value providing a measurement selection to crush, the default value is .1 pset,get, psetname is the optional node selection for part of the mesh. DESCRIPTION crush_thin_tets loops thru tets of a volume mesh and looks for elements that, relative to the characteristic length established by the normalized root mean square length of the edges, are thinner than TOLCRUSH. In the case that thinness is defined as the minimum tet altitude, then this relative length is actually an aspect ratio, because it goes to zero if the tet is degenerate and has a maximal value of 1 for a regular tet. Given the relative length scale, we can measure thinness not just of the altitudes, but of any distance measurement in the tet. In particular there are four type of thin situations possible for a bad tet and we take appropriate actions for each case: 1) If an element has relative edge length shorter than TOLCRUSH, it is merged. 2) If a normal point-to-edge projection has relative length &lt; TOLCRUSH, a node is added to the edge, so that a type (1) merge can take place. 3) If a normal point-to-face projection has relative length &lt; TOLCRUSH, a node is added to the face, so that a type (1) merge can take place. 4) If a normal mutual diagonal-to-diagonal projection has relative length &lt; TOLCRUSH, a node is added to one diagonal, so that a type (2) situation is created (which leads to another refinement and a type (1) merge). Since there are situations when a type (1) action would be barely rejected on tolerance, but the more complicated type (2) action would be barely accepted on tolerance, we loosen the tolerance slightly for type (1) actions relative to type (2) actions to avoid this. Similarly, there are situations when a type (2) action would be barely rejected on tolerance, but the more complicated type (3) or type (4) actions would be barely accepted on tolerance. To avoid this we loosen the tolerance of type (2) actions relative to type (3) and type(4) actions. Currently we are using these effective tolerances (on relative length): type 1 : 1.2*TOLCRUSH type 2 : 1.1*TOLCRUSH type 3 : TOLCRUSH type 4 : TOLCRUSH EXAMPLES The LaGriT input is an AVS format file with a thin tet number 1 with aspect ratio of .149 making it a sliver. 6 5 0 0 0 1 0. -1. .05 2 1. 0. -.05 3 0. 1. .05 4 -1. 0. -.05 5 0. 0. -2. 6 0. 0. 2. 1 1 tet 1 4 2 3 2 2 tet 1 2 4 5 3 3 tet 1 4 3 6 4 4 tet 2 3 4 5 4 5 tet 2 1 3 6 This example calls crush_thin_tets twice, once with TOLCRUSH= .1 and again with TOLCRUSH .15, a value larger than the known aspect ratio of .149. As a result, nothing will happen on the first call. The second call will find and crush the sliver by splitting elements and merging edges to create a new mesh without the sliver. crush_thin_tets / cmotet / .1 rmpoint/compress resetpts itp crush_thin_tets / cmotet / .15 rmpoint/compress resetpts itp The first call has no change to the input. The second call splits tets such that thin tet is eliminated. Images show the input tet cell numbers and node numbers (left), the input tet elements exploded for viewing (middle), the output from crush_thin_tets with exploded view (right).             input tet id numbers input tets exploded output tets exploded",
    "tags": "crush_thin_tets, tet",
    "url": "/pages/docs/commands/crush_thin_tets.html"
  },{
    "title": "*arguments:",
    "text": "Example 2: addmesh / amr The objective is to join two meshes to create a third using the addmesh / amr command. Two cubes, one smaller than the other, each having a different grid resolution are combined. The amr option finds the intersection and refines one mesh to interface with the boundary of the other mesh using adaptive mesh refinement. Input      lagrit_input_amr   Output Images +———————–+———————–+———————–+ [mesh [mesh [](image/addmesh_amr/ 1](image/addmesh_amr/ 2](image/addmesh_amr/ addmesh_amr3.gif”[com addmesh_amr1.gif”[![] addmesh_amr2.gif”[![] bined (image/addmesh_amr/ad (image/addmesh_amr/ad (view dmesh_amr1_tn.gif”{wi dmesh_amr2_tn.gif”{wi 1)](image/addmesh_amr dth=”” dth=”” /addmesh_amr3.gif”![] “”](image/a “”](image/a (image/addmesh_amr/ad ddmesh_amr/addmesh_am ddmesh_amr/addmesh_am dmesh_amr3_tn.gif”{wi r1.gif” r2.gif” dth=”” “” +———————–+———————–+———————–+ [](image/addmesh_amr/ [](image/addmesh_amr/ addmesh_amr4.gif”[com addmesh_amr5.gif”com bined bined (view (view 2)](image/addmesh_amr /addmesh_amr4.gif”[![ /addmesh_amr5.gif”[![ ](image/addmesh_amr/a ](image/addmesh_amr/a ddmesh_amr4_tn.gif”{w ddmesh_amr5_tn.gif”{w idth=”” idth=”” “”](image/a “”](image/a ddmesh_amr/addmesh_am ddmesh_amr/addmesh_am r4.gif” r5.gif” +———————–+———————–+———————–+",
    "tags": "",
    "url": "/pages/docs/demos/description2_amr.html"
  },{
    "title": "Example 2: createpts in a cylindrical geometry",
    "text": "Example 2: createpts in a cylindrical geometry The objective is to add points to a cylindrical mesh using the createpts command. A cylindrical geometry is defined. The createpts/rtz command is used to create a point distribution within the geometry exercising various options available to the command. The output consists of one gmv file. Input lagrit_input_creatertz Output Image",
    "tags": "",
    "url": "/pages/docs/demos/description2_rtz.html"
  },{
    "title": "Example 3: addmesh/append",
    "text": "Example 3: addmesh/append The objective is to join two meshes to create a third using the addmesh / append command. Two cubes, one smaller than the other, each having a different grid resolution are combined. The append option concatenates two meshes where imt, icr, and itetclr of mesh2 are given the values max(imt(mesh1)). Input      lagrit_input_append Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description3_append.html"
  },{
    "title": "Example 3: creatpts in a spherical geometry",
    "text": "Example 3: creatpts in a spherical geometry The objective is to add points to a spherical mesh using the createpts command. A spherical geometry is defined. The createpts/rtp command is used to create a point distribution within the sphere. The output consists of one gmv file. Input      lagrit_input_creatertp Image of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description3_rtp.html"
  },{
    "title": "Example 4: creatpts in a rectangular geometry that includes a material interface",
    "text": "Example 4: creatpts in a rectangular geometry that includes a material interface The objective is to create  a rectangular mesh using the createpts/brick command. A rectangular geometry is defined that contains a cut-plane defining the boundary between two materials. The createpts/brick command is used to create a point distribution within the geometry and a nearest neighbor connectivity list. The output consists of one gmv file. Input      lagrit_input_createbrick Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description4_brick.html"
  },{
    "title": "Example 4: addmesh / delete",
    "text": "Example 4: addmesh / delete The objective is to create a mesh using the addmesh/delete command by deleting one mesh from another. Two cubes, one smaller than the other, each having a different grid resolution are combined. The delete option finds the elements of mesh1 that intersect mesh2 and removes them from mesh1, creating the resultant mesh (mesh3). Input      lagrit_input_delete Images of GMV output  ",
    "tags": "",
    "url": "/pages/docs/demos/description4_delete.html"
  },{
    "title": "Example 5: addmesh / intersect",
    "text": "Example 5: addmesh / intersect The objective is to create a point set that are the nodes in mesh1 that intersect elements of mesh2. Two cubes defined by mesh1 and mesh2 are read. The perimeter of mesh2 lies within that of mesh1. The addmesh / intersect command is used to determine the nodes in mesh1 that intersect elements of mesh2. Input      lagrit_input_inter Images of GMV output IMAGES_TODO",
    "tags": "",
    "url": "/pages/docs/demos/description5_intersect.html"
  },{
    "title": "Example 5: createpts in a spherical geometry using shells as region boundaries",
    "text": "Example 5: createpts in a spherical geometry using shells as region boundaries The objective is to create a spherical mesh using the createpts/sphere command. A spherical geometry is defined containing three regions, each defined as the region between two spherical shells. The createpts/sphere/diamond command is used to create a point distribution between spherical shells for one diamond of the defining icosahedron. The output consists of one gmv file. Input lagrit_input_createsphere Image of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description5_sphere.html"
  },{
    "title": "Example 6: addmesh / match",
    "text": "Example 6: addmesh / match The objective is to join two meshes to create a third using the addmesh/match command. Two rectangular meshes are combined. The match option concatenates two meshes but allows the second to be translated, rotated, and scaled. Input lagrit_input_match Images of GMV output  ",
    "tags": "",
    "url": "/pages/docs/demos/description6_match.html"
  },{
    "title": "Example 6: creatpts in a spherical geometry using shells as region boundaries",
    "text": "Example 6: creatpts in a spherical geometry using shells as region boundaries The objective is to create a spherical mesh using the createpts/sphere command. A spherical geometry is defined containing three regions, each defined as the region between two spherical shells. The createpts/sphere/itype=2 command is used to create a point distribution between spherical shells for all diamonds of the defining icosahedron. The output consists of one gmv file. Input      lagrit_input_createshere2 Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description6_sphereB.html"
  },{
    "title": "Example 7: creatpts in a logically rectangular geometry",
    "text": "Example 7: creatpts in a logically rectangular geometry The objective is to create a brick mesh using the createpts/brick command. A logically rectangular geometry is defined. The createpts/brick command is used to create a point distribution and mesh connectivity list. The output consists of one gmv file. Input      lagrit_input_createbrick2 Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description7_brickB.html"
  },{
    "title": "*arguments:",
    "text": "Example 7: addmesh/merge The objective is to join two meshes using the addmesh/mergecommand. Two rectangular meshes are read and combined. The merge command concatenates the meshes. Input      lagrit_input_merge   Images of GMV output ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------- [ &lt;img width=\"300\" src=\"https://lanl.github.io/LaGriT/assets/images/addmesh_merge/addmesh_mesh1_tn.gif\"](image/addmesh_merge/addmesh_mesh1.gif\" [Input1](image/addmesh_merge/addmesh_mesh1.gif\" [ &lt;img width=\"300\" src=\"https://lanl.github.io/LaGriT/assets/images/addmesh_merge/addmesh_mesh2_tn.gif\"](image/addmesh_merge/addmesh_mesh2.gif\" [Input2](image/addmesh_merge/addmesh_mesh2.gif\" [ &lt;img width=\"300\" src=\"https://lanl.github.io/LaGriT/assets/images/addmesh_merge/addmesh_mesh3_tn.gif\"](image/addmesh_merge/addmesh_mesh3.gif\" [Merged](image/addmesh_merge/addmesh_mesh3.gif\" ----------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------",
    "tags": "",
    "url": "/pages/docs/demos/description7_merge.html"
  },{
    "title": "Example 8: creatpts in a spherical geometry using shells as region boundaries",
    "text": "Example 8: creatpts in a spherical geometry using shells as region boundaries The objective is to create a spherical mesh using the createpts/sphere command. A spherical geometry is defined containing three regions, each defined as the region between two spherical shells. The createpts/sphere/itype=2 command is used to create a point distribution between spherical shells for all diamonds of the defining icosahedron. The output consists of one gmv file. Input      lagrit_input_createsphere3 Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description8_sphereC.html"
  },{
    "title": "Example 9: random distribution of points in a box",
    "text": "Example 9: random distribution of points in a box The objective is to create a point distribution within a rectangular region using the createpts/random/xyz command. First a rectangular geometry is created by specifying the region inside a cube. The createpts/random/xyz command is then used to create a point distribution with a specified target spacing. The output consists of one gmv file. Input      lagrit_input_createrandom Image of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description9_random.html"
  },{
    "title": "Example 1: dump files in various formats",
    "text": "Example 1: dump files in various formats The objective is to dump a simple geometric object into avs, fehm, LaGriT, and gmv formats. The output consists of one gmv file, one avs file, one LaGriT file, and seven fehm related files. Input lagrit_input_dump Images of GMV input (the output consists of several file formats including binary)",
    "tags": "",
    "url": "/pages/docs/demos/description_dump.html"
  },{
    "title": "Example 1: define various point sets within a geometry",
    "text": "Example 1: define various point sets within a geometry The objective is to take a geometry with multiple materials and define various point sets using pset. The output consists of one gmv file, but the main effect is found by inspection of the output file. Input lagrit_input_pset Images of GMV input and output Output log file Input geometry",
    "tags": "",
    "url": "/pages/docs/demos/description_pset.html"
  },{
    "title": "Example 1: Check quality of various meshes",
    "text": "Example 1: Check quality of various meshes The objective is to use the quality command to interogate various mesh properties. There are three meshes tested in this example. The output consists of the result of the command output, placed into the output log file. Input     Output output_qual1 output_qual1skew output_qual2",
    "tags": "",
    "url": "/pages/docs/demos/description_qual.html"
  },{
    "title": "Example 1: test using regnpts to create point distributions and meshes.",
    "text": "Example 1: test using regnpts to create point distributions and meshes. The objective is to use the regnpts command to create point distributions within a geometry, and subsequently create a mesh. The output consists of one gmv file. Input lagrit_input_regnpts Images of GMV input and output Outer region and inner region edges and nodes Inner region surface and outer region nodes",
    "tags": "",
    "url": "/pages/docs/demos/description_regnpts.html"
  },{
    "title": "Example rotatept",
    "text": "Example ROTATEPT The objective is to use the rotatept command to modify a point distribution by rotation. The output consists of three gmv files, one showing the original point distribution, one showing a rotation in the xy-plane, and one showing a rotation away from the z-axis, each using rotatept/rtz. LaGriT Input Command File lagrit_input_rotatept Initial point distribution cmo/create/abc/tet createpts/rtz/9,5,2/0.,0.,0./10.,360.,2./1,1,1/ pset/rays/seq/1,0,0 zq/xic/pset,get,rays rotation in xy-plane about z-axis rotatept/pset,get,rays/nocopy/0.,0.,0./0./30. rotation in xy-plane and away from z-axis rotatept/pset,get,rays/nocopy/0.,0.,0./15./00.",
    "tags": "example rotatept",
    "url": "/pages/docs/demos/description_rotatept.html"
  },{
    "title": "Example 1: test using trans to modify two point distributions.",
    "text": "Example 1: test using trans to modify two point distributions. The objective is to use the trans command to translate a point distribution. The output consists of two gmv files, one showing the original point distributions, one showing the distributions after translation. lagrit_input_trans Images of GMV input and output Initial point distribution translation along z-axis",
    "tags": "",
    "url": "/pages/docs/demos/description_trans.html"
  },{
    "title": "",
    "text": "  6. Distribute points within the volume There are many methods of distributing points within a volume.  For simple geometries refer to the createpts command.  This example uses the regnpts command which, although more complicated, provides greate flexibility.  Points are distributed within regions using Cartesian, cylindrical or spherical coordinates by constructing rays that travel through regions and distributing points along these rays. For this example, points are distributed using Cartesian coordinates. The rays are specified by defining a set of points and a plane. For each point in the set, a ray is constructed normal to the plane passing through the point. In general rays are constructed in sets, each set is specified by a single plane and a set of points. The createpts command is used to create the points. Theregnpts command is used to specify the plane, to specify the region, and to specify the number of points to be distributed along the rays. The points and the plane should lie outside the enclosing volume and on opposite sides. The normal to the plane should point toward the point. As rays are created, if they do not pass through the specified region, no points are distributed. Points may be spaced evenly along the ray or they may be spaced according to a ratio. The following commands will place points in the unit cube.   create 25 points (5x5x1) in a plane above the unit cube place points on the boundaries in the x and y directions (1,1,0) createpts /xyz/5,5,1/0.,0.,1.1/1.,1.,1.1/1,1,0 give the points defined by the createpts command the name, rayend pset/rayend/seq/1,0,0/ “283” “208” create rays between points in rayend and the plane below the cube distribute 3 points along these rays in the region top add one point at the upper external boundary for each ray will get 4 points total along each ray in region top “pset,get,rayend” refers to all the points named rayend the three points: (0.,0.,-.1), (0.,1.,-.1), (1.,1.,-.1) define a plane whose normal points toward the rayend points regnpts/top/3/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/0,0 “342” “270” distribute 4 points along these rays in the region bottom add one point at the lower external boundary for each ray add one point at the material interface for each ray since bottom contains the interface - a total of 6 points for each ray. points will be distributed such that the ratio of distances between any two consecutive pairs of points is 0.6, traveling from the source of the ray (the plane) to the ray end. regnpts/bottom/4/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/1,.6 “347” “308” Other versions of the regnpts are appropriate for cylindrical and spherical geometries. For cylindrical geometries the createpts command specifies points in a cylindrical shell outside the volume. The regnpts command specifies a line (usually the cylinder axis), and the rays are constructed normal to this line and containing one of the createpts points. For spherical geometries the createpts command specifies points in a spherical shell outside the volume. The regnpts command specifies a point (usually the center of the sphere) from which rays are constructed to the createpts points.",
    "tags": "",
    "url": "/pages/docs/distributep.html"
  },{
    "title": "EDGE REFINEMENT",
    "text": "I. Edges Each edge is tested separately to see if it should be tagged for refinement or derefinement. Definition: c = a user supplied tolerance f(i) = value of the field variable f at node i L = length of the edge For the edge between nodes 1 and 2, we have Criteria: 1) Junction: Refine if the edge field values straddle c. Tag for refinement if f(1) &gt; c and f(2) &lt; c or f(1) &lt; c and f(2) &gt; c example: For c = 0, refine if f changes sign across the edge. 2) Constant: Refine if the edgeís field values exceed c. Tag for refinement if f(1) &gt; c or f(2) &gt; c 3) Maxsize: Refine if the edge length exceeds c. Tag if l &gt; c 4) Delta: Refine if the magnitude of the difference of the field values at the edge ends exceeds c. Tag if f(1) - f(2) &gt; c 5) Lambda Refine: Refine if lambda/dx &lt; c. Where dx is a scale length (here taken to be the edge length). Generally lambda/dx is a quality measure of the discretization. A larger value of usually indicates a better grid discretization. There are some special cases. If one of the field values is zero as could happen on a boundary, then lambda/dx 1/2. If f(1) is equal to f(2) then lambda/dx is divergent but the algorithm uses a small number e = .000001 added to the denominator lambda/dx to give a large but finite value of lambda/dx thus indicating a good discretization.",
    "tags": "refine edges",
    "url": "/pages/docs/edges.html"
  },{
    "title": "ELMTEST",
    "text": "  ELMTEST This command test a mesh for valid jtet connectivity.  If the mesh is a network it allows for jtet loops; in this case the jtet relationship is not reflexive but, for example if the loop has length 3. Normally degenerate faces may not have neighbors with a different number of nodes; however, if  a scalar mesh attribute ‘jtet_reduce_nnd’ is defined and has the value 1, faces will match if the node numbers are the same even if a node number appears more that once. SYNTAX elmtest /[nwrite] nwrite is the number of warning messages to print.  The default for nwrite is 20. EXAMPLES: elmtest elmtest//100",
    "tags": "elmtest, jtet, connectivity",
    "url": "/pages/docs/commands/elmtest.html"
  },{
    "title": "",
    "text": " “30” “30”](mstkla.md#EXAMPLE) “30” “30”](utilities.md) “30” “30”](linking.md) / * ========================================================================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #   Example program with MSTKLA # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ========================================================================== * #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include “mstkla.h” #include “gmtkla.h” int main(int argc, char *argv[]) {   char *meshname;   PMeshObj mesh;   PMeshVert vert, rverts[8];   PMeshRegn reg, oreg;   ElType type;   int nv, nf, nr, nrv, i, j, *rfside, nrf, ngr, ngf;   double xyz[3];   PGeomEntity gent;   PGeomFace *rflist, *gflist;   PGeomRegn *grlist;     ***/ Initialization **/     MSTKLA_Init();   GMTKLA_Init();     ***/ Create a mesh object and fill in the data after reading from a file **/   mesh = MESH_Create();   MESH_InitFromFile(mesh, argv[1], argv[2], 1, &amp;meshname);     ***/ Model info **/     ngr = GM_NumRegions();   fprintf(stderr,”Number of model regions: %d n”,ngr);     ngf = GM_NumFaces();   fprintf(stderr,”Number of model faces: %d n”,ngf);     ***/ Get all the regions in the model **/   GM_Regions(&amp;ngr, &amp;grlist);     ***/ Loop through the regions and print out info about the faces***      bounding this region **     **/*     for (i = 0; i &lt; ngr; i++) {     fprintf(stderr,”Region %-d n: n”,(i+1));       ***/ Faces of the region **/       GR_Faces(grlist[i],&amp;nrf,&amp;rflist,&amp;rfside);       fprintf(stderr,”  %d Faces n”,nrf);     for (j = 0; j &lt; nrf; j++) {       fprintf(stderr,”Face %-d  Dir %-d Type %-d n”,        GF_Number(rflist[j]),rfside[j],GF_Type(rflist[j]));         for (i = 0; i &lt; ngr; i++)     GR_Delete(grlist[i]);   free(grlist);   */ Just get the all the faces of the model **/ ***  / Delete the objects containing that info - the surfaces themselves***      don’t get deleted **     **/*   GM_Faces(&amp;ngf, &amp;gflist);   for (i = 0; i &lt; ngf; i++)     GF_Delete(gflist[i]);   free(gflist);     ***/ Mesh Info **/   fprintf(stderr,”Number of nodes in mesh: t%d n”,MESH_NumVertices(mesh));   fprintf(stderr,”Number of elements in mesh: t%d n”,MESH_NumRegions(mesh));   ***/ Loop through each mesh vertex and print some info about it **/   nv = MESH_NumVertices(mesh);   for (i = 0; i &lt; nv; i++) {     vert = MESH_Vertex(mesh,i);     if (MV_Type(mesh,vert) == VDELETED MV_Type(mesh,vert) == VIGNORE)       continue;     ***/ Get the classification (model entity that mesh entity is on) of***        the mesh vertex **       **/*     gent = MV_GMentity(mesh,vert);     ***/ Get the coordinates of the mesh vertex **/     MV_Coords(mesh, vert, xyz);     if (gent)       fprintf(stderr,”V%-d [ G%-d (order %1d) —  %lf %lf %lf n”,        MV_Number(mesh,vert),GEnt_Number(gent), MV_GMtype(mesh,vert),        xyz[0],xyz[1],xyz[2]);     else       fprintf(stderr,”V%-d [ G (order %1d) —  %lf %lf %lf n”,        MV_Number(mesh,vert),MV_GMtype(mesh,vert),        xyz[0],xyz[1],xyz[2]);     fprintf(stderr,” n n”);   nr = MESH_NumRegions(mesh);   ***/ Loop through each mesh regions and print some info about it **/   for (i = 0; i &lt; nr; i++) {     reg = MESH_Region(mesh,i);     ***/ Region type - TET, PYRAMID, PRISM, HEX? **/     type = MR_Type(mesh,reg);       ***/ Vertices of region aka nodes of element **/     MR_Vertices(mesh, reg, &amp;nrv, (PMeshVert *) rverts);       ***/ Classification of mesh region i.e. what model region it is in **/     gent = MR_GMentity(mesh,reg);     if (GEnt_Type(gent) != GREGION)       fprintf(stderr,”Mesh Region not classified on model region??? n”);       fprintf(stderr,”R%-d [ G%-d — “, MR_Number(mesh,reg), GEnt_Number(gent));     for (j = 0; j &lt; nrv; j++)       fprintf(stderr,”%d  “, MV_Number(mesh,rverts[j]));     fprintf(stderr,” n”);       ***/ Loop through the regions of the mesh and print the face neighbor info **/   for (i = 0; i &lt; nr; i++) {     reg = MESH_Region(mesh,i);     fprintf(stderr,”Region %-d neighbors: “, MR_Number(mesh,reg));     type = MR_Type(mesh,reg);     nf = RType_NumFaces(type);     for (j = 0; j &lt; nf; j++) {       ***/ Find the other region sharing face ‘j’ of ‘reg’ **/       oreg = MR_FaceNebr(mesh,reg,j);       if (oreg) { ***/ a region exists on the other side of face, print info **/          fprintf(stderr,”R%-d “,MR_Number(mesh,oreg));               fprintf(stderr,” n”);          “30” “30”](mstkla.md#EXAMPLE) “30” “30”](utilities.md) “30” “30”](linking.md)",
    "tags": "",
    "url": "/pages/mstkla/example.html"
  },{
    "title": "DEMO Write Face and Node Sets",
    "text": "DEMO Write Face and Node Sets This example shows how extract/surfmesh can be used to write boundary face and node information. This is the method used to add facesets (side sets) that are added to an ExodusII mesh file. This information can also be read and parsed for used for modeling application for boundary conditions in FEHM and PFLOTRAN. Note it is very important that you use the master source mesh to extract node and element numbers. If you subset or change the master mesh, the node and element numbers might change and your face and node list will not be valid. This Demo shows how to Create the tet mesh with 2 materials (one interface). See CREATEPTS/BRICK. Write the mesh node sets as an FEHM zone file or as an AVS format file. See PSET WRITE and ZONE. Create a surface mesh consisting of faces on the boundary and interface. See EXTRACT_SURFMESH. Write the mesh face and node information to files that can be used define boundary conditions. See DUMP EXO and DUMP AVS. Images for this Demo Click on images to enlarge. Master Tet Mesh Extracted Surfmesh Colored Surfmesh Create hex mesh with 2 materials and one interface. Set mesh object itp array to tag boundary and interface nodes. Extract surface representing faces on the boundary and the interface. Surfmesh itetclr0 is used to select the interface. Color the surfmesh with desired subsets, interface (blue) and top (green). Output Face Sets Output Node Sets Output face sets for top and interface Output nodes for top and interface (node numbers shown in image) LaGriT Command Files for Demo LaGriT command file for Demo: write_face_node_sets.lgi.txt LaGriT output report for Demo: write_face_node_sets.out.txt Demo Output Files This Demo will write the following files: top_nodes.zonn and inter_nodes.zonn list of nodes at top and interface of master mesh FEHM zonn format. top_nodes.vertexset and inter.vertexset list of nodes at top and interface of master mesh in pset format. top_nodes.dat and interface_nodes.dat master node attribute values for subset node id to master in AVS node attribute format. top.faceset and interface.faceset extract/surfmesh attributes with master element id to surface face id, readable for ExodusII files. mesh_facesets.exo master mesh with facesets (side sets) viewable with Paraview and GMV mesh_facesets.gmv master mesh with facesets (surfaces) viewable with GMV head ZONN file top_nodes.zonn: zonn 000001 TOP_NODES nnum 121 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 head PSET file top_nodes.vertexset: pset ascii 1 TOP_NODES 1 121 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 head AVS node attribute file top_nodes.dat: 0 0 1 0 0 00001 1 id_node, integer 1 486 2 496 3 485 4 497 5 487 head AVS element attribute file top.faceset: 0 0 0 2 0 00002 1 1 idelem1, integer idface1, integer 1503 2 1504 2 1508 2 1509 2",
    "tags": "",
    "url": "/pages/docs/demos/extract_facesets.html"
  },{
    "title": "EXTRUDE",
    "text": "EXTRUDE This command takes a topologically 1d or 2d mesh (a line, a set of line segments, or a planar or non-planar quad or triangle surface) and extrudes it into three dimensions along either the normal to the curve or surface (default), along a user defined vector, or to a set of points that the user has specified. If the extrusion was along the normal of the surface or along a user defined vector, the command can optionally find the external surface of the volume created and return that to the user. SYNTAX extrude/mesh1/mesh2/const min/offset/volume bubble/[norm x1,y1,z1] extrude/mesh1/mesh2/interp/layers/range1/range2 range1 and range2 are defined as pset,get, pset_name or ifirst,ilast,istride (1,0,0 is all). mesh1 is the name of the resulting mesh. mesh2 is the name of the initial mesh. This mesh must be a valid mesh object with element type of line, tri, or quad. The mesh type hybrid is acceptable but behavior may be unpredictable. const is a keyword that indicates that the distance from each of the points in the initial mesh along the extruding vector will be equal to offset.Therefore, if you wanted the extruded mesh to have the same surface or edge characteristics as the original mesh on both the initial and newly formed surface or edge, you would use const. min is a keyword and indicates that the minimum distance along the extruding vector to a reference plane that is perpendicular to the extruding vector will be equal to offset. This means that if you want an extruded mesh with at least one flat side, you would use min. This also means that if you use min, extrude computes the “bottom point” on the initial mesh, or the point closest to the reference plane, and then extrudes that point by min, all the other points will therefore be extruded by a larger distance. This avoids the problem of having the initial mesh intersect the reference plane that forms the “bottom” of the created mesh. interp is a keyword and indicates a different kind of extrusion. Instead of giving the initial mesh a direction in which to be extruded, this keyword specifies that the initial mesh is made up of two sets of points to be connected. These point sets are defined by range1 and range2. The ranges can be defined using the standard LaGriT techniques of pset, get, pset_name or ifirst, ilast, istride. layers is the number of layers of elements that will be placed between the original two surfaces. This is a good point distribution technique. The final number of layers of points will be equal to layers+1. It must be an integer. offset is the length of extrusion. It can either be an integer or a real. volume is a keyword and indicates that the volume that was extruded is to be returned to the user (i.e., the operation will result in either a topologically 2d (quad) mesh if the initial mesh was topologically 1d, or a topologically 3d (prism or hex) mesh if the initial mesh was topologically 2d). bubble is a keyword and indicates that the external surface of the volume created will be returned. If bubble is used, hextotet will be called on the final surface, as well as extract. The final argument is optional. It must either be the keyword norm, or a three valued vector (in cartesian space) specifying a direction. The default, if no argument is provided, is norm. If norm is chosen, the element area weighted normal to the surface or curve is computed, and the initial mesh is extruded in that direction. Otherwise, if a vector value is specified, the vector is normalized, and its direction used to extrude the initial mesh. NOTES This code works on meshes containing lines, quads, triangles, or hybrid polygons. If there are lines in the initial mesh, they become quads; tris become prisms; and quads become hexes. Note that line elements will not work for the bubble option and will produce errors during the call to hextotet. If the interp keyword is used, the code expects the number of points in range1 and range2 to be equal, and to correspond such that the first point in range1 will connect to the first point in range2 in the final mesh object, etc. Other setups will result in a twisted, perhaps invalid mesh object. It is very possible to create an invalid mesh object with the extrude command, especially if the initial mesh is a multivalued surface, or if the extruding vector is in a direction parallel to the plane the initial surface is in. You have been warned. EXAMPLES extrude/cmo_hex/cmo_quad/const/5.0/volume This would result in hexes being created out of the initial quad sheet. First, since const and volume are used, the quad sheet will be extruded a constant amount from each point. Second, since the extruding vector and norm are omitted, the extrusion will occur on the average normal to the plane. Therefore, this command will result in a mesh of hexahedrons extruded 5.0 units in an orthogonal direction. (Or, more succinctly, a mesh of parallelopipeds of height 5.) extrude/cmo_prism/cmo_tri/ min/10/volume/ 1,2,-1 This command would result in prisms being created out of the initial tri sheet. First, since min is used, the “bottom” of the extruded volume would be a plane. Second, because the vector 1, 2, -1 is specified, the extrusion will be in that direction (again the magnitude is not important, the vector is normalized to a unit vector), not in the direction of the average normal. extrude/cmo_bigbox/cmo_quad/const/5.0/bubble/ This would result in a surface surrounding an amalgamation of parallelopipeds created from the initial quad sheet. First, since const is used the quads will be extruded a constant amount from each point in the quad sheet. Second, since the extruding vector and norm are omitted, the extrusion will occur on the average normal to the plane. Therefore, this command will result in a mesh of tris that form the surface of a group of parallelopipeds extruded 5.0 units in an orthogonal direction. extrude/cmo_arbshape/cmo_tri/ min/7.5/bubble/ 3,-2.5,-6 This command would result in a mesh of tris that form a surface enclosing a volume of prisms being created out of the initial tri sheet. First, since min is used, the “bottom” of the surface would be a plane. Second, because the vector 3, -2.5, -6 is specified, the extrusion will be in that direction (again the magnitude is not important, the vector is normalized to a unit vector), not in the direction of the average normal of the initial tri surface. extrude/cmo_prism/cmo_tris/interp/14/pset,get,bottom/pset,get,top This command would result in a mesh of prisms being created out of the two sets of tri sheets in cmo_tris as well as 14-1 layers of additional tris that would be interpolated. First, since interp is used, the pset defined by bottom would end up connected to the pset defined by top. Second, there would be 14 layers of elements that would be placed between the psets top and bottom, so that the resulting grid would have 15 layers of points that would be connected to one another to form prisms.",
    "tags": "extrude",
    "url": "/pages/docs/commands/extrude.html"
  },{
    "title": "LANL LaGriT",
    "text": "Pictures Created by Tinka Gammel -------------------------------- &lt;img height=\"300\" width=\"300\" src=\"images/snap.jpg\"&gt; \"600\" &lt;img height=\"300\" width=\"300\" src=\"images/snap1.jpg\"&gt; \"600\"",
    "tags": "",
    "url": "/pages/finite.html"
  },{
    "title": "8",
    "text": " Geometry Information   Much geometry information is maintained in the geom common block which is defined in the include file geom_lg.h. ————- ———————————————————— nsurf  is the number of surfaces nregs  is the number of regions nmregs  is the number of mregions maxdef is the number of tokens in the longest region definition maxmdef  is the number of tokens in the longest mregion definition. lastregdef end of regdef array lastmregdef end of regmdef array lastsparam end of sparam array ————- ———————————————————— Geometry information is contained in a set of memory managed arrays whose partition name is the geometry name. Retrieve the geometry name by:            call cmo_get_attinfo(‘geom_name, cmo_name, iout, rout, geom_name, ipout, itype,ierror) Surface information includes:   ----------- --------------------------------------------------------------- csall  surface name istype surface type (e.g. 'plane', cylinder, .....) ibtype boundary type (e.g. 'reflect;, 'interface', ...) sheetnm sheetname (for sheet surface types only) surfparam data describing the surface, varies depending on surface type offsparam offset into surfparam for a given surface ----------- --------------------------------------------------------------- Region/mregion information includes: ------------------------ ----------------------------------------------------------- cregs (cmregs) region (mregions) names ndetregs(ndefmregs) number of tokens in region(mregion) definition regdef (mregdef) region (mregion) definition offregdef (offmregdef) offset into regdef (mregdef) for a given region (mregion) matregs material number fo a material region ------------------------ ----------------------------------------------------------- subroutine get_material_number(mregion_name,number,ierror)          returns the material number associated with the material region called mregion_name. Any of the memory managed geometry arrays can be accessed using mmfindbk, for example:           character *32 pointer (ipcsall, csall)           call mmfindbk(‘csall’, geom_name,ipcsall,length,ierror)           where geom_name has been retrieved from the mesh object using cmo_get_attinfo.",
    "tags": "",
    "url": "/pages/docs/geom.html"
  },{
    "title": "",
    "text": "geometry/create geometry/create /geom_name Initialize a geometry called geom_name. Change the name of the current geometry to geom_name. Save all values associated with the previous geometry.  To associate this geometry with a mesh object use the cmo/geometry command.  See III.E for a discussion of geometry. EXAMPLES: geometry/create/new_geom/",
    "tags": "",
    "url": "/pages/docs/geom_create.html"
  },{
    "title": "GEOMETRY",
    "text": "GEOMETRY Initialize a geometry or change the name of the current geometry. To associate this geometry with a mesh object use the cmo/geometry command.  See Geometries for a discussion of geometry. geometry/create /geom_name geometry/release /geom_name create Initialize a geometry called geom_name. release Change the name of the current geometry to geom_name. Release all data structures related to geometry, geom_name and remove geom_name from the list of geometries. EXAMPLES geometry/create/new_geom/ geometry/release/old_geom/    ",
    "tags": "geometry, regions",
    "url": "/pages/docs/commands/geometry.html"
  },{
    "title": "Example LaGriT Page",
    "text": "LaGriT Style Guide In an effort to maintain consistency across the GitHub Pages implementation of LaGriT documentation, this document is a style guide for readers and developers. This page uses HTML to format box sections to show raw text and the resulting format. Use &lt;div class=\"markdown-example\" id=\"example-text\"&gt; &lt;pre class=\"source\"&gt;sample format written to show the raw page text &lt;/pre&gt; &lt;div class=\"rendered\"&gt;sample to show how format will appear on page &lt;/div&gt; &lt;/div&gt; &lt;b&gt;sample&lt;/b&gt; format written to show the raw page text sample to show how format will appear on page Table of Contents Page Titles and Headers Command Formatting Inline Code, Examples, Demos Linking to Other Pages Long Page Lists Embedding Images Further Resources 1. Page Headers &amp; Titles Each page should contain YAML-formatted metadata at the top of the document. See GitHub’s announcement and a basic guide on supported tags. In general, most metadata will do nothing. However, each document should contain at least these specifiers: title - this renders as the browser page title, and renders in search tags - this benefits the search functionality as well --- title: \"Example LaGriT Page\" author: My Name tags: example, quickstart, style --- Page titles should use the h1 header class followed by a page line, note the # character must not have spaces in front. Subsections should be marked with h2, subsubsections with h3, etc. # COMMAND or Page Title ------------------------------------ Page text ## Section Header COMMAND or Page Title Page text Section Header 3. Command Syntax and Descriptions The LaGriT command syntax section should be enclosed in the &lt;pre&gt; tags. Use the HTML bold formats for the command name and any literal keywords. &lt;pre&gt; &lt;b&gt;extract/surfmesh&lt;/b&gt;/1,0,0/cmo_out/ [cmo_in] [&lt;b&gt;external&lt;/b&gt;] &lt;/pre&gt; extract/surfmesh/1,0,0/cmo_out/ [cmo_in] [external] In the sections describing words and behavior of the command, the following formats should be followed: In general, use bold monospaced font for commands and methods, bold for keywords or reserved words, and unstyled monospace for primary variable names. The italics italic variable as needed for additional variables. The general italic is for use in text for notes or references. The following are used for a command syntax and description: Appearance Markdown Text COMMAND link [**`COMMAND`**](file.md) COMMAND **`COMMAND`** method **`method`** variable `variable` keyword **keyword** keyword_link [**keyword_link**](file.md) plain link [plain link](file.md) italic variable *`italic variable`* italic text *italic text* 3. Inline Code, Examples, Demos Command pages may include additional sections. Any inline Code, Examples, or Demos use fenced code blocks and should be wrapped in three backticks. The backticks will format much the same way as the HTML &lt;pre&gt; tags. This is an inline code block with 3 backticks before and after. To display screen output, use the tag &lt;pre class=\"lg-output\"&gt; instead of backtics or other &lt;pre&gt; tags. This is a block for screen output. 4. Linking to Other Pages You can link to other pages on this site by either using the literal URL, or (more appropriately) with a relative link to the corresponding Markdown file. It is better practice to use a relative link to a Markdown file, so that those attempting to read the documentation through a Markdown viewer (i.e. after cloning the LaGriT repo) will be able to easily access the referenced document. As an example, [this page](https://lanl.github.io/LaGriT/pages/docs/commands/ADDMESH.html) will take you to the same place as [clicking here](docs&#x2F;commands&#x2F;ADDMESH.md). As an example, this page will take you to the same place as clicking here. 5. Long Page Lists For pages with a long list of command options, use a clickable table at the top. See examples at dump Table format with page links. The colon on left will make cells left justified. Use colons on both sides to center. Add explicit spaces to avoid cell text running into adjacent cell text. | | | | | | :---- | :---- | :---- | :---- | |&amp;nbsp;&amp;nbsp; [**`chad`**](#chad) |&amp;nbsp;&amp;nbsp; [**`coord`**](#coord) |&amp;nbsp;&amp;nbsp; [**`datex`**](#datex) |&amp;nbsp;&amp;nbsp; [**`elem_adj_node`**](#elem_adj) | ... ### **`chad`** &lt;a name=\"chad\"&gt;&lt;/a&gt; 6. Embedding Images Below are multiple ways to embed images in a Markdown file. Note that relative paths are relative to LaGriT/docs/pages/docs/commands/. Set Image sizes for a page between 250 and 500. Embed with html &lt;img width=&quot;500&quot; src=&quot;https://lanl.github.io/LaGriT/assets/images/cube.png\"&gt; Using href will make a small image clickable to the full image: &lt;a href=&quot;cube.png\"&gt; &lt;img width=&quot;300&quot; src=&quot;cube.png\"&gt; &lt;/a&gt; Embed with markdown &#x0021;&#x005b;alternate text](https://lanl.github.io/LaGriT/assets/images/cube.png) &lt;img src=&quot;&#123;&#123;'assets/images/cube.png' | absolute_url&#125;&#125;&quot; width=&quot;500&quot;&gt; &#x0021;&#x005b;alternate text](../../../assets/images/cube.png) &#x0021;&#x005b;alternate text](&#123;&#123; site.baseurl }}/assets/images/cube.png) &#x0021;&#x005b;alternate text](&#123;&#123;'assets/images/cube.png' | absolute_url&#125;&#125;) 7. Further Resources Markdown supports tables, lists, embedded HTML/Javascript/CSS, images, and more. For syntax usage on embedding these elements, a few references can be found below: Markdown Quick Cheatsheet (Common Mark) Mastering Markdown (GitHub) - basic Markdown syntax overview Markdown Cheatsheet (assemble.io) - discusses the relationship between Markdown elements and HTML",
    "tags": "example, quickstart quickstart",
    "url": "/pages/github_pages_example.html"
  },{
    "title": "GRAPHICS",
    "text": "LaGriT GRAPHICS Geology Semiconductor Hexahedral grids Hybrid Grain growth Still Images Mesh for scanning microscopy simulation Tetrahedral LaGriT mesh for Microstructure Evolution Finite Element Calculation Laplacian smoothing Biological Structures (PDF) Gif Animations Grain growth in large cube Grain growth with temperature-dependent mobility Grain growth in line to bamboo GMMFE (Graph Massage w/ Moving Finite Elements) Shallow Water Equations Evolving Adaptive Grid Perspective view of water height with grid Alternate view of water height Rotating Hump View Perspective View Graph Massage for the shear flow (x,y)’=(-xy,0) Evolving Triangular Grid with Graph Massage Evolving Quadrilateral Grid with Graph Massage Evolving Quadrilateral Grid without Graph Massage Dendrite formation Dendrite surface with grid [adaptive refine used to maintain grid] without grid [temperature field displayed]",
    "tags": "graphics",
    "url": "/pages/graphics.html"
  },{
    "title": "Semiconductor",
    "text": "*XYZ: Cartesian coordinates cmo/create/cmo_hex_xyz/ rz/xyz/5,7,8/0.0,0.0,0.0/1.0,1.0,1.0/1,1,1/ rzbrick/xyz/5,7,8/1,0,0/connect/ zq/imd/1,0,0/regxyz/ dump/gmv/gmv_hex_xyz/     Return to LaGriT Home Page",
    "tags": "",
    "url": "/pages/hex1.html"
  },{
    "title": "Semiconductor",
    "text": "RTZ: Cylindrical coordinates cmo/create/cmo_hex_rtz// rz/rtz/5,7,8/1.0,0.0,0.0/0.0,360.0,2.0/1,1,1/ rzbrick/rtz/7,5,8/1,0,0/connect/ zq/imd/1,0,0/regrtz/ filter/1,0,0/ geniee dump/gmv/gmv_hex_rtz/ finish     Return to LaGriT Home Page",
    "tags": "",
    "url": "/pages/hex2.html"
  },{
    "title": "LaGriT Examples and Demos",
    "text": "LaGriT Examples and Demos         2d_connect rotatept createpts regnpts triangulate dump hextotet sort connect hextotet trans pset 2d_recon addmesh rmmat negative_aij/rivara Other Examples",
    "tags": "",
    "url": "/pages/docs/demos/"
  },{
    "title": "Tutorial LaGriT Introduction",
    "text": "Download Tutorial Tutorial - LaGriT Introduction LaGriT consists of mesh commands and options that are used to create, modify, optimize, and write files. LaGriT can be run on the command line interactively so commands are entered one at a time at the prompt, or with one or more files containing the LaGriT commands. By convention we use “.lgi” for lagrit input file names and “.mlgi” for macro files called from main command file. Run lagrit from the command line interactively, or put commands in a file and redirect. lagrit or lagrit &lt; input.lgi Important Note: the finish command must be used to exit interactive session and must be at end of command file. Common terms and definitions General Mesh = Grid = elements defining geometric shapes allowing numerical computations for simulations Node = Vertice = point = mesh object nodes that can be used to connect into elements. Element = cell = nodes are connected into element types such as line, triangle, or tetrahedral (see page) structured mesh = elements are arranged in a regular pattern with parallel sides and and orthogonal elements. unstructured mesh = elements arranged to fit complex geometries Delaunay = tri or tet elements arranged such that mesh is optimized for compuational accuracy Voronoi = the vertices of the voronoi volumes correspond to the circumcenters of the Delaunay tri and tets control volume (CV) method = ensures conservation of mass and energy in fluid flow and heat transfer equations LaGriT Current Mesh Object = cmo = the mesh object that actions will act on by default. imt = default name for node array with positive integer values indicating color or material itetclr = default name for element array with positive integer values indicating color or material itp = boundary tags geometry = created with surface and region commands and is used to set mesh materials Step 1. Create a Mesh Object Step 2. Check and View the Mesh Step 3. Assign materials Step 4. Set boundary nodes Step 5. Check and View the Mesh Step 6. Write Mesh and FEHM Setup Files Step 7. Create a zone list for FEHM",
    "tags": "",
    "url": "/pages/tutorial/lagrit_introduction/"
  },{
    "title": "LaGriT - Home",
    "text": "Powerful mesh generation,optimization, and maintenance. Download LaGriT Tutorial Contact Us LaGriT (Los Alamos Grid Toolbox) LA-CC-15-069 is a library of user callable tools that provide mesh generation, mesh optimization and dynamic mesh maintenance in two and three dimensions. LaGriT is used for a variety of geology and geophysics modeling applications including porous flow and transport model construction, finite element modeling of stress/strain in crustal fault systems, seismology, discrete fracture networks, asteroids and hydrothermal systems. The general capabilities of LaGriT can also be used outside of earth science applications and applied to nearly any system that requires a grid/mesh and initial and boundary conditions, setting of material properties and other model setup functions. It can also be use as a tool to pre- and post-process and analyze vertex and mesh based data. About LaGriT LaGriT provides a variety of meshing tools specific (but not limited) to geologic applications and Voronoi control volume solvers. These tools were developed to generate and modify meshes, and also to create meshes with control volume discretization such that the underlying control volumes are Voronoi tessellations as preferred by some modeling applications. Capabilities include: Representation of 2- and 3-dimensional complex geometries with multiple materials or regions Unstructured triangle/tetrahedral and structured or unstructured quadrilateral/hexahedral meshing Model set-up including assigning material properties, boundary conditions, and initial conditions Adaptive mesh refinement, smoothing, and optimization Distribute uniform or variable spaced points using Poisson Disk sampling 2D and 3D Delaunay triangulation conforming to complex geometry Output for solver packages including specialized format for FEHM, Amanzi/ATS, PFLOTRAN, and TOUGH2 Interactive command line, batch input file, or embedded in Fortran/C interfaces (no GUI) PyLaGriT is a Python interface that allows LaGriT functionality to be used interactively and in batch mode. It combines the meshing capabilities of LaGriT with the numeric and scientific functionality of Python including the quering of mesh properties, enhanced looping functionality, and user defined error checking. PyLaGriT has been developed to easily generate meshes by extrusion, dimensional reduction, coarsening and refinement of synthetic and realistic data. PyLaGriT enhances the workflow, enabling rapid iterations for use in simulations incorporating uncertainty in system geometry and automatic mesh generation. PyLaGriT Manual Using LaGriT Commands LaGriT works on a single or multiple mesh objects which can be created or read from a file. The actions on the mesh object are driven by mesh commands and their options. These commands can be called interactively on a command line, or scripted with an input file. LaGriT will write two output files upon completion, by default they are lagrit.out (summary and reports for each command) and lagrit.log (saved commands). See the following about using the commands. Refer to Tutorials and Examples for help with syntax and work flow. Commands listed Alphabetically Commands listed by Category Command Interface Syntax Conventions Mesh Design Considerations LaGriT Error reporting Tutorials and Examples The easiest way to use LaGriT is by copying from working examples. The Tutorials will help you to understand how commands can be combined into a work flow. Examples and demos provide methods to create meshes and ways to optimize for and check for improved mesh quality. Tutorials and Examples Test Suite Cases Meshing Projects Page Some Graphics Examples LaGriT Details The Mesh Object is the data structure which contains the information necessary to define a mesh. It consists of attributes that include coordinates, connectivity, and other data. Attributes are updated by LaGriT routines and can be modified by the user. Descriptions of the mesh object and associated details are included here. Mesh Object Definition Mesh Object Connectivity Supported Element Types Geometries and Regions Code and Development LaGriT was originally written with Fortran and C and now includes C++ routines. New wrappers enable C++ to access fortran code needed to maintain and manipulate mesh objects. CMake is used to generate the build system and works with C, C++, and compatible Fortran compilers. Building an Executable and Running LaGriT Fortran Interface to LaGriT code C-Fortran Interface to LaGriT code Issuing Commands from a User Program Writing User Commands Accessing the Mesh Object Utility and Memory Subroutines Old Manual Index",
    "tags": "",
    "url": "/"
  },{
    "title": "MSTKLA Online Manual",
    "text": "“249” “87”“248” “166” MSTKLA - Mesh ToolKit interface to LAgrit (LA-UR-99-6711) DIRECT LINKS “142” “24”](Geom.md) “143” “26”](Mesh.md) “143” “25”](utilities.md) “1” “26”](MeshAttributes.md) “144” “24”](GeomEntity.md) “141” “25”](GeomRegion.md) “143” “26”](GeomFace.md) “143” “25”](GeomEdge.md) “142” “24”](GeomVertex.md) “1” “25”](GenRegion.md) “143” “25”](MeshRegion.md) “143” “26”](MeshFace.md) “143” “25”](MeshEdge.md) “143” “25”](MeshVertex.md) “144” “25”](trivia.md) Questions, Comments, Suggestions? Contact:                 Rao V Garimella, PostDoc                                                                       Tel: (505) 665-4636                 EES-5, MS D0                                        ‘       ‘                                    FAX: (505) 665-69                 Los Alamos National Lab                              (  )-(  )                                Email: &lt;rao@lanl.gov                 Los Alamos, NM 8   MSTKLA is a C interface to the LaGriT code which is designed to make it easier to use the LaGriT functionality. It tries to hide some of the internals of LaGriT and provides an API that works in a somewhat object oriented way. It does not attempt to provide or enhance interactive commands that exist in LaGriT. Rather, it is designed more with writing automated mesh generation procedures and complex meshing algorithms within LaGriT in mind. MSTKLA has one or more mesh objects, which have mesh regions, mesh faces, mesh edges and mesh vertices (nodes). Mesh faces and mesh edges are objects defined on the fly in terms of their vertices. One can ask these objects various questions or modify their info through operators. In addition there is a geometric model and geometric model objects (In the spirit of consistent naming, I am labeling this set of functions GMTKLA). Since LaGriT does not really store curves or points in the database, these are also faked on the fly. The mesh and model entities are related through the concept of CLASSIFICATION. “A mesh entity is classified on a model entity if it forms all or part of that model entity’s discretization (grid) but not its boundary’s”. So mesh regions can be classified only on a model region.  Mesh faces can be classified on a model face or a model region. Mesh vertices can be classified on a model vertex, model edge, model face or model region. Classification information can be queried from MSTKLA if it is available. In particular, in LaGriT, only external faces (what LaGriT calls “reflective” boundaries) and internal faces or interfaces created with the option “intrcons” in the surface command have the information required to retrieve full classification information. Full classification information includes the type of geometric model entity the mesh entity is classified on, the ID of that geometric model entity and a pointer to the geometric model object (which can be further queried). Interface surfaces created with the surface command option “intrface” do not have the necessary information to relate the mesh and the model fully. (In the future, I may put in code to take the “intrface” type surfaces and add the info needed to find out the classification information). Note that the current interface works for querying an existing mesh but not yet for modifying it. The operators for this are on the way. Operators for calling the actual meshing operators (connect, refine, smooth, etc) will also be added in the near future. Finally, the basic interface (low level query and modification operators) are expected to retain the same format regardless of what the underlying database is (LaGriT or something else). So, for example, I am hoping that an operator to retrieve the nodes of an element will retain the same form shown below regardless of how it functions internally: void MR_Vertices(PMeshObj mesh, PMeshRegn reg, *int **nv, *PMeshVert **rverts); I will try hard to maintain this API constant but cannot absolutely guarantee it.   []{#parent-childAlso see Parent-Child Node (Vertex) Issues []{#typedefsTYPEDEFS  []{#MSTKLA_InitMSTKLA Interface Operators MESH INITIALIZATION:   void MSTKLA_Init(void); Initialize the mesh toolkit. MESH OPERATORS:    []{#MESH OBJECT:MESH OBJECT:  []{#MESH REGION:MESH REGION:  []{#MESH FACE:MESH FACE:  []{#MESH EDGE:MESH EDGE:  []{#MESH VERTEX:MESH VERTEX:    []{#GENERIC MESH REGION QUERIES:GENERIC MESH REGION QUERIES: []{#GMTKLA_InitGEOMETRIC MODEL INITIALIZATION: void GMTKLA_Init(void); Initialize the geometric model interface. MODEL OPERATORS:  []{#GEOMETRIC MODEL:GEOMETRIC MODEL:  []{#MODEL ENTITY:MODEL ENTITY:  []{#MODEL REGION:MODEL REGION:  []{#MODEL FACE:MODEL FACE:  []{#MODEL EDGE:MODEL EDGE:  []{#MODEL VERTEXMODEL VERTEX —&gt; Not implemented fully   []{#UTILITIES:UTILITIES: []{#EXAMPLEEXAMPLE OF PROGRAMMING WITH MSTKLA   []{#EXECUTABLELIBRARIES, INCLUDE FILES AND CREATING AN EXECUTABLE",
    "tags": "",
    "url": "/pages/mstkla/"
  },{
    "title": "INTERSECT_ELEMENTS",
    "text": "INTERSECT_ELEMENTS This command takes two meshes and creates an element-based attribute with the number of elements intersected. We define intersection as two elements sharing any common point. SYNTAX intersect_elements / mesh1 / mesh2 / [attrib_name] mesh1 has the added attribute containing the number of elements that were intersected. mesh2 is the object used for the intersection. attrib_name is the name of the element based attribute that is created by this command. The default name for this attribute is in_mesh2 using the mesh name to form the new attribute name. This attribute stores the number of intersections. It is worth noting that some mesh viewers do not take kindly to names that are longer than eight characters and may truncate them. Description This code has been slightly modified to work with AMR grids. This modification depends on an element based attribute called itetkid. If this attribute is not present, intersect_elements will NOT be able to recognize the AMR grid, and will intersect all elements of the octree. With the itetkid attribute present, only leaves of the octree which intersect will be flagged. This table shows the available intersect capabilities. An X in the box means that the intersection is supported. element point line tri quad tet pyr hex point X X X X X X X line X X X X X   X tri X X X X X   X quad X X X X X   X tet X X X X X   X pyr X             hex X X X X X   X For example, this means that if you have a mesh that has hexes and tets in it, you could intersect it with a mesh that has anything but pyramids in it. Note: intersect_elements is based on a k-D-R tree implementation to improve performance in many circumstances. Unfortunately, there is no way to improve performance if the elements being intersected have many candidate elements in their bounding boxes. As such, there are situations where running time may be improved by refining mesh2 such that its elements are of comparable size with those of mesh1. EXAMPLES intersect_elements/cmo_grid/cmo_sphere/ Intersect grid with sphere and tag elements in default attribute in_cmo_sphere. intersect_elements/cmo_grid/cmo_well/obswell Intersect grid with well and tag elements in default attribute in_obswell. read avs river_lines.inp moli intersect_elements / cmotri / moli / inriver eltset / eriver / inriver / gt 0 pset/priver/ eltset / eriver cmo/ setatt/ cmotri/ itetclr / eltset,get,eriver 1 cmo/ setatt/ cmotri/ imt / pset,get,priver 1 Intersect to find nodes and elements at river object, tagged elements are in attribute inriver.",
    "tags": "intersect elements",
    "url": "/pages/docs/commands/intersectelements.html"
  },{
    "title": "Issuing commands from a user program",
    "text": "Issuing commands from a user program. Any LaGriT command can be issued by calling the subroutine dotask , for example: call dotask (cmo/select/3dmesh; finish, ier1) will select the Mesh Object named 3dmesh. ier1 will be zero if the commands are executed with no error, non-zero otherwise. A sequence of commands can also be executed using dotask,  for example: call dotask (cmo/addatt/mo; cmo/list; finish, ier1) will execute the two commands and then return to the next executable statement.  A finish command must always be the last command in the command list for dotask.  The user should also be aware that mesh object pointers might be changed by the dotask commands and should be refreshed using cmo_get_info.  The parser arrays cmsgin, xmsgin etc. will not be the same upon return from dotask. By using the LaGriT command infile, a series of commands may be executed, for example: call dotask (infile/mydeck; finish, ier1) will execute all the LaGriT commands that are in the user’s file named mydeck. The final command in the file mydeck should be finish. mydeck itself may contain additional infile commands.",
    "tags": "",
    "url": "/pages/docs/issuing.html"
  },{
    "title": "KDTREE",
    "text": "KDTREE KDTREE uses the elements of the current mesh object to produce a k-D tree that is stored in the attributes LINKT and SBOX that are appended to the mesh object.  Leaf nodes in LINKT each contain exactly one element index.   Because of the possibility of triangle overlap, KDTREE also produces an array SBOX which gives ‘safety boxes’.  For each node in the k-D tree, there is a corresponding safety box which is just big enough to contain all the triangles  “under” the node.  The attributes LINKT and SBOX are used by the subroutine:  RETRIEVE_WITHIN_EPS.  RETRIEVE_WITHIN_EPS finds all elements with epsilon of the query point (xq,yq,zq). What is actually returned is a small subset of leaves  (i.e., elements) that feasibly could be within epsilon of the query point.  The user must then do exact geometric tests on this small subset to actually determine which elements are a distance epsilon from the query point. subroutine retrieve\\_within\\_eps(xq,yq,zq,linkt,sbox,eps,nefound,iefound,ierr) xq, yq, zq  coordinates of query point linkt, sbox mesh object KDTREE attributes created by the KDTREE command eps  search epsilon nefound  number of elements found iefound array of elements found ierr error flag   (0 = no error) The attributes LINKT and SBOX may also be used by the subroutine: NEARESTPOINT.  NEARESTPOINT uses the k-D tree structure for a triangular surface mesh object  (generated by KDTREE) to accelerate finding the nearest point on the surface to the given query point (xq,yq,zq).  What is actually returned is a small subset of leaves (i.e., triangles) that feasibly could contain the nearest point.  The user must then do exact geometric tests on this small subset to determine points of intersection. subroutine nearestpoint(xq,yq,zq,xic,yic,zic,itet,xs,ys,zs, linkt,sbox,eps,distpossleaf,mtfound,itfound,ierr) xq, yq, zq  coordinates of query point xic,yic,zic arrays of coordinates of nodes in the surface mesh object itet array containing trianged-node relationship for surface mesh object. xs,ys,zs coordinates of previous retrieved “nearestpoint”.  If no previous query, set these to a very large value linkt, sbox mesh object.  KDTREE attributes created by the KDTREE command distpossleaf work array of length = number of triangles in the surface mesh. mtfound number of triangles found itfound array of triangle (element number) found ierr error flag              ",
    "tags": "kdtree",
    "url": "/pages/docs/commands/kdtree.html"
  },{
    "title": "About LaGriT and PyLaGriT",
    "text": "LaGriT LaGriT is a library of user callable tools that provide mesh generation, mesh optimization and dynamic mesh maintenance in three dimensions for a variety of applications. Geometric regions within arbitrarily complicated geometries are defined as combinations of bounding surfaces, where the surfaces are described analytically or as collections of points in space. A variety of techniques for distributing points within these geometric regions are provided. Mesh generation uses a Delaunay tetrahedralization algorithm that respects material interfaces and assures that there are no internal negative coupling coefficients. The data structures created to implement this algorithm are compact and powerful and expandable to include hybrid meshes as well as tetrahedral meshes. Mesh refinement and smoothing are available to modify the mesh to provide more resolution in areas of interest. Mesh refinement adds nodes to the mesh based on geometric criteria such as edge length or based on field variable criteria such change in field. Mesh smoothing moves nodes to adapt the mesh to field variable measures, and, at the same time, maintains quality element shape. Mesh elements may become distorted as mesh nodes move during a time dependent simulation or are added as a result of refinement operations. Mesh reconnection via a series of edge flips will maintain the Delaunay criterion of the mesh. An additional requirement of time dependent simulations is that as interface surfaces move, the corresponding region definitions must respond dynamically. As surfaces collide, the mesh must respond by merging points and effectively squeezing out the material between the colliding surfaces. LaGriT provides the necessary tools for time dependent simulations. PyLaGriT PyLaGriT is a Python interface that allows LaGriT functionality to be used interactively and in batch mode. It combines the meshing capabilities of LaGriT with the numeric and scientific functionality of Python including the quering of mesh properties, enhanced looping functionality, and user defined error checking. PyLaGriT has been developed to easily generate meshes by extrusion, dimensional reduction, coarsening and refinement of synthetic and realistic data. PyLaGriT enhances the workflow, enabling rapid iterations for use in simulations incorporating uncertainty in system geometry and automatic mesh generation.",
    "tags": "",
    "url": "/pages/docs/lagrit.html"
  },{
    "title": "LaGriT V2 Release Notes",
    "text": "Version 2.2 Release November 2010 This is the last release before work to support 64 bit. * * Program: LaGriT V2.200 Linux m32 * * * date_compile: 2010/11/22 * Enhancements: interpolate Changed interpolate to “find” more points on edges this will permit nodes to find a nearest edge or point and be “inside” the triangle for extreme small or large numbers where epsilon values are difficult to evaluate correctly. Note, this changed test results for interpolate, test/level01 results were updated for these improvements. extract/surfmesh Now creates attributes to hold element local face numbers of 3D input mesh that occur on either side of output mesh face, idface0 and idface1. Now copies user-created node-based attributes from source. dump/fehm dump/zone_outside Changed FEHM outside area to Voronoi instead of Median FEHM file file_name_outside.area changed to file_name_outside_vor.area For dump/zone, added keywords keepatt_area or keepatt_voronoi which will compute and keep voronoi vector areas xn_varea, yn_varea, zn_varea and keepatt_median will compute area/num nodes on face and keep attributes xn_area, yn_area, zn_area The written file file_name_outside_vor.area or file_name_outside_med.area is a list of 2D area vectors (Ax_i,Ay_i,Az_i) associated with each node. cmo/addatt/voronoi_varea will do the same voronoi calculation on triangles as is done with the outside area for FEHM modeling files. The call will create node attributes xn_varea, yn_varea, zn_varea indicating face directions. dump/ filename 2 token dump for common files added to writedump.f addmesh/ excavate remove nodes and elements if they fall with the circumsphere of triangles on the input mesh. These issues were fixed: intrp_gtg.f A bug was fixed in interpolation that would sometimes save a node id in pt_gtg or el_gtg attributes that was not related to the found candidate and value. This could occur where there are multiple candidates for the source and if epsilon values are reaching near machine limits. The test in level01/intrp_2D_sizes was changed to capture and evaluate these issues. epsilon errors in intrp_gtg.f, inside_lg.f There are changes to interpolate using tests for finding points that are inside or on edges or vertices of an element. The epsilon tests have been relaxed to allow points that are “near” to be found on edge - if within the chosen epsilon. The interpolation has been changed to evaluate candidate points based on the confidence of being inside the associated triangle. A result indicating the point is inside will “win” over a candidate result that is on edge or vertice. If idebug attribute is set to a number of 5 or greater, there will be many more statements written that are related to the inside triangle and epsilon tests. Version 2.106 6/29/2010 This version contains the work done over the summer by Aaron Gable. Better handling of errors and segmentation faults were added to various pieces of the code having to do with actions involving more than one mesh object and their user defined attributes. Enhancements memory New options to print and check memory manager and report memory usage. This superseeds old utilities mmprint, mmcheck, etc. read for 3 tokens for .inp .gmv .avs cmo/attribute_union Change two meshes so they both share the same set of attributes compute / linear_transform extrapolation from an attribute value in a surface onto every node of a 3D mesh compute/signed_distance_field to calculate signed distance relative to above and below. grid2grid wrapper for hextotet. can also convert from octree mesh to lagrit with tree_to_fe anothermatbld3d_wrapper.f Create two new node vectors, ccoef, ij_ccoef Put the negative ij coefficient value into the two nodes connected to the ij edge. The vector ij_coef will assign the j index value to node i so that one can determine which edge is associated with the neative coefficient that is assigned to nodes. Add option to pset/ / zone for user specified zone id number These issues were fixed: Modified epsilons in tri2d, fixed bug in foreach part of loop anothermatbld3d.c possible accuracy improvement using Carl’s changes to include TranslateTetToZero for geometric calculations Version 2.1 Release August 2009 This is a major update to LaGriT and the lg_util library. Major changes have been made in the core memory management routines to allow development for a 64 bit release. These changes will be invisible to most users but allows better reporting of errors and memory usage for useful diagnostic information. * * Program: LaGriT V2.100 Linux m32 * * * date_compile: 2009/08/03 * ###Enhancements: Executable build for Mac with Intel chip New capability in compute module to compute signed distance fields Incorporate METIS source code for graph partition and reorder package with LaGriT. For details of METIS algorithms and descriptions of the third command line argument see http://glaros.dtc.umn.edu/gkhome/views/metis Add option to create node attribute that is the Voronoi volume associated with each node of a Delaunay mesh Module addmesh modified to handle errors so that it can be used in a loop without needing to have first call be different Updates stor file commands so default uses newest version of code to build sparse matrix. This uses less memory and takes less time to build. New syntax options for stor file compression include all (default), graph, coefs, or none. Initialize list pointers to null assign null to pointers after free add warning messages for failure to free. initlagrit.f add call to mmverify the new util version checks for correct pointer sizes cmo addatt vor_volume added which calls anothermatbld3d_wrapper to fill voronoi volumes dumpfehm.f Add compress_opt to dumpfehm arguments add comments and error checking to clarify code logic check options and set for 2D or 3D calls to matbld use matbld3d_stor for compress options none and coefs use anothermatbld3d_wrapper for compress options all and graph Note anothermatbld3d_wrapper can write only scalar coef values anothermatbld3d_wrapper.f Extensive chages to error handling and messages, but not to the logic of program This code has same logic as matbld3d - but uses linked lists instead of mmgetblk calls Use io_type to toggle creation of attribute for voronoi volumes or to write to stor file added extensive error checking to eliminate segmentation faults added error check and message for every mmgetblk and mmrelblk added calls to mmprint when mm calls fail cleaned up variable declarations and added comments added istatus to check for errors and completion of matrix changed all routine messages to start with AMatbld3d_stor to distinguish from matrix built with Matbld3d_stor added idebug options added status report at end of routine matbld3d_stor.f Extensive chages to error handling and messages, but not to the logic of program This code uses many mmgetblk calls and about 40 percent more memory than linked list version added extensive error checking to eliminate segmentation faults added error check and message for every mmgetblk and mmrelblk added calls to mmprint when mm calls fail cleaned up variable declarations and added comments added istatus to check for errors and completion of matrix added idebug options added status report at end of routine matbld1.f This routine is called by matbld3d_stor added error check and message for every mmgetblk and mmrelblk added calls to mmprint when mm calls fail ###These issues were fixed: readatt not working correctly for psets blockcom.h fix for compile on MAC OS X Absoft on intel comment out ntetmax/0/ and let compiler initialize because we have 2 instances of pointer sizes. See kfix and xfix in neibor.h Version 2.004 10/21/2008 Enhancements: resetpts bug fix, boundary_components and extract_surfmesh added features boundary_components: added id_numb boundary index number extract_surfmesh: added attributes idelem0, idelem1, idnode0 and removed attribute map- Made changes so that filter and rmmat return with no action rather than crash when passed an empty mesh object. Add options dump/att_node and dump/att_elem Add options dump/att_node and dump/att_elem to output tables of either node attributes or element attributes to ascii files with header lines beginning with character #. These are similar to dump/avs/file/mo/0 0 2 0 or dump/avs/file/mo/0 0 0 2 except the addition of # character to start lines. Now these files can be read in without editing using cmo / readatt / workflow. Added character # for comment lines These issues were fixed: resetpts had a bug for some element types Corrected bug: cmo_exist returned error flag but check of error flag was to wrong error flag variable. Made changes so that filter and rmmat return with no action rather than crash when passed an empty mesh object. Version 2.003 05/20/08 Compile and test V2.003 for platforms SGI-32, SUN, MAC, LINUX These issues were fixed: These include fixes to SGI compile errors in dumpavs.f filter.f refine_tet_add.f lagrit*.h writinit.f and the Makefile in src Correct minor bugs. Test case now works. sphere1.f had an incorrect attempt to use MO name before the name had been obtained. Code would crash. offsetsurf.f did not handle problems with non-triangle or line type MO. Instead of kicking out, an attempt was made to compute sythetic normal for a mesh object (such as quad) and this caused code to crash. Fixed error that occured when all output attributes were turned off. Fixed error that occured when all output attributes were turned off. Code tried to allocate a zero length array for xvalues( ). Version 2.002 Release April 2008 Improved check_test.py to compare numbers as numerical values instead of text string. The new results are saved in result_files Generalized version Makefile and dependencies Uses wildcards for .f .f90 and .c maintains object files in seperate directories for each platform and for debug and optimized use make help for list of options added options opt and debug as build choices Initialize nremtet and npoints2 to 0, initialize number_elements and number_nodes to zero Modify output for Dudded points to indicate when there are no elements (for removal) Changed name from ‘program adrivgen’ to ‘program lagrit_main’ Modified header correcting spelling, changed X3D to LaGriT. Enhancements Add capability to read FEHM zone/zonn files. These issues were fixed: corrected change to printatt minmax output so that name has 18 characters, with total line of 80 chars for cmo_setatt.f added error check for existing cmo and expanded name string size for 17 character names for cmo/printatt/ minmax limited format to 80 characters Corrected typo in screen output. Changed ‘nnelements’ to ‘nelements’ Changed some memory allocation from real(2) to int(1) for integer work arrays. Running a large problem (&gt;10,000,000 nodes) was crashing at rmpoint due to MALLOC failure. changesets tracked with Mecurial/Trac 0.10.4 on ancho.lanl.gov/lagrit/hg/lagrit",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_081021.html"
  },{
    "title": "LaGriT Release Notes",
    "text": "LaGriT V1.0.1 - V1.0.2 Release Notes 1999 - 2000 This text is converted from old pdf files and may have translation errors. See original pdf for clarification. LaGriT V1.0.2 January 2000 PDF Version LaGriT V1.0.1 November 1999 PDF Version New Commands intersect_element intersect two mesh objects and create an element based attribute (xsect_cm) that holds the number of times the sink element was intersected by a source element intersect_elements/sink_mo/source_mo/[attribute_name] lower_d extract lower dimensional meshes from the current mesh object, create data structure for the lower dimension objects that parallel the top d default structure: [d1_nnodes, d1_e|ements, d1_itet, d1_jtet, di_itetoff, d1_jtetoff, d1_itetc|r, d1_itettyp] [d2_nnodes, ….. ] rzv distribute nodes as linear combinations of 3 supplied vectors. rzvlgeom/n1,n2,n3/v11,v12,v13/v21,v22,v23/v31,v32,v33 geom can be xyz, rtp or rtz. n1,n2,n3 specify the max number applied to each vector. The v‘s are the 3 basis vectors. rzamr use octree refinement to a specified level on a existing hex mesh to distribute nodes within a region- intended a a node distribution algorithm only - no hex information is preserved. rzamr/region_name/number_of_levels createpts wrapper for all the ‘rz‘ type commands: createpts/xyz|rtz|rtp|/n1,n2,n3/x1,y1,z1/x2,y2,22/[ix,iy,iz/]/ [irx,iry,irz/rx,ry,rz] createpts/sphere/1|2|8|diamond /nr,npt,xirad,xorad /xcen,ycen,zcen/iz/irat,rz/ createpts/brick/xyz|rtz|rtplni,nj,nk/xmin,ymin,zmin/ xmax,ymax,zmax/iiz,ijz,ikz/[iirat,ijrat,ikrat/xrz,yrz,zrz/isym,jsym,ksym createpts/brick/xyz|rtz|rtp/ni,nj,nk/pstatus,get,name/connect/ createpts/amr/region_name/number_of_levels createpts/random/ xyz|rtz|rtp /spacing/x1,y1,z1/x2,y2,z2/ [xcen.ycen,zcen/ edgedist/ ranseed1,ranseed2] createpts/vector/ xyz|rtz|rtp/n1,n2,n3 /V11,V12,V13/V21,V22,V23/V31,V32,V33 Command Enhancements read/gmvfreeformat read in an ascii gmv file that is to be read with read (unit,*) statements. boundary add option to establish or to reset icr, icontab relationship for a set of surfaces. This is normally done by the setpts command, but if surfaces are defined after setpts, the surface command will cause an entry in the icontab table for the nodes on the surface, but no entry will exist for intersections of surfaces. boundary/dirichlet/icr//surface list e.g. boundary/diriclet/icr//top left front will identify the nodes on the intersection of the surfaces top left and front, and will set the icr value of these nodes to point into the correct icontab entry. quality add pcc option which will identify negative coupling coefficients and create an element based attribute to store the value (1 means okay, anything less than 1 is a negative coupling) quality/pcc boundary_components boundary_components Now prints out number of connected boundary components and a representative vertex from each component. rmpoint/sparse For expert users only. Requires reconnection when done. Bug fixes 06/10/99 pntlimc ﬁx missing argument in call to writloga - return empty set if error 06/13/99 refine_face_add, cer_chain,cel_chain ﬁx incorrect icr and itp values assigned using reﬁne/addpts to triangular 2d mesh 16/16/99 copypts remove extra comma from write statement 06/1 7/ 99 readavs read pyramid data correctly 06/23/99 control_connnaud_lg ﬁx errors in nesting of inﬁles and in invoking infile from dotask 16/25/99 get_elements_on_edge update len,len1 1f need to increment memory 17/02/99 readgmv_ascii check for end of ﬁle – skip blank lines 07/07/99 regupts this is really a compiler bug - change indirect indexing so optimizer does not generate bad code 17/13/99 control_command_lg skip comments When entered as interactive or as dotasks 07/23/99 refine_face_add make arguments in call match those in subroutine statement 07/23/99 readavs declare pointers — use pointer_arrays.h for integer8/integer4 distinction 08/ 04/99 initlagrit initialize pi 18/05/99 cmo_readdump_cmo allow for zero length attributes 08/05/99 read_lagritgeom ﬁx memory problem 08/10/99 multiimaterial calculate length of matlst correctly 18/11/99 reﬁne_interface_elements_lg use nnodes for length of iseedtet 08/11/99 regnpts use max not min for length of name comparisons 08/1 8/99 readdump use ierror_return 08/27/99 rmpoint get correct values in isetwd 18/30/99 multi_material2d_lg refresh pointers 08/3 0/99 multi_magterial refresh pointers 08/31/99 control_command_lg check for an empty loop 18/31/99 matbld3d_stor, anothermatbld3d_wrapper unformatted IO bugs 18/31/99 writedump restore dump_recolor command 09/01/99 connect2d_lg remove references to if4 09/01/99 initlagrit remove test on uninitialized variable 19/(11/99 read_lagrit_geom use lengths with concatenation operator 09/01/99 refine_face_add initialize isnl for all new nodes 09/01/99 surfset change dotaskgen to dotask 09/01/99 make bigtri get mbndry from mesh object 19/02/99 pset ﬁx test on mregion names 09/03/99 surface restore tabular surface implementation 09/07/99 recon2 allow for nodes on external boundaries with no icr values 19/17/99 cer_chain ﬁx typo (mpary should have been mpary1) effecting pset type refinements 10/03/99 intradd use nefcmo which is required for hybrid grids 10/14/99 region, mregion Check for size of stbout array 10/19/99 rzbrick3 check value of nwds before setting isym, jsym and ksym. 12/13/99 rzbrick3 check nwds before setting end point and ratio ﬂags Code Improvements boundary new option (see above) ﬁlter cleaned—up and added comments pset use Information from call get_materials_on_edge_lg returns materials around edge cmo_dump_cmo skip cmo attributes with ‘L’ in ioﬂag ﬁeld when writing lagrit dump ﬁles. matbld0tri, matbld3d assigned idebug, reduced screen output, removed print * read_trilayers postproccss by column option, preserve buffers, create buffers at interfaces, read gmv or avs temptam new subroutine beads_ona_ring to distribute vertically for read_trilayers rand_lg new random number routine (fancy) ran2_lg renamed random number routine (simple) temp,edit clean up unused code neighbor_recolor improved algorithm cmo_interpolate accept ‘constant’ as interpolation type - implement linear,log, asinh for integer attributes recon2 test for existence of icontab readgmv_binary allow line type elements to be read connect release imt1 when no longer needed cmo_modatt_cmo look for special name icr,imt,itp, isn and change icr1,imt1,itp1,isn1 zq get rid unused options rz change i6 formats to i10 cel_chain check for infinite isnl chain loops dumpavs check if no nodes, elements then return without crashing delaunay replace expensive inner loop with more efﬁcient code connect settets, check if mbndry is big enough checkmbndry inv3x3, inv2x2, inv_schmidt_hilbert_lg.f better solution to MX=Y for 3X3 and 2X3 cases volume_qud.f contains 2 algorithms for calculating volume of a quad volume_element.f call volume_qud(elcment) for old method using centroid, call volume_qud(element)_alt_lg for method equalizing 4 contributing triangle areas 12/03/99 lower_d_lg, cmo_copyatt_mpno_lg copy all user attributes from one mesh object to another — used by lower_d routines 12/13/99 pset a11ow either compare/value or va1ue/compare in syntax of command. 12/14/99 readdump, readgmv_ascii new option read/gmvfreeformat uses read(unit,*) statements. Code Changes reﬁne reﬁne..edge for 2d now works like reﬁne..face (in 2d edges are facets and nodes are edges - but people don’t think that way hence the change) rz initiahze itp,imt,icr to zero for new nodes blockcom, local_element.h set up relationships for edges to faces for all element types readgmv ascii call geniee at end —— skip blank lines, test for eof’ readgmvibinary call geniee at end popcones_lg,massage issue rmpoint/compress from within loop (needed for big problems) lineline, xsectelementscmo, calc_rdist, lineseglineseg, xsectelm, insideielement, linesegtri, kdtreeselect, tritri new subroutines dump_material_list replace * formats to speed up code hpsortip, hpsorti, matbldl replace all calls to ssort with calls to appropriate hpsort routine agd3d don’t print ‘curve neighbor’ warning to standard out. popcomponents new topo change routine rmppoint zero out imt,itp,isn,icr for removed nodes in rmpoint/compress option cmo_interpolate handle ‘and‘ and isetwd as special case delaunay, refine_edge_add, ﬁndface, matbld0tri, matbld2d_stor replace calls to ssort with hpsort agd, sgd use inscribed radius not aspect ratio mergepts_simplex use epsilonv not epsilonl for volume tests",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V1.0.2.html"
  },{
    "title": "LaGriT Release Notes",
    "text": "LaGriT V1.0.3 Release Notes Notes 2001 This text is converted from old pdf files and may have translation errors. See original pdf for clarification. LaGriT V1.0.3 2001 PDF Version A summary of the major changes found in this release are listed below. A complete list of changes is included at the end of this document. Refer to the user‘s manual for a complete description of the new, enhanced and revised commands. New Commands: reorder/cmo/sort_key will reorder a the mesh object according to the sort_key. See sort interpolate interpolate/map|continuous|voronoi/cmo_sink/attr_sink/ifirst,ilast,istride, /cmo_source/attr_source/[mintie|maxtie]/ [value|p|us1|nearest source,attr/[keepatt|delatt] Enhanced Commands: extrude extrude/cmoout/cmoin/interp/layers/range1,range2 smooth smooth/position/network/pset,get,name/number_of_iterations/ weight/[check|nocheck] createpts createpts/voronoi cmo cmo/set_id/cmoname/both node element [attributename1/attributename2] sort sort/cmoname/bins /ascending|decending]/[ikey]/in_att sort/cmoname/index|rank/ ascending|decending]/[ikey]/in,att1 in_att2 in_att3 extract extract only exterior surface. extract/surfmesh/ifirst,ilast,istride/cm0_out/[cmo_in]/[external] recon If checkaxy is specified, then for the case of 2D triangular meshes, we check xy projected areas are positive and larger than epsilona. recon/[0,1]/[toldamage]/[checkaxy] Bug fixes 06/06/00 dumpgmv_hybrid use i3.3 format to write ‘created’ material names. 07/24/00 setsize_nosb test against mbndry_old not mbndry for noop condttion 07/25/00 set_global_nosb set only integer or real (don’t Wipe out previously set variable) 07/27/00 lower_d_lg set ioff before using, increase dimension of tmsgout, imsgout 08/16/00 connect ﬁxed memory problems with failure lists 09/08/00 boundary ﬁx several bugs relating to resetting icr values 09/08/00 rotatept ﬁx getting pset if using numeric arguments 09/08/00 rzbrick3 call cmo_get_name before calling cmo_get_info 09/27/00 multi_material_2d_lg missing argument in surftstv calls 10/12/00 pset restore ‘eq’ as default operation 10/20/00 reﬁne face add ﬁx problems with second pass on 2d refine 03/23/01 surface ﬁx problem with cone type - parameters saved in wrong place 05/07/01 cer_chain make reﬁne on roughness work for 2d meshes Code Improvements 06/08/00 cmo_mesh_type new mesh type triplane like tri but ndimensions_geom=2. 08/25/00 addmesh pyramid use kdtree to ﬁnd matching grid boundaries 09/03/00 pset, eset changed formats so big indices will print cmo_interpolate implement user option - user must supply user_nterpolation subroutine mega_error, mega_hessian fix allocation of over large tmp array Code Changes cmo_get_info return itype=4 for pointer retrteval control_command_lg echo comments to outx3dgen mm2000 print block in address order rmpoint ﬁx allocations for temp space to use a better estimate of size and integer type if possible. refine_face_add skip call to settets if attribute skip settets is =0 rzbrick3, pset, eset filter, hextotet hybrid, reﬁne, readngptet, readngphex, dump_fehm, extract_interface remove references to ialias mmrelblk comment out warning if block does not exist cel_chain force exclusive for rivara_truncated reﬁnes connect,delaunay change epsilons for point insertion tests statementfunctions.h new function DSZIRTRI caluculates the SIGNED inscribed radius of tri. refine_face_add use cmo_interpolate values for coordinates of new points recon all recon commands processed through subroutine recon, toldamage now computed if not supplied reﬁne We now pass psetname= -def- in the case of 2D with no surface. In this case the entire 2-D grid will be in the ‘pset’ for refinement cer_chain We commented out the RECON after reﬁnement. agd3d We now refrain from merging out nodes if they would create a roughness&gt;0.8*TOLROUGHNESS. getgsynth Initial revision. Computes synthetic normals for ALL nodes in 2-D massage We now take TOLROUGHNESS in the argument list. This is a format change, but old decks should still work.",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V1.0.3.html"
  },{
    "title": "LaGriT V1.100 Release Notes 1999",
    "text": "LaGriT V1.100 Release Notes 1999 This text is converted from old pdf files and may have translation errors. See original pdf for clarification. LaGriT V1.0 May 1999 PDF Version A summary of the major Changes found in this release are listed below. triangulate triangulate a 2D mesh assuming the ordered nodes in the 2D mesh define the perimeter of a polygon ung2avs convert Arclnfo (GIS) Ungenerate files to AVS ung2avs/avs_file_out/ung_file_in/[z_va|ue] deﬁne allows a number to be associated with a character string, such that the character string can be used in input decks in place of the number. define/nx/3 define/ny/4 define/nz/5 define/bottom/O.1/ define/top/4.6 define/left/ -4.7 define/right/9.8 surface/s1/reflect/box/0.0,left.bottom/1.0,right,top colormap This command builds the colormap. In reality it only builds the material adjacency graph, from which the colormap can be quickly generated when needed. Three actions are possible: colormap/[add|create|delete]/[cmo_name] add - The material adjacency characteristics of the specified mesh object is added to the existing material adjacency graph, which is created if it didn‘t exist. This is the default action. create - The existing material adjacency graph is deleted and a new one created from the specified mesh object. delete - The material adjacency graph is deleted if it exists. Any specified mesh object is ignored. Examples: colormap/create/mesh1 colormapl/mesh2 colormap/delete massage added a smoothing operation to the optimization which can be turned off with the nosmooth option massage/creation/annihilation/toldamage//[ifirst,ilast,istride]/[nosmooth] smooth new option aspect will smooth to improve aspect ratio by moving a node toward the neighbor that provides the greatest improvement. New option lpfilter will smooth surface networks (i.e 2D mesh objects or the interface network of a 3D mesh) using a polynomial filter. (filtdeg default 30; k_pb default 0.1) smooth/position/aspectl[ifirst,ilast,istride/toldamage] smooth/position//pfilter/[ifirst,ilast,istride/filtdeg/k_pb] pset new option surface will identify nodes on the specified surface. Keyword surface names have the following meaning: -all- will identify nodes on any surface. -interface- will identify nodes on any interface surface. -boundary- will identify nodes on exterior surfaces. pset/psetname/surface/surface_name/[ifirst,ilast,istride] refine new option roughness will refine based on the distance of the endpoint of an edge to the plane determined by the synthetic normal with respect to a specified surface at the other endpoint of the edge. refine/roughness///edge/ifirst,ilast,istride/ distancelsurface_namelexclusivelinclusive refinelroughnessllledge/1,0,0l.28lptoplinclusive new option edge_list will bisect a set of edges specified by the node numbers of the endpoints of the edges. refine/edge_list///edge/edge_listl refine/edgeilist///edge/1 2 23 47/ will refine the edge with endpoints 1 and 2 also the edge with endpoints 23 and 47. new option interface will bisect a set of non-interface edges of tets all of whose vertices are interface nodes. refine/interface///edge/pset,get,psetname//// [inclusivelexclusive]l extract new option network will extract the network of interfaces (consisting of parent nodes) from a mesh. extractlnetworklifirst,ilast,istride/cmoout/cmoin dump dump/recolor/file_name This command writes the existing colormap to the specified file. (See colormap command.) dump/fehm/file_name / [cmo_name] / [binary/ ascii | asciic | binaryc] /[scalar, vector, both] / [delatt, keepatt] The [delatt, keepatt] option gives the user the ability to delete or keep the boundary attributes, top, bottom, left_w, right_e, back_n, front_s, which are created by dump/fehm. The default is delatt. dump/fehm/file_name / [cmo_name] / [binaryc | asciic] produces compressed matrices dump/gmv/file_name/[cmo_name]/[binary, ascii] specify binary or ascii format of GMV file on command line dump/lagrit/file,name/[cmo_name]/ will write an ascii restart file that contains geometry and mesh object information. cmo_name can be ‘-all-‘ in which case all mesh objects are written to the file or it can specify a list of mesh objects to be written. read read/lagrit/file_name/[cmo_name]/ will read an ascii restart file written by dump/lagrit. All mesh object data is preserved in the file including the cmo_name. connect connect will triangulate a 2d planar set of nodes generating a triangular Delaunay grid. Bug fixes Jan 98 to May 99 multi_material - ﬁxed error for node added that was on both an interface and an exterior boundary might get the wrong itp1 value. connect - refresh pointers alter call to remove bigtet ceL_chain - fix bug with memory allocation for mpary array. massage,getmpary - correctly access pset for massage try2tob - get pointer to icontab correctly cel_chain - Check for psetnames = blank gctbit,sctbit Change declaration of ISHFT to intrinsic ﬂip2t03,ﬂp2t03b, ﬂp2to3i - update itettyp for new element recon2d - use cmo.h (icmoget) to pass to testdamage so it knows If it must refresh pointers dumpavs - close file always before leaving subroutine reﬁne_edge_list_lg - correct pointer statement tangent_plane, cer_chain - ﬁx reﬁne on roughness reﬁne_ﬁx_add - correctly set ier values for added nodes on constrained interfaces sheet - explicitly specify -def— for mesh object name rzbrick - ﬁx ratio ﬁag control_command_lg - correctly remove unnecessary blanks from command lines cmo_create - make interpolation type be ‘and’ for isetwd and xtetwd cmo_interpolate - ﬁx interpolation for isetwd and xtetwd pset - idebug delared as integer rmmat - ﬁx error return ﬂag resetpts - ﬁx error return ﬂag surfset - ﬁx memory management error gctmpary - sct defaults correctly by testing nwds closed_surfaces - ﬁx arguments to getregv2 call reﬁne_edge_add - modify pset membership for new nodes. cmo_select, cmo_get_name - remove null character from end of name recon2d - set itetoff lpﬁlter,LowPassFilterModule - avoid overwiting data Code Improvements Jan 98 to Mar 99 smooth - new option smooth/position/aspect will smooth to improve aspect ratios. smooth, extract - new option smooth/position/lpfilter will smooth surface networks. New extract option extract/network will an interface network from a 3D mesh. pset - New options for surface (surface names: -all-, -interface-, -boundary- have the obvious special meanings) delaunay - Insert nodes in mesh in random order. Replace n**2 a1gorithm to ﬁnd matching faces with a linked list approach reeon2d - changed test to use consistent volume calculation. reﬁne, tangent_plane, cer_chain, reﬁne_edge_list_lg, lpﬁlter, LowPassFilterModule, GmphModule - new command options triangulate_lg, msgtty - add triangulate command pntlimc - check for pset named ‘-def—‘ or empty string corrected warning that showed up on the DEC compile in the following routines: addmesh, addmesh delete, addlnesh pyramid, boundary components, chkreg, chkregv, closed surfaces, cmo_delatt_def, cmo_interpolate, cmo_setatt, cmo_release, connect, correctpc, dereﬁne, dopmat, dumpchad, ﬁlholes, geniee, get_mregions, get_regions, get_surfaces, getreg, getregv, grid_to_grid, hextotet_att, l1n1en1adjb, hsb2seta, ifacept, initx3d, math, occonv, pstatus, readgmv_binary, reﬁne_coupling_coef, reﬁne_edge_add, reﬁne_face, reﬁne_face_add, rmregmn, rmsurf, rwdpmw, r2, search2d, sortbins, taylor_error, translate, volume_tet, voron2d, writedump, refine_edge_list_lg recon2, mega_error - restrict existence of ‘mega’ related attributes to recon loop. change IO disposition to not write to GMV ﬁles refine, refine_interface_elements_lg - new reﬁne option to reﬁne non—intcrface edges of tets, all of whose vertices are interface nodes. dump/fehm, writedump, matbld3d_stor - generate compressed matrix for geometric coefficients .stor file cel_chain, cer_chain, refine_edge_add - set pset membership of child nodes in reﬁne_edge_add_tet reﬁne_edge_add - pset is inherited from ‘anding’ the pset of the endpoints of reﬁned edgeh Code Changes Nov 98 to Apr 99 agd3d massage - add smoothing operation to optimization loop in massage. sgd, primestep - smoothing now automatic in massage, turn it off with ‘nosmooth’ cel_chain - remove call to recon from inside reﬁne/rivara loop. agd3d - allow more merges of nodes that do not have unique successors and predecessors dumpavs - allow for ranksﬂ and limit coordinate range to (—1 16—30, 11e+30) aratio_tet - handle extreme aspect ratio tets correctly agd3d, aratio_tet, aratio_tri - remove assumption that fp errors would not be trapped massage - set ipointi to 1 and ipointj to nnodes intradd - use a more memory efficient al gorithm to create child nodes agd3d - change error to warning when material match in question (skip merge) all common blocks - moved common statements after declarations added ‘save’ statement dump_recolor_lg, neighbor_recolor_lg, writedump - add dump/recolor command (see above) dump - fehm option to keep/delete boundary attributes on fehm ﬁles dump_outside_list ung2avs - option to convert Ungenerate ﬁles to AVS ﬁles dumpgmv_hybrid - read binary/ascii from command line llip3t02, llip4to4, llip2t00, llip3t021 [lip4to4i llip2t00b In[lip recon IceonZ ﬁiplt00, ﬂip2t02, - remove calls to ﬂuxing routines and clean up associated memory usage control_eommand_lg - new method of command processing writloga, writinit, dotask, dotaskx3d, initlagrit, msgtty, control lg.h, lagrith dumpgmvihybrid cmo attribute 7def- is modified so that it Will not be written to gmv files. writcdump,rcaddump dump/lagrit and rcad/lagrit - now write and read ascii geometry files dumpilagrit, eventually this command will also dump the mesh objects dump_lagrit_geom, read_lagrit - read_lagrit_geom cmo_dump_cmo dump/lagrit and read/lagrit - now write and read ascii re start ﬁles cmo_read_dump_cmo - that contain geometry and mesh object intbnnation matbld2dstor - add max connections to output, make consistent with matbld3d_stor eset - don’t print element number of member of set quality - print if idebug set to 1 connect2d_lg - new code to connect 2d planar node distributions into 2d grids delaunay2d_lg, delaunay2d_connect_lg, multi_material2d_lg, fix_small_triangles_lg, make_big_triangle_lg scale_lg, msgtty change subroutine name ‘scale’ to ‘scale_lg’ to avoid conﬂicts with other libraries",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V1.00.html"
  },{
    "title": "LaGriT Release Notes",
    "text": "LaGriT V1.1.0 Release Notes Notes 2002 This text is converted from old pdf files and may have translation errors. See original pdf for clarification. LaGriT V1.1.0 Nov 2002 PDF Release YMP QA/QA STN: 10212-1.1-00 LaGriT V1.0.4 2002 PDF A summary of the major changes found in this release are listed below. A complete list of changes is included at the end of this document. Refer to the user‘s manual for a complete description of the new, enhanced and revised commands. New Commands create_graph Create a node or dual (element) adjacency graph. If node option is selected, the graph of node adjacency is created, if dual option is selected, the graph of element adjacency (dual graph) is created —— see manual for details create_graph/metis/node|dual/ v1,v2/ create|delete metis Interface METIS graph partition and reorder package with LAGriT. http://www-users.cs.umn.edu/~karypis/metis For details of METIS algorithms see: The standard libraries, Iiblagrit.a and Iibutil.a do not contain METIS. In order to utilize the METIS functions, one must download the METIS package, build the METIS libraries on your local system and link them with the LAGriT libraries. For example: f90 -o lagrit driver.f liblagrit.a libmetis.a libutil.a stack stack\\fill stack\\reorder read tri or quad surfaces combine into one cmo and fill with prisms 0r hexes mode mode/discrete/surface_cmo/tolldamage - all refinement smoothing operations on this surface must result in nodes that are members of surface_cmo mode/recon/[delaunaylgeometryladaption] choose reconnection mode - delaunay flip to restore delaunay, geometry will flip to create ‘plump’ elements, adaption will flip to reduce solution error mode/adaption_field/field_name/scale_factor/4d_refine_length/4d_merge_length/4d_damage/percent_to_refine/ error_cut_off_refine if this mode is on adaptive massage will be in effect sethessian sethessian/user - make the 2nd derivative matrix from the routine supplied by the user sethessian/erradpt make the 2nd derivative matrix from the user supplied edge errors sethessian/field_name/[algorithm choice] make the 2nd derivative matrix base on the supplied field and algorithm (default is the mega algorithm) loop loops may be max 10 deep, max 250 tokens in the lforeach/ mode. Implementation involves a define and a dotask issued for each loop command loop/do variable lp_start lp_stop lp_stride loop_end/ loop/foreach variable item1 item2 itemN loop_end/ Examples: loop foreach MO cmo1 cmo2 cmo3 loop_end &amp; cmo / delete / MO loop do NX 2 31 loopiend &amp; loop do NY 4 51 loopiend &amp; loop do NZ 6 7 1 |oop_end &amp; loop foreach X0 0 5.5 10.2345678 |oop_end &amp; createpts/xyz/NX,NY,NZ/XO O. O. / 100. 100. 100. loop foreach FILE file1 file2 file3 loop_end &amp; loop foreach CMO cmo1 cmo2 cmo3 loop_end &amp; infile lagrit_control_file Enhanced Commands refine refine allow eltset,get,eltsetname wherever pset get psetname was previously allowed. math allow more operand types add math/sum and math/integrate math/abs is absolute value option createpts createpts/median creates new mesh object attributes called xmed,ymed and zmed of length nelements and rank scalar. They contain the x,y,z coordinates of the median point of each element in the mesh. All element types are supported sort reorder sort, reorder now sort and reorder elements in addition to nodes Bug Fixes pset_nosb fix problem with geom/xyz writedump ﬁx problem with delatt/keepatt and dmllp/zone read_geometries fix problem if number of surfaces is zero rotatept fix typo surfpts fix problems with ‘surface‘ option cmo_delatt fix error in retrieving cmo name mega3d skip calls involving hessian for smooth/position/geometry option closed_surfaces ﬁx undeﬁned variable dump_pt_by_value, put mega3d_nosb, getiedge, polyfun_nosb.f corrected the prob1em involving the nondistinction of differently colored but coincident edges hextotet_hybrid add error checking, avoid cmo_interpolate bug refine_tet_add get correct cmo name intersect_elements fix incorrect declaration lower_d_lg ﬁxed test for increasing attribute space reﬁne_nosb ﬁx errors in faceedge and tetedge options cmo_addatt_nosb fix type dec1arations mergepts_simplex use epsilon for inversion tests rz ﬁx line mode dump_geometries_lg,geometry_release_lg,read_geometries_lg_nosb allow for mesh object with no geometry refine_edge_2d reset ipointj at end control_command_lg reuse space if names are reused in deﬁne commands Code Changes eset_nosb Fixed multiple calls to eltset so that it behaves like pset(i.e. contents ofa named e1tset reset at each call) cmo_set_mesh_type add error checking cmo_addatt allow permanent or temporary persistence cmo_copyatt allow element attributes to be copied to nodes that are element vertices cmo_set_mesh_type changed subroutine name from cmo_mesh_type cmo_status added ‘brief‘ option cmoiinlerpolate add error checking unpackpc simplify the logic freemove pass in info that determines move gctiedge distinguish between coincident but different matcria1 edges intrp_gtg add tiemat option isosurface set edges per element sethessian, dampiptihyivalue, eva1uateisobolevnorm,hess3d ,interpo1ate7hessi 5111- use sethessian celichain, refineispawnilg, reﬁneicouplingcoeLpopconeng, (:51, cer—chain, eel, popcomponenlsilg use return ﬂag from reﬁneiedgeiadditet to terminate iterations if reﬁne does nothing flip2to3b_nosb, ﬂip2to3, hmemadjb_nosb remove warning message connect_nosb spe11ing error math_sum, math_integrate new options rotatlenln_nosb, rotatept_nosb rotate only coordinates — skip other attributes table_element clean -up distance_to_sheet, testdamage, edgefun_lt, point_to_plane freemove_nosb, mega3d_inner_loop, mega3d_nosb, massage, reﬁne_edge_add, sgd, cee_chain, polyfun_nosb, adg3d, mode_lg, msgtty_nosb changes for adaptive massage and for discrete mode perturb_lg ﬁx calling sequence recon2_nosb sb ﬁx debug 0utput quadxyz,quadxy, read_sheetij format changes extract_surfmesh better error checking partition,reﬁne_edge_3d, addmesh_amr, voronoi_stor, grid_to_orid, addmesh_overlap, addmesh_merge pull routines out of temp.f pset better setting of epsilons for geom option",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V1.1.0.html"
  },{
    "title": "LaGriT Release Notes",
    "text": "LaGriT V1.1 Release Notes Notes 2003 to 2004 This text is converted from old pdf files and may have translation errors. See original pdf for clarification. LaGriT V1.1.2 2004 PDF LaGriT V1.1.1 2003 PDF A summary of the major changes found in this release are listed below. A complete list of changes is included at the end of this document. Refer to the user‘s manual for a complete description of the new, enhanced and revised commands. Enhanced Commands read read/gocad/file_name/mesh_object_name. Read an ascii GoCad TSURF file (2D). read/gocad/file_name/mesh_object_name refine/…amr/iprd Use amr refinement with an optional direction. iprd = 123 refine all hexes. iprd=1 refine along the X direction, iprd=2, refine along the y direction, iprd=12,13,23 refine along x,y; x,z; y,z respectively. For example: refine/constant/imt1/linear/element/1,0,0/ -1.,O.,O./inclusive/amr/12 will refine all hexs in the x and y directions only. geniee/cmoname/2dnormal/reference_element_number [addatt] For 2d meshes only, this option will attempt to make the topological orientation of a triangle, quad or hybrid-triangle- quad mesh consistent so that shared edges are traversed on opposite directions. This will not be possible if more that 2 elements share an edge. reference_element_number is the element that all other elements will be compared to. dump/elem_adj_node/file_name/cmoname Write a list of all elements adjacent to each node to the file fileiname. massage new option semiexclusive. Refinement will be triggered only by edges both of whose endpoints are in the pset. However edges with only one or no nodes in the pset might be refined as a result of ‘Rivara’ refinement Chain. dump/zone_imt output zone list file associted with imt values but do not output outside lists and multi— material connection lists. createpts/itp Add nodes to a mesh object by linear interpolation between two point sets Code Changes ung2avs Changed coordinate arrays to double precision arrays. Modiﬁed formats [or larger numbers. refine_nosb, filter, geniee,refine_get_add Changes related to refine/amr option delaunay2d get rid of n**2 loop (zeroing out ioff) ntrp_gtg increase number of signiﬁcant figures for output. addmesh_append_nosb Added support of maintaining all attribute types (VINT, VDOUBLE, VCAR) for both element based vectors and node based vectors matbld3d_stor Add output of xyz miu/max bounding box of each Voronoi cell. To activate set if_vor_io/2/ mm2000 Added output at the end of mmprint to print out total amount of memory associated With memory managed arrays. Changed format in mmprint to allow larger integers. readgmv_ascii changed format so lhe aseii output can exceed lmﬂlion nodes dumpgmv_hybrid, readgmv_binary recognize amr variables itetpar, itetkid, itetlev as VINT. recon, mode add option to turn off recon rzbrick3 dded options, fixed bugs documented functionality in rzinterp sections of the code. This piece of code is nearly the same as the point interpolation code used in extrude, but since it required a lot of changes to get it working, 1 decided not to touch the code that extrude uses. rz Fixed error that occured when createpts/line was a line aligned With the y or z axis. Error resulted in only cell centered point distributions. Now one can get correct results When ijz=1 and ikz=1. sortbins allow attributes of arbitrary length notjust nnodes or nclemcnts cmo_setatt_nosb use a longer format When printing a real acalar attribute dump_material_list fix format statement radapt initialie ctrl to zero fillholes Skip holes whose number is greater than lhe current nelements value extract_interface do not release cmo if it exists - this lost added attributes recon2_nosb pass iopt2t02 to try4to4xv so as to be able to skip interface recons if desired filter In cases where the specified pset was empty the code would crash due to asking for zero length array. Put in error check to return if pset is empty set. cel_chain initialize flag to zero Bug Fixes extrude Set, ndimensions_geom of new mesh object. pset change format to a32 to print entire pset names. read_sheetij 1ntialize hdrlen to zero so ﬁles With no header are read correctly connect2d got rid 1n**2 loop on resetting ioff shttstv_nosb added explicit lengths to character comparisons (ickin, ickout) cel_chain Fix truncated option refine_edge_list_lg ityp=itettyp(it) was not being set correctly addmesh_nosb Fixed bug in VCHAR type element attribute cmo_copyatt_nosb Allow copy ot’node attribute to element attribute and Vice versa only if have the same length. readgmv_ascii fix problem With type ‘lin’ refine_tet_add Return gracefully if nadd=0. eset Bug in exclusive/pset_get_name Bug resulted inincorrect result except in the case of tet’s or quads. Fixed for all element types now. matbld1 changed order in Which work arrays are allocated and released so that they only exist when they are really needed. Changed the way row/column index pointers are sorted. 01d method used a trick, but the tliek fails when the number of nodes get larger than O(10**7). Change to use of a multi—key sort of the isortr and isortc arrays. Added some output to log ﬁles.",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V1.1.2.html"
  },{
    "title": "LaGriT V1.1.3 and V1.1.4 Release Notes 2005",
    "text": "LaGriT V1.1.3 and V1.1.4 Release Notes 2005 This combines notes for development work June 2005 and November 2005. These notes are converted from old pdf files and may contain translation mistakes. See the original pdf for clarification. LaGriT V1.1.4 November 2005 PDF Version LaGriT V1.1.3 June 2005 PDF Version A summary of the major changes found in this release are listed below. A complete list of changes is included at the end of this document. Refer to the user manual for a complete description of the new, enhanced and revised commands. New Commands: fset fset/f1/pset,get,p1 face sets are defined as faces belonging to the elements corresponding to pointsets where the face is on the boundary. In other words, face sets become entities for applying boundary conditions. Enhanced Commands: dump/avs Added avs2 option witch will output node and element attributes as real or integer. avs option outputs all node and element attributes as real. Code will test the max(abs(attribute)) and format integers to use only as many columns as are needed. cmo cmo_command_nosb.f added fillatt option that avoids warnings for attributes that already exist and allows the attribute to be filled dump dump material_list.f added argument iselect to subroutine call that allows the user to choose a single selected zone value and corrected code to finish writing zone file if no materials are found. dump dumpfehm writedump_nosb added argument imat_select to dump_marerial_list call that enables a single zone to be selected added option for geoFEST output dump/geofest calc_rdist msgtty added option to call calc_rdist. math math_nosb added min, max options connect multi_material_nosb add option to test all interface edges if a material interface is crossed. connect/check_interface massage massage add norecon option that turns off all calls to the reconnection routines. filter filter_elem_graph mark and optionally delete duplicate elements msgtty_nosb filter/element Code Changes: 02/28/05 intersect elements intrp_gtg 10/12/05 dumpavs_nosb changes needed for avs2 option. writedump_nosb 10/18/05 readavs extend input file name to 132 characters fix error if number of nodes = 0 and number of elements not zero readdump, extend input file name to 132 characters readx3d_att, readnurbs_iges_grid, read_sheetij, read_gocad_tsurf 10/26/05 math_sum added significant figures and put name of attribute on output line. Bug Fixes: 07/22/04 dumpgmv_hybrid_nosb readgmv_ascii_nosb 02/28/05 pset_nosb 04/06/05 dumpgmv_hybrid_nosb implicit none and added code to report progress of the element search. associate imt and others with imtl type names Insert code to invert connectivity so that tet and hex are not inside out. Also added simdate and codename keyword to header of ascii GMV files. These keywords are used in the read/gmv code now to detect the new corrected connectivity Insert code to invert connectivity so that tet and hex are not inside out. Also added simdate and codename keyword to header of ascii GMV files. These keywords are used in the read/gmv code now to detect the new corrected connectivity added imask to shiftr for union of more than one set, fixed logic so that names that start the same will be treated as different, e.g. imtl imtl temp fixed bug introduced by inversion of connectivity when outputting tet or hex elements. 10/03/05 dumpgmv_hybrid_nosb Distinguish between node and element attributes by checking clen of the attribute. 10/12/05 tritri.f Added implicit none and declared logmess correctly. 10/12/05 intersect_elements.f Minor changes to log messages. 11/02/05 translate Avoid crashing if mesh has no nodes. 11/03/05 do_extract_nosb Fix definition of d in ptnorm option 11/03/05 dumpavs_nosb Handles mesh with only element attributes and fixed formats so they are long enough for num elements, num nodes. 03/06/06 isosurface Fixed problem with the case where no elements were created. For example in the case where a plane is extracted from a 3D object but the plane does not intersect the 3D object anywhere. In that case a new mesh object was created that was 2*nnodes and 2*nelementsof the input mesh object but there was nothing in the output mesh object. Now the output mesh object is created but nnodes=nelements=0.",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V1.1.4.html"
  },{
    "title": "LaGriT V2 Release Notes",
    "text": "V2.002 2008 to V2.2 2010 This covers work from 2008 to 2010 and includes V2.2 major release before changing all code to support 64 bit. Version notes start at latest first, older versions at end of this page. Version 2.2 Release November 2010 * * Program: LaGriT V2.200 Linux m32 * * * date_compile: 2010/11/22 * Enhancements: interpolate Changed interpolate to “find” more points on edges this will permit nodes to find a nearest edge or point and be “inside” the triangle for extreme small or large numbers where epsilon values are difficult to evaluate correctly. Note, this changed test results for interpolate, test/level01 results were updated for these improvements. extract/surfmesh Now creates attributes to hold element local face numbers of 3D input mesh that occur on either side of output mesh face, idface0 and idface1. Now copies user-created node-based attributes from source. dump/fehm dump/zone_outside Changed FEHM outside area to Voronoi instead of Median FEHM file file_name_outside.area changed to file_name_outside_vor.area For dump/zone, added keywords keepatt_area or keepatt_voronoi which will compute and keep voronoi vector areas xn_varea, yn_varea, zn_varea and keepatt_median will compute area/num nodes on face and keep attributes xn_area, yn_area, zn_area The written file file_name_outside_vor.area or file_name_outside_med.area is a list of 2D area vectors (Ax_i,Ay_i,Az_i) associated with each node. cmo/addatt/voronoi_varea will do the same voronoi calculation on triangles as is done with the outside area for FEHM modeling files. The call will create node attributes xn_varea, yn_varea, zn_varea indicating face directions. dump/ filename 2 token dump for common files added to writedump.f addmesh/ excavate remove nodes and elements if they fall with the circumsphere of triangles on the input mesh. These issues were fixed: intrp_gtg.f A bug was fixed in interpolation that would sometimes save a node id in pt_gtg or el_gtg attributes that was not related to the found candidate and value. This could occur where there are multiple candidates for the source and if epsilon values are reaching near machine limits. The test in level01/intrp_2D_sizes was changed to capture and evaluate these issues. epsilon errors in intrp_gtg.f, inside_lg.f There are changes to interpolate using tests for finding points that are inside or on edges or vertices of an element. The epsilon tests have been relaxed to allow points that are “near” to be found on edge - if within the chosen epsilon. The interpolation has been changed to evaluate candidate points based on the confidence of being inside the associated triangle. A result indicating the point is inside will “win” over a candidate result that is on edge or vertice. If idebug attribute is set to a number of 5 or greater, there will be many more statements written that are related to the inside triangle and epsilon tests. Version 2.106 6/29/2010 This version contains the work done over the summer by Aaron Gable. Better handling of errors and segmentation faults were added to various pieces of the code having to do with actions involving more than one mesh object and their user defined attributes. Enhancements memory New options to print and check memory manager and report memory usage. This superseeds old utilities mmprint, mmcheck, etc. read for 3 tokens for .inp .gmv .avs cmo/attribute_union Change two meshes so they both share the same set of attributes compute / linear_transform extrapolation from an attribute value in a surface onto every node of a 3D mesh compute/signed_distance_field to calculate signed distance relative to above and below. grid2grid wrapper for hextotet. can also convert from octree mesh to lagrit with tree_to_fe anothermatbld3d_wrapper.f Create two new node vectors, ccoef, ij_ccoef Put the negative ij coefficient value into the two nodes connected to the ij edge. The vector ij_coef will assign the j index value to node i so that one can determine which edge is associated with the neative coefficient that is assigned to nodes. Add option to pset/ / zone for user specified zone id number These issues were fixed: Modified epsilons in tri2d, fixed bug in foreach part of loop anothermatbld3d.c possible accuracy improvement using Carl’s changes to include TranslateTetToZero for geometric calculations Version 2.1 Release August 2009 This is a major update to LaGriT and the lg_util library. Major changes have been made in the core memory management routines to allow development for a 64 bit release. These changes will be invisible to most users but allows better reporting of errors and memory usage for useful diagnostic information. * * Program: LaGriT V2.100 Linux m32 * * * date_compile: 2009/08/03 * Code Enhancements: Executable build for Mac with Intel chip New capability in compute module to compute signed distance fields Incorporate METIS source code for graph partition and reorder package with LaGriT. For details of METIS algorithms and descriptions of the third command line argument see http://glaros.dtc.umn.edu/gkhome/views/metis Add option to create node attribute that is the Voronoi volume associated with each node of a Delaunay mesh Module addmesh modified to handle errors so that it can be used in a loop without needing to have first call be different Updates stor file commands so default uses newest version of code to build sparse matrix. This uses less memory and takes less time to build. New syntax options for stor file compression include all (default), graph, coefs, or none. Initialize list pointers to null assign null to pointers after free add warning messages for failure to free. initlagrit.f add call to mmverify the new util version checks for correct pointer sizes cmo addatt vor_volume added which calls anothermatbld3d_wrapper to fill voronoi volumes dumpfehm.f Add compress_opt to dumpfehm arguments add comments and error checking to clarify code logic check options and set for 2D or 3D calls to matbld use matbld3d_stor for compress options none and coefs use anothermatbld3d_wrapper for compress options all and graph Note anothermatbld3d_wrapper can write only scalar coef values anothermatbld3d_wrapper.f Extensive chages to error handling and messages, but not to the logic of program This code has same logic as matbld3d - but uses linked lists instead of mmgetblk calls Use io_type to toggle creation of attribute for voronoi volumes or to write to stor file added extensive error checking to eliminate segmentation faults added error check and message for every mmgetblk and mmrelblk added calls to mmprint when mm calls fail cleaned up variable declarations and added comments added istatus to check for errors and completion of matrix changed all routine messages to start with AMatbld3d_stor to distinguish from matrix built with Matbld3d_stor added idebug options added status report at end of routine matbld3d_stor.f Extensive chages to error handling and messages, but not to the logic of program This code uses many mmgetblk calls and about 40 percent more memory than linked list version added extensive error checking to eliminate segmentation faults added error check and message for every mmgetblk and mmrelblk added calls to mmprint when mm calls fail cleaned up variable declarations and added comments added istatus to check for errors and completion of matrix added idebug options added status report at end of routine matbld1.f This routine is called by matbld3d_stor added error check and message for every mmgetblk and mmrelblk added calls to mmprint when mm calls fail These issues were fixed: readatt not working correctly for psets blockcom.h fix for compile on MAC OS X Absoft on intel comment out ntetmax/0/ and let compiler initialize because we have 2 instances of pointer sizes. See kfix and xfix in neibor.h Version 2.004 10/21/2008 Code Enhancements: resetpts bug fix, boundary_components and extract_surfmesh added features boundary_components: added id_numb boundary index number extract_surfmesh: added attributes idelem0, idelem1, idnode0 and removed attribute map- Made changes so that filter and rmmat return with no action rather than crash when passed an empty mesh object. Add options dump/att_node and dump/att_elem Add options dump/att_node and dump/att_elem to output tables of either node attributes or element attributes to ascii files with header lines beginning with character #. These are similar to dump/avs/file/mo/0 0 2 0 or dump/avs/file/mo/0 0 0 2 except the addition of # character to start lines. Now these files can be read in without editing using cmo / readatt / workflow. Added character # for comment lines These issues were fixed: resetpts had a bug for some element types Corrected bug: cmo_exist returned error flag but check of error flag was to wrong error flag variable. Made changes so that filter and rmmat return with no action rather than crash when passed an empty mesh object. Version 2.003 05/20/08 Compile and test V2.003 for platforms SGI-32, SUN, MAC, LINUX These issues were fixed: These include fixes to SGI compile errors in dumpavs.f filter.f refine_tet_add.f lagrit*.h writinit.f and the Makefile in src Correct minor bugs. Test case now works. sphere1.f had an incorrect attempt to use MO name before the name had been obtained. Code would crash. offsetsurf.f did not handle problems with non-triangle or line type MO. Instead of kicking out, an attempt was made to compute sythetic normal for a mesh object (such as quad) and this caused code to crash. Fixed error that occured when all output attributes were turned off. Fixed error that occured when all output attributes were turned off. Code tried to allocate a zero length array for xvalues( ). Version 2.002 Release April 2008 Improved check_test.py to compare numbers as numerical values instead of text string. The new results are saved in result_files Generalized version Makefile and dependencies Uses wildcards for .f .f90 and .c maintains object files in seperate directories for each platform and for debug and optimized use make help for list of options added options opt and debug as build choices Initialize nremtet and npoints2 to 0, initialize number_elements and number_nodes to zero Modify output for Dudded points to indicate when there are no elements (for removal) Changed name from ‘program adrivgen’ to ‘program lagrit_main’ Modified header correcting spelling, changed X3D to LaGriT. Enhancements Add capability to read FEHM zone/zonn files. These issues were fixed: corrected change to printatt minmax output so that name has 18 characters, with total line of 80 chars for cmo_setatt.f added error check for existing cmo and expanded name string size for 17 character names for cmo/printatt/ minmax limited format to 80 characters Corrected typo in screen output. Changed ‘nnelements’ to ‘nelements’ Changed some memory allocation from real(2) to int(1) for integer work arrays. Running a large problem (&gt;10,000,000 nodes) was crashing at rmpoint due to MALLOC failure. changesets were tracked with Mecurial/Trac 0.10.4 on ancho.lanl.gov/lagrit/hg/lagrit",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V2.002.html"
  },{
    "title": "LaGriT Release Notes V3.1",
    "text": "LaGriT V3.108 July 2016 The was the Last version released under Open Distribution license LA-CC-2012-084 before Open Source. This code was tagged in Mercurial as V3.108 and used to start open-source repository on github. This includes work by summer student Mikita Yankouski with WIN development using Cygwin. Added top level python control suite, and standarized level02 output files. See instructions.txt and cmake-script. Files changed for WIN are opsys.h and type_sizes.h to account for win64 and changed define for SIZEOF_LONG file: opsys.h #ifdef win64 #define FCV_UNDERSCORE #define SIZEOF_INT 4 #define SIZEOF_LONG 8 #define SIZEOF_VOIDP 8 #define MAX_UINT 18446744073709551615.00 #endif #ifdef win64 #define int_ptrsize long long file: type_sizes.h #ifdef __CYGWIN__ #define FCV_UNDERSCORE #define SIZEOF_INT 4 #define SIZEOF_LONG 4 #define SIZEOF_VOIDP 8 #endif file: machine_header.h #ifdef win64 #define FCV_UNDERSCORE #define SIZEOF_INT 4 #define SIZEOF_LONG 8 #define SIZEOF_VOIDP 8 #endif file: Makefile ifeq ($(COMPILER), cygwin) SUFFC = _cygwin FC = /bin/gfortran CC = /bin/gcc CXX = /bin/c++ FC90 = /bin/gfortran OSTAG = _cygwin FFLAGS = -fcray-pointer -fdefault-integer-8 -m64 -Dwin64 FF90FLAGS = -fcray-pointer -fdefault-integer-8 -m64 -Dwin64 CFLAGS = -m64 -Dwin64 LaGriT V3.106 August 2015 Major update to write PFLOTRAN type option stor file and new syntax using Exodus II 6.9 libraries. Note: The LaGriT run-time banner shows V3.2 with compile date Aug 2015, even though it is actually a branch from V3.106. Enhancements: dump / pflotran Writes .uge file for pflotran and is used by the DFN suite of scripts. The deve directory is in /n/swdev/LAGRIT/work/pflotran. The syntax looks like: dump / pflotran / root_name / cmo_name dump / pflotran / root_name / cmo_name / nofilter_zero dump / exo calls ExodusII new routines changed from V5 to V6. LaGriT command syntax is unchanged. http://sourceforge.net/projects/exodusii/files/ Exodus II 6.09 HDF5 version 1.8.6 netcdf-4.1.3 exo block id modified to input digit instead of digit0000. All exodus files are same as Exodus II 5, except for the block id. Tests have been updated resulting in the following differences: Exodus 6.09: &lt; :api_version = 6.09f ; &lt; :version = 6.09f ; --- &lt; eb_prop1 = 1, 2, 3 ; Exodus 5.22a: :api_version = 5.22f ; :version = 5.22f ; --- eb_prop1 = 10000, 20000, 30000 ; compress_eps new cmo attribute for stor file allowing user to extend range of ccoef values by setting mesh attribute compress_eps (from default 1e-8). Changing value of compress_epsilon seemed to help loss of coeffs with large aspect ratios. These issues were fixed: dump / stor corrected bug for 2D grids that overwrite volic with incorrect value if grid is non-planer. dump / fehm add space between ns and nelements, increase to i12 read / fehm fixed seg fault for 0 elem report message by using a,a instead of a in write format. build ExodusII6 libraries The following issue was fixed when building static libraries with exodus: These are the external libs used with LaGriT V3.1 As of November 2012 http://sourceforge.net/projects/exodusii/files/ Exodus II 5.22a HDF5 version 1.8.6 netcdf-4.1.3 Error in Library inclusion order in the following places: 1. /n/swdev/src/exodusii/exodus-6.09/exodus/cbind/CMakeList.txt Line 284 2. /n/swdev/src/exodusoo/exodus-6.09/exodus/forbind/CMakeList.txt Line 62 Solution was to switch ${HDF5_LIBRARY with ${HDF5HL_LIBRARY Linux RHEL Exodus 5 libraries were built in /n/swdev/LAGRIT/VERS_3.100_012_NOV09/build_lagrit/exodus Build executable for linux: gfortran -O -Dlinx64 -static -fcray-pointer -fdefault-integer-8 -fno-sign-zero -o mylagrit lagrit_main.o lagrit_fdate.o lagrit_lin64_o_gf4.5.a /n/swdev/LAGRIT/VERS_3.100_012_NOV09/build_lagrit/lg_util/lib/util_lin64_o_gfort4.5.a -L /n/swdev/LAGRIT/VERS_3.100_012_NOV09/build_lagrit/exodus/lin64/lib -lexoIIv2for -lexodus -lnetcdf -lhdf5_hl -lhdf5 -lz -lm -lstdc++ LaGriT V3.101 November 2013 Note for DFNWorks applications using LaGriT, this version does NOT have the PFLOTRAN file option. This version of code uses ExodusII 5 routine calls. These are replaced with ExodusII 6 in newer versions. V3.103 is last version lagrit code using Exodus 5 libs V3.104 is new version lagrit code using Exodus 6 libs Enhancements: read / zone or zone_element added option zone_element which allows reading of node or element list in FEHM zone or zonn format. Each node or element number found in the list has attribute tagged. These issues were fixed: addatt/mo_tri / unit_area_normal fixed incorrect zero result and fixed attribute handling so vector array is formed using irank = 3. cmo/addatt/ mo/ area_normal/xyz/ Result is off by factor of 2, fixed area normal to assign half the cross product (for triangles). synth_norm fixed handling of attributes. The synthetic normals were creating a dummy attribute not used because offsetsurf is creating x_n_norm y_n_norm z_n_norm on the input cmo. Attribute names are ignored on the command line, added better reporting for this. LaGriT V3.100 November 2012 Major changes to most parts of the code to enable 64 bit compilation and added external ExodusII 5 libraries to write Exodus basic mesh files. This includes work by Quan Bui for ExodusII node sets and element sets. Enhancements: dump / exo Now includes netcdf and exodus libs for writing exodus mesh files and reading and writing facesets. Syntax: dump / exo / ifile / cmoname Dump exodus files with/without facesets, fast/slow options: dump / exo / ifile / cmoname / facesets / on dump / exo / ifile / cmoname / facesets / off dump / exo / ifile / cmoname / facesets / on file1,file2,...filen dump / exo / ifile / cmoname / facesets / off file1,file2,...filen write exo pset and eltsets: dump / exo / filenam.exo / cmoname / psets / eltsets / dump/exo/mesh_07.exo/mo7//eltsets/ &amp; facesets bc01.faceset &amp; bc02.faceset bc03.faceset bc04.faceset &amp; bc05.faceset bc08.faceset bc09.faceset dump/exo/mesh_06.exo/mo6/psets// &amp; facesets bc01.faceset &amp; bc02.faceset bc03.faceset bc04.faceset &amp; bc05.faceset bc08.faceset bc09.faceset dump 3 token short syntax for dump (avs,gmv,lg,lagrit,ts,exo) extract/surfmesh Now creates attributes to hold element local face numbers of 3D input mesh that occur on either side of output mesh face, idface0 and idface1. Now copies user-created node-based attributes from source. interpolate Changed interpolate to “find” more points on edges this will permit nodes to find a nearest edge or point and be “inside” the triangle for extreme small or large numbers where epsilon values are difficult to evaluate correctly. massage Added option for massage to refine based on an attribute field. Syntax: massage / [bisection length/field name] / merge_length / toldamage / ... massage2 Under development massage2 syntax for incremental refinement strategies. Syntax: massage2/ [file name] / [Target Length Scale]/[field name]/ &amp; merge_length/toldamage/[tolroughness]/[ifirst,ilast,istride]/ ... math add modulo and mod options recon Code improvements related to recon 0 and recon 1 will result in slightly different but better connectivity results. sort Added line sort by nodes or elements for creating valid polygons that can be read and used by other routines. Syntax: sort / line_graph / cmo / ascending descending / [key] / [nodes/elements] These issues were fixed: cmo/copyatt fix copy from node attribute to elem attribute of equal length cmo/readatt fix to allow character in first position which will be skipped minor fixes related to 64 bit code changes. Improved error catching for common routines. Changesets tracked in Mercurial/Trac on ancho.lanl.gov/lagrit",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V3.100.html"
  },{
    "title": "LANL LaGriT",
    "text": "Lasetup lasetup is a user interface for reading or creating, and writing, the geometry portions of LaGriT input files. The advantage that LaGriTsetup gives you is that you can see what you are creating, thus avoiding mistakes, and it can save you from a certain amount of tedious typing. lasetup deals with the LaGriT surface, region, and mregion commands only. lasetup uses the OpenGL and Motif graphics libraries. You will not be able to use lasetup unless these libraries are installed on your workstation. You will also need a 24-bit TrueColor visual, preferably double buffered, available on your machine. You can find out what is available by running xdpyinfo. Also the X server must be running the GLX extension. Extensions are listed near the top of the output of xdpyinfo. lasetup Requirements lasetup User’s Manual(ps) lasetup User’s Manual(pdf) Download lasetupsgi Download lasetupsolaris Download lasetuplinux Questions may be directed to: John Fowler at jxf@lanl.gov",
    "tags": "",
    "url": "/pages/lasetup.html"
  },{
    "title": "LaGriT Licensing",
    "text": "LaGriT Open Source LaGriT V3 LA-CC-15-069 is distributed as open-source software under a BSD 3-Clause License (See below). The Github repository includes source code, compile instructions, and tests for both LaGriT and PyLaGriT. External collaborators are welcome to particpate, see the contributor agreement in the repo. It also includes a snapshot of this site, lagrit.lanl.gov. git clone https://github.com/lanl/LaGriT The following external Exodus II libraries are used with the LaGriT build. For Questions regarding these libraries, contact Greg Sjaardema at Sandia National Laboratories (gdsjaar@sandia.gov). ExodusII 6 HDF5 NetCDF4.3 zlib-1.2.8 License (BSD) LANL Software: LA-CC-15-069 No. C15097 This software is open source available under the BSD-3 license. Copyright (c) 2016. Triad National Security, LLC. All rights reserved. This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy/National Nuclear Security Administration. All rights in the program are reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear Security Administration. The Government is granted for itself and others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare derivative works, distribute copies to the public, perform publicly and display publicly, and to permit others to do so. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Triad National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY TRIAD NATIONAL SECURITY, LLC AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TRIAD NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
    "tags": "",
    "url": "/pages/licensing.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#EXECUTABLE) “30” “30”](example.md) INCLUDE FILES FOR MSTKLA ** #include “mstkla.h”            with the addition of **-I/home/rao/meshing/mstkla/1.0/include in the link line ** #include “gmtkla.h”            with the addition of **-I/home/rao/meshing/mstkla/1.0/include in the link line ** #include “utilities.h”           with the addition of **-I/home/rao/utilities/1.0/include in the link line ** #include “macros.h”            with the addition of **-I/home/rao/meshing/mstkla/1.0/include in the link line   Linking with MSTKLA   MSTKLA (and the embedded GMTKLA) are in the following libs: /home/rao/develop/meshing/mstkla/1.0/lib/ $ARCHOS/ where ** $ARCHOS** is a variable that combines the architecture and operating system info. You can have it set in your Makefile by appropriately calling the script /home/rao/bin/getarch (See the Makefile in /home/rao/develop/meshing/test) The libraries are libmstk.a (debug version) and libmstk-O.a (optimized version) MSTKLA also uses 2 other modules called ‘clagrit’ and ‘utilities’. The libs for clagrit  are in /home/rao/develop/meshing/clagrit/1.0/lib/ $ARCHOS/ The libs are libclagrit.a (debug) and libclagrit-O.a (optimized).   The libs for utilities are in /home/rao/develop/utilities/1.0/lib/ $ARCHOS/ and the libs are libutilities.a (debug) and libutilities-O.a (optimized) Also, the standard lagrit and util libs have to be included. They are located in /pvcs.config/t3d/bin The libs are liblagrit_ $ARCH.a, libutil_ $ARCH.a (debug) and liblagrit_ $ARCH_opt.a, libutil_ $ARCH_opt.a (optimized). Here, ** $ARCH** is as follows:     Solaris:     sol     HP:           hp     DEC:        dec     SGI:          sgi     SGI/64:     sgi_64     IBM:         ibm The order of libraries that works while linking (until more complicated library interdependencies creep in) is   **-L $(MSTKLA_LIBDIR) -lmstkla -L $(CLAGRIT_LIBDIR) -lclagrit ** **-L $(MYUTIL_LIBDIR)  -lutilities ** **-L $(LAGRIT_LIBDIR) -llagrit_ $(ARCH)  -L $(CLAGRIT_LIBDIR) -lclagrit ** **-L $(UTIL_LIBDIR) -lutil ** -lm    “30” “30”](mstkla.md#EXECUTABLE) “30” “30”](utilities.md)",
    "tags": "",
    "url": "/pages/mstkla/linking.html"
  },{
    "title": "loop",
    "text": "loop   The loop command repeatedly executes any LaGriT command with either a do loop type or foreach type variable argument control. The coomand supports loops up to 10 deep with a maximum of 250 tokens in the foreach list.   SYNTAX loop/ do / variable / loop_start / loop_stop / loop_stride/ loop_end / LaGriT_command loop/ foreach / variable / list_var1 list_var2 ... list_varN / loop_end / LaGriT_command do or foreach are keywords that determine the type of loop operation. variable is a character string that can be used in the LaGriT_command. The variable values are controled by the loop range or given in a variable list. loop_start / loop_stop / loop_stride Integers that specify the initial, limit, and increment of variable. variable / list_var1 list_var2 … list_varN Integers, reals or characters that are substituted into variable prior to each execution of the LaGriT_command. loop_end Required keyword string to terminate a foreach list. It is also REQUIRED after loop_stride. LaGriT_command Any valid LaGriT command including another loop command.   EXAMPLES loop / foreach / MO / cmo1 cmo2 cmo3 / loop_end / cmo / delete / MO Delete a list of mesh objects. loop / foreach / FILE / file1 file2 file3 / loop_end &amp; loop / foreach / MO / cmo1 cmo2 cmo3 / loop_end &amp; infile LaGriT.input_control_file   Execute a set of commands in a LaGriT control file that utilize the variables FILE and MO. loop/ do / NX 2 3 1 / loop_end &amp; loop/ do / NY 4 5 1 / loop_end &amp; loop/ do / NZ 6 7 1 / loop_end &amp; loop/ foreach / X0 0 5.5 10.23678 / loop_end &amp; createpts/xyz/NX,NY,NZ/X0 0. 0. / 100. 100. 100. Execute a set of commands in a LaGriT control file that utilize the variables NX,NY,NZ,X0. loop / foreach / MO cmo1 cmo2 cmo3 / loop_end &amp; loop / foreach / ATTRIBUTE / icr isn itp / loop_end &amp; cmo/modatt/MO/ATTRIBUTE/ioflag/l   Modify IO flags of three attributes in three different mesh objects.",
    "tags": "loop, do, foreach",
    "url": "/pages/docs/commands/loop.html"
  },{
    "title": "LOWER_D",
    "text": "LOWER_D These commands are advised for expert users only. This suite of commands creates and handles the lower dimension structures associated with a mesh.  The existing mesh is labeled ‘d0’.  The next lower dimension mesh ‘d1’ and so on.  For an original 3D mesh, the d1 structures are the surfaces (2D) separating material regions, the d2 structures are the lines separating the d1 surfaces and the d3 structures are the nodes at the ends of the d2 lines. ## SYNTAX lower_d / filter / [cmo_name] /[iclr1 itp imt ] / value [ and or new ] create lower_d structures in mesh object lower_d / create/ [cmo_name] release lower_d structures lower_d / release/ [cmo_name] create lower_d structures into named mesh objects cmo1, cmo2, cmo3 lower_d / extract/ [cmo_name/cmo1/cmo2/cmo2] Several new attributes are created which belong the original mesh object:   name type length d0_nnodes_topo VINT, nnodes 0 = interior, 1 = surface, node 2 = line node, 3 = line end node d1_nnodes INT, scalar number of nodes in this structure d1_elements INT, scalar number of elements in this structure d1_nef_cmo INT, scalar number of facets/element in this structure d1_nee_cmo INT, scalar number of edges/element in this structure d1_nen_cmo INT, scalar number of nodes/element in this structure d1_jtet_cycle_max INT, scalar the longest jtet cycle in this structure d1_itettyp VINT d1_elements element type d1_itetclr VINT d1_elements element selection number d1_itet off VINT d1_elements offset to d1_itet d1_jtet off VINT d1_elements offset to d1_jtet d1_itet VINT d1_elements list of nodes for each xd1_neu_cmo element d1_jtet VINT d1_elements list of face neighbors xd1_nef_cmo d1_elm_d0 VINT d1_elements   elements face # in original mesh that this element came from d2_nnodes INT, scalar number of nodes in this structure d2_elements INT, scalar number of elements in this structure d2_nef_cmo INT, scalar number of facets/element in this structure d2_nee_cmo INT, scalar number of edges/element in this structure d3_nen_cmo INT, scalar number of nodes/element in this structure d2_jtet_cycle_max INT, scalar the longest jtet cycle in this structure d2_itettyp VINT d2_elements element type d2_itetclr VINT d2_elements element material number d2_itet off VINT d2_elements offset to d2_itet d2_jtet off VINT d2_elements offset to d2_jtet d2_itet VINT d2_elements list of nodes for each xd2_neu_cmo element d2_jtet VINT d2_elements list of face neighbors xd2_nef_cmo d2_elm_d1 VINT d2_elements element &amp; face that this element came from in next higher level structure d3_nnodes INT, scalar number of nodes in this structure lower_d_flag INT, scalar 0= no lower d structure exist =1 lower_d structures exist and are valid =2 lower_d structures not valid The above set of attributes are created if the original mesh is 3D. If the original mesh is 2D then the d1 structures are created, but the d2 structures are simply the d2_nnodes.  If the original mesh is 1D, then only the d1_nnodes structure is created. At the time the lower_d structures are created color table attributes: d0_clrtab, d0_nclrs, .. are also created.",
    "tags": "lower_d",
    "url": "/pages/docs/commands/lower_d.html"
  },{
    "title": "EXTRACT/SURFMESH DEMO",
    "text": "DEMO extract/surfmesh For syntax and description see EXTRACT_SURFMESH. For usage with ExodusII files see DUMP EXO. This demonstrates the difference between extracting all interfaces and boundaries and extracting external boundaries only. The LaGriT input and output report file are included below.       Input Hex Mesh surfmesh all surfmesh external Hex mesh colored by itetclr material, nodes show itp values (clip front) extract all boundaries and interfaces, color by itetclr1 (clip front) extract external boundaries only, color by itetclr1 (clip front) Demo Description The first image shows the input hex mesh with 2 materials, one internal interface, and a simple box shaped boundary. The interface and boundary nodes are tagged with the appropriate itp values. See more about mesh object attributes at Mesh Object. The itp values are shown in the image as round points: 0 (dark blue) internal nodes 2 (light blue) internal nodes on the interface between materials 10 (yellow) outside boundary nodes 12 (red) outside boundary nodes on the interface between materials The middle image shows the quad surface extracted from the hex mesh with the default option of all boundaries and interfaces. The third image shows the quad surface extracted from the hex mesh with the option external which ignores internal interfaces. Only the external boundary surface is created. The surface element type will depend on the element face being extracted, a hex element will produce a quad surface, a tet element will produce a tri surface. New mesh object attributes are added to the output mesh. Use commands cmo/status and cmo/printatt to see these attributes. The output from these commands are included in the example LaGriT input and output below. Added Mesh Object Attributes Six new element attributes and one node attribute, are added to the output mesh object. itetclr0 and itetclr1 material colors (itetclr) of each side of the extracted surface. 0 indicates a face on the boundary. idelem0 and idelem1 element number on each side of the extracted surface. idface0 and idface1 the local face number for each element on either side of the extracted surface. A tet will have 4 faces and a hex will have 6 faces. facecol is a model face number constructed from the itetclr0 and itetclr1 attributes and is not guaranteed that the same facecol value will not be given to two disjoint patches of mesh faces. idnode0 provides the mapping from nodes in the extracted interface network to (parent) nodes in the input mesh object; that is, IDNODE0(J) is the parent node in the input mesh object that corresponds to node J in the output mesh object.         itetclr0 itetclr1 idface0 idface1 between 0 and max material number between 1 and max material number between 0 and 6 between 1 and 6 Convert Quad Surface to Tri Surface This demo uses the grid2grid command to convert each quad element to 2 triangles each. Some of the extracted quad mesh objects will no longer have values that make sense, particularly the itetclr0, idface0 etc attributes that have values from the oritinal hex mesh. These attributes can be removed with the cmo/DELATT/ command. After the triangle mesh is created, we can set the materials based on normals in 6 directions. This is a quick way to check that triangles have outward pointing normals. Use the command settets/normal. Note: after quad elements are split into tri elements, the extract/surfmesh attributes no longer apply.     convert quad to tri settets normal external quads to 2 triangles each (clip front) triangles colored by 6 normal directions (exploded view) LaGriT command file: ex_extract_surfmesh.lgi.txt LaGriT output report: ex_extract_surfmesh.out.txt LaGriT command file: # CREATE hex mesh define MO_MESH mo_hex define/R0/ 0.0 define/Z0/ 0.0 define/R1/ 10.0 define/Z1/ 8.0 define/ND/ 11 define/NZ/ 9 cmo / create / MO_MESH / / / hex createpts/brick/xyz/ND ND NZ/R0 R0 Z0/R1 R1 Z1/1 1 1 # COLOR elements material 1 and material 2 pset/p2/attribute xic/1,0,0/ gt 6. eltset/e2/ inclusive pset,get,p2 cmo / setatt / MO_MESH / itetclr 1 cmo / setatt / MO_MESH / itetclr eltset,get,e2 2 # SET BOUNDARIES AND INTERFACES resetpts/itp dump/avs/box.inp/ MO_MESH # EXTRACT ALL EXTERNAL AND INTERFACE BOUNDARIES # Set material itetclr to attribute itetclr1 extract/surfmesh/1,0,0/ mos_all / MO_MESH cmo/copyatt/ mos_all mos_all / itetclr itetclr1 # EXTRACT EXTERNAL ONLY # Set material itetclr to attribute itetclr1 extract/surfmesh/1,0,0/ mos_ext / MO_MESH / external cmo/copyatt/ mos_ext mos_ext / itetclr itetclr1 # CONVERT QUADS to TRI # Set material itetclr to normals in 6 directions grid2grid/quadtotri2/ mos_tri / mos_ext cmo/select/mos_tri settets/normal # write files dump/avs/ surfmesh_all.inp / mos_all dump/ surfmesh_all.gmv / mos_all dump/avs/ surfmesh_external.inp / mos_ext dump/ surfmesh_external.gmv / mos_ext dump/avs/ surfmesh_ext_tri.inp / mos_tri dump/ surfmesh_ext_tri.gmv / mos_tri # report status of all mesh objects cmo/status # report attribute min max for mos_all cmo/printatt/mos_all/ -all- minmax finish Command to view min and max of extracted quad surface mos_all attributes: cmo/printatt/mos_all/-all- minmax Sample output: ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH -def- 0.00000E+00 0.00000E+00 0.00000E+00 585 scalar 1 1 0 1 vector 3 3 0 1 nnodes 585 585 0 1 nedges 0 0 0 1 nfaces 0 0 0 1 nelements 600 600 0 1 ... imt1 1 1 0 585 itetclr 1 2 1 600 ... idnode0 1 1089 1088 585 idelem0 0 797 797 600 idelem1 1 800 799 600 facecol 1 3 2 600 idface0 0 6 6 600 idface1 1 6 5 600 ...",
    "tags": "extract surfmesh",
    "url": "/pages/docs/demos/main_extract_surfmesh.html"
  },{
    "title": "INTERPOLATE",
    "text": "INTERPOLATE The interpolate (or intrp) command is used to interpolate attribute values from nodes or elements of a source mesh to node or element attributes of a sink mesh. Normally the source grid is coarser or the same resolution as the sink grid. Consider using upscale to assign values from high resolution to coarse resolution. Note: interpolate/map replaces the command doping/integer1 which copied source itetclr values to sink imt values. interpolate/voronoi replaces doping/integer2 which copied nearest node source imt to sink imt. interpolate/continuous evolved from the doping/table command. These commands are still similar to the old versions except that this interpolation has been updated to include attribute selections and expanded options. SYNTAX interpolate / intrp_method / cmosink, attsink / 1,0,0 / cmosrc, attsrc / [tie_option] [flag_option] [keep_option] [intrp_function] interpolate /  map or voronoi or continuous or default &amp; /cmosink, attsink / 1,0,0 /cmosrc, attsrc/ &amp; [ tiemin or tiemax ] [ flag_value or   plus1 ] &amp; [nearest, node_attribute ] [keepatt or delatt ]  [ intrp_function ] PARAMETER DESCRIPTIONS intrp_method defines the method of interpolation used from mesh object cmosrc to mesh object cmosink. map method copies the value from the enclosing source element to sink node or element (centroid). Sink nodes located outside the source elements are tagged with values according to flag options. If undefined, the flag value will be a value 1 greater than the max source attribute values. To copy from a source of type node, use voronoi method. voronoi copies the value from the nearest source node to the sink node. By selecting the nearest source points, Voronoi regions are generated around each sink point. The resulting sink point (node or centroid) is given the value of the attribute associated with the Voronoi generating point whose Voronoi cell the sink point lands in. The outside flag options do not apply for this method, even if a sink point is outside the source, a nearest node will be found. continuous interpolates values from the enclosing source element nodes to the sink nodes (or centriod of element). The interpolation is the sum of vertice values multiplied by the relative volume of elements formed by the sink point location on or inside the found element. The element is divided into volumes as determined by the sink point location and its relationship to the vertices of the enclosing element. A triangle becomes three triangles each with a vertices on the sink point. A quad becomes four quads. A tet becomes four tets. The assigned sink point value is the sum of these values divided by the number of element vertices. The interpolation function belonging to the attribute is applied to the vertice values before being summed. See also the interp_function option. WARNING A hex becomes 8 hexs which depends on orthogonal hexs and so is not currently supported. Use hextotet to convert hex elements to tets. default - If source attribute is element type then use map. If source attribute is node type then use continuous. cmosink, attsink are the sink mesh object name and attribute to write interpolated values to. If the sink attribute is element type, centroids are calculated for each element and these are used for the interpolation methods. indexed_set 1,0,0 (start,stride,stop) or pset,get,pset_name or eltset,get,eltset_name are the set of sink nodes or elements to write interpolated values to. 1,0,0 will select all sink nodes or elements.  cmosrc, attsrc are the source mesh object name and attribute values interpolating from. The following parameters are optional on the command line: tie_option is used to break a tie when a sink point has more than one valid candidate source node or element. Along with kdtree search, nearestpoint() and retrieve_within_eps() routines return a list of candidate objects for a sink point. These can be either a list of closest points, or a list of elements the point is on or inside. tie_option chooses one candidate from the possible candidates. The result is a one-to-one correspondence with each sink point paired with a single source node or a single source element. See keep_option for saving attributes with this correspondence. tiemax selects the maximum value from candidate nodes or elements. This is the default selection. tiemin selects the minimum value from candidate nodes or elements. flag_option is used to assign an error value, or to assign a value for points not inside the source mesh. These flag values indicate either that there was an error and a value could not be written to the sink attribute. The kdtree element search will assign a flag value if a sink point is located outside the source grid. This does not apply to Voronoi method which finds nearest node and does not depend on finding an enclosing element. plus1 will assign a flag value of maximum source value plus 1, this is the default behavior. nearest node_attribute will find the nearest source node and use the node’s attribute value as the flag value. The keyword nearest must be followed with the name of the source attribute name to be used for the flag values. flag_value given as an integer or real value will use this numeric value for the flag assignments. keep_option is useful during multiple calls to interpolate to use attributes pt_gtg and el_gtg instead of creating these search attributes for every call. The sink and source mesh objects and their index selection must not change. The interpolate command uses kdtree and candidate searches to create sink attributes that pair sink points to associated source node or element. By using the keyword ‘keepatt’ these attributes are not deleted. On subsequent calls to interpolate these attributes are used to look up associated node or element numbers. If map or continuous methods are used, the element attribute named el_gtg will be created. If voronoi or the flag_option nearest are used, the node attribute named pt_gtg will be created. The keyword delatt deletes any attributes created during the kdtree searches. By default these attributes are removed. intrp_function replaces the interpolation function associated with the sink attribute. This interpolation function is applied to the final interpolated field value. Valid interpolate functions are linear, asinh, log, copy, sequence, min, incmin, max, incmax, and, or, user. Functions such as min and max pass the interpolation value unchanged. DEBUG SYNTAX cmo/setatt/ cmosink / idebug debug_level For debugging purposes, setting idebug will output additional information from the interpolate routines. The integer value ‘debug_level’ is used to control the amount reported, 0 is no debug (default), 1 is minimum output and triggers calls to mmverify(), 5 is the middle, 9 and greater is verbose and includes information on every point and or element in the mesh. Table 1 Attribute Types for Interpolate This table indicates the type of attributes that can be used with the interpolation methods. Method Sink Source map node element map element element continuous node nodes (on element) continuous element nodes (on element) voronoi node node voronoi element node Table 2 Interpolation Methods and Options This Table shows supported applications for each of the interpolation methods. (parenthesis) means the option should work, but may be undefined. NOT indicates Not Supported OPTIONS MAP CONTINUOUS VORONOI source element type tri, quad, hex, tet, (pyr), (pri), (line) tri, quad, NOT hex, tet, (pyr), (pri), (line) tri, quad, hex, tet, (pyr), (pri), (line), (pnt) sink element type tri, quad, hex, tet, (pyr), (pri), (line), (pnt) tri, quad, hex, tet, (pyr), (pri), (line), (pnt) tri, quad, hex, tet, (pyr), (pri), (line), (pnt) source attribute element nodes (on element) node sink attribute node or element (centroid) node or element (centroid) node or element (centroid) source attribute type integer or double integer or double integer or double sink attribute type integer or double double, NOT integer integer or double interp function linear, log, sinh, all others pass unaltered linear, log, sinh, all others pass unaltered linear, log, sinh, all others pass unaltered tie option tiemin or tiemax tiemin or tiemax tiemin or tiemax flag option plus1, nearest, or user value plus1, nearest, or user value plus1 or user value keepatt option element attribute el_gtg element attribute el_gtg node attribute pt_gtg Examples interpolate / map / cmo_sink imt /1,0,0/ cmo_src itetclr For each node in cmo_sink find an enclosing element from mesh cmo_src. Assign the element’s itetclr value to the corresponding imt attribute of cmo_sink. For sink points outside of the source elements, a value 1 greater than itetclr max value is assigned. interpolate / voronoi / cmo_sink itetclr /1,0,0/ cmo_src imt / keepatt For each element centroid in cmo_sink find nearest node in cmo_src. Assign the source node imt value to the corresponding itetclr attribute of cmo_sink. The keepatt option keeps the sink attribute pt_gtg with nearest node values for each element centroid. interpolate / map / cmo_sink Pval /1,0,0/ cmo_src Vval / tiemin, log This command will assign source Vval values to sink Pval for elements enclosing cmo_sink points. If the sink point is found within more than one element, the min value of the candidate elements will be chosen. Since the interpolation function “log” is named, it will be applied to the source Vval value before being written to sink attribute Pval. interpolate/ voronoi / cmo_sink imt /1,0,0/ cmo_src imt For each node in cmo_sink, find the closest node in cmo_src. Assign the imt value from the closest cmo_src node to the imt attribute of cmo_sink. interpolate/ continuous / cmo_sink xval /1,0,0/ cmo_src Pv For each node in cmo_sink, find a cmo_src element the node is inside. Interpolate the element node values in Pv on to the sink point and write to the sink attribute xval. interpolate/ map /cmo_sink imt /1,0,0/ cmo_src itetclr / nearest, imt / keepatt interpolate/ map /cmo_sink imtreal /1,0,0/ cmo_src itetreal / nearest, imtreal The first call to interpolate will assign itetclr values from source elements to imt in the sink cmo for points inside the source elements. Any sink point not inside the source grid will be assigned the imt value of the nearest source point. Since keepatt is set, both attributes pt_gtg and el_gtg will be kept as sink cmo attributes and hold the node and element numbers for each sink point. The second call to interpolate will find the sink attributes pt_gtg and el_gtg. The nearest point and enclosing element kdtree searches will be skipped. This time the element value in attribute itetreal will be assigned to the sink node attribute imtreal. For points outside the grid, values from nearest node attribute imtreal will be used. Note that the delatt keyword does not have to exist, the interpolate attributes are always deleted unless the keyword keepatt is used. Demos Examples: interpolate / voronoi Examples from test/level01/interp_voronoi Examples: interpolate / map Examples from test/level01/interp_map Examples: interpolate / continuous Examples from test/level01/interp_continuous",
    "tags": "map continuous voronoi nearest node",
    "url": "/pages/docs/commands/main_interpolate.html"
  },{
    "title": "Example REGNPTS",
    "text": "Example REGNPTS Use regnpts to create point distributions and meshes. Click on small images to view full size image. Input LaGriT command file lagrit_input_regnpts Outer region and inner region edges and nodes Inner region surface and outer region nodes",
    "tags": "regnpts, create points, ray shooting",
    "url": "/pages/docs/demos/main_regnpts.html"
  },{
    "title": "EXAMPLE RMMAT",
    "text": "RMMAT EXAMPLE The objective is to use the rmmat command to modify a mesh by removing one of the material regions. The output consists of five gmv files, one showing the single material region, one showing a mesh with two materials included, and one each for the results of rmmat/node, rmmat/element, rmmat/all. Click on images to enlarge. LaGriT Input Command File lagrit_input_rmmat Input Mesh with single material rmmat / element Input Mesh with two materials rmmat / node rmmat / all",
    "tags": "rmmat",
    "url": "/pages/docs/demos/main_rmmat.html"
  },{
    "title": "ROTATELN DEMO",
    "text": "DEMO ROTATED CYLINDER IN BOX Create a box with a cylinder object, use rotateln and trans to move the cylinder.             Rotated Points Remove dud points tet mesh Create a cylinder centered around x=.5,z=.5, radius = .1 the cylinder is aligned parallel to the y-axis and inside a box of width =2 , length=2. Create geometry and material regions. The regions are air for the cylinder - solid outside the cyl. Create the point distribution. Points are spread by surrounding the whole object with a cylinder shell of points and then creating rays between these points and the major axis of the cylinder. Points are distributed along these rays inside the cylindrical region. A background rectangular grid of points is spread outside the cylinder. The rz command always distributes points with the z-axis as the axis of symmetry The first image shows the points (magenta and green) and the ray points (in black). Rotate and translate Use the rotateln and trans commands to move the point distribution after it is created. Set node and element materials, remove ray points (black points in image), and connect into a tet mesh. cmo/create/3dmesh surface/box1/reflect/box/-1.0,-1.0,0.0/ 1.0, 1.0, 1.0/ surface/h1/intrface/cylinder/ 0.5, -1.,0.5/ 0.5, 1.0, 0.5/.1/ # set geometric and material regions region/H1/ le box1 and le h1 / region/Fill/ le box1 and gt h1 / mregion/Air/ le box1 and lt h1 / mregion/Solid/Fill # create point distributions createpts/xyz/11,11,1/-1. -1. 1.1/1.0 1.0 1.1/1,1,0/ pset/rays/seq/1,0,0/ regnpts/Fill/11/pset,get,rays/xyz/ 0.0,0.0,-0.1/1.0,1.0,-0.1/ &amp; 0.0,1.0,-0.1/0,0/ createpts/rtz/1,13,11/5.,0.,-1./5.,360.,1./0,1,1/0,0,0/ pset/ray1/seq/0,0,0/ # rotate and move the points rotateln/pset,get,ray1/nocopy/-100.,0.,0./100.,0.,0./-90./0.,0.,0./ trans/pset,get,ray1/0.,0.,0./0.5,0.,0.5/ regnpts/H1/3/pset,get,ray1/rtz/0.5,-1.1,0.5/0.5,1.1,0.5/0,0/ # remove duplicates filter/1,0,0/ # dud some nodes that were ray points cmo/setatt//itp1/pset,get,rays/21 cmo/setatt//itp1/pset,get,ray1/21 # set imt materials for nodes setpts dump/gmv/cylinder_rot.gmv/3dmesh # connect into delaunay tet mesh connect # set itetclr materials for elements settets dump/gmv/mesh_tet_duds.gmv/3dmesh # remove dud nodes and set boundary rmpoint/compress resetpts/itp dump/gmv/mesh_tet.gmv/3dmesh finish",
    "tags": "rotateln, rotate line",
    "url": "/pages/docs/demos/main_rotateln.html"
  },{
    "title": "Online Manual",
    "text": "Online Manual I. Introduction LaGriT and PyLaGriT LaGriT Features Mesh Design Considerations Tutorials and Examples II. LaGriT Commands Syntax Conventions Alphabetic listing of LaGriT commands LaGriT commands by Category III. Mesh Objects Mesh Object Definition Mesh Object Connectivity Supported Element Types Geometries Command Interface Fortran Interface IV. Interfacing User Routines to LaGriT Building an Executable and Running LaGriT Issuing Commands from a User Program Writing User Commands Accessing the Mesh Object Utility Subroutines V. Errors Errors in parsing or executing commands. Out of memory errors. Fatal memory management errors LaGriT References LaGriT Publications LaGriT on Github",
    "tags": "manual, index",
    "url": "/pages/manual.html"
  },{
    "title": "1",
    "text": "   Memory Manager LaGriT uses dynamic memory allocation. Memory is referenced by a two part name, block name and partition name. It is allocated in integer or real blocks(real is implemented as real *8). Each memory block is preceeded by a header and terminated by a trailer. The memory manager always returns the pointer to the data section of the memory block. Length is specified in words. Type indicates if the words are integer or real. Different platforms will have different values for integer and real word lengths. These machine dependent values are collected in the include file machine.h. The following parameter names are used by the memory management routines:   blk block name of memory block prt partition name of memory block  iadr pointer to memory block (data section)  length number of words in block or to be allocated itype 1 for integer, 2 for real(real *8) , 3 for character icscode return code, 0 for no errors  increment numbers of words to use as increment to size of memory block need required size of memory block extra extra amount to add to size of memory block when increasing its size ———– ———————————————————————- In the following list underlined parameters are required input parameters.   Allocate a block of memory: mmgetblk(blk,prt,iadr,length,itype,icscode) Release a block of memory: mmrelblk(blk,prt,iadr,icscode)   Release a partition of memory – all blocks belonging to this partition will be released: mmrelprt(prt,icscode) Increment a block of memory by increment: mmincblk(blk,prt,iadr,increment,icscode)   Find pointer (idar) and length (length) to a block of memory: mmfindbk(blk,prt,iadr,length,icscode)   Return type (itype) of a block of memory: mmgettyp(iadr,itype,icscode)   Return number of words (length) in a block of memory given the address of the block: mmgetlen(iadr,length,icscode)   Return number of words (length) in a block of memory given the name of the block: mmblklen(blk,prt,iadr,length,icscode) Return name (blk, prt) of a block of memory: mmgetnam(iadr,blk,prt,icscode) Return address (iadr) of a block of memory: mmgetpr (blk, prt,iadr,icscode) Print a dump of allocated memory. This is useful for debugging purposes; the dump is listed by increasing pointer address: mmprint() Verify memory integrity. Print debug information if the memory block headers or trailers have been overwritten. mmverify() Find a block of memory, increase it if shorter than length, or allocate it if it doesn’t exist; mmggetbk(blk,prt,iadr,length,itype,icscode) Change the length of a block of memory to length. mmnewlen(blk,prt,iadr,length,icscode) Change the name of a partition to prt1 from prt2 mmnamprt(prt1,prt2,icscode) Get the address of the requested block and change the size of the storage to need+extra if need &gt; length.  Always return in length the new length of the block.  If length is 0 on entry, allocate a new block. mm_ovall(blk,prt,iadr,need,extra,length,type,status)",
    "tags": "",
    "url": "/pages/docs/memmang.html"
  },{
    "title": "memory",
    "text": "MEMORY These commands report the current state of LaGriT’s dynamic memory allocation. LaGriT arrays are referenced by memory management by a two part name, block name and partition name. It is allocated in integer or real blocks. Each memory block is preceeded by a header and terminated by a trailer. Different platforms will have different values for integer and real word lengths. Read more on LaGriT memory management at Memory Manager The following memory command options are recognized: memory/verify verify the integerity of LaGriT memory manager storage by checking that the known blocks have not been overwritten. If corruption is detected, an array map will be printed. Nothing is printed if there memory is successfully verified. memory/print print an address map of the LaGriT managed arrays. For each array the following is printed; index, length, type, memory address, associated name, and partition. The partition is the grouping of arrays by usage. Common partitions include the mesh object (by name), global memory, and temporary memory for work arrays. memory/maxmalloc Report estimate of possible amount of memory available for allocation by LaGriT. This test will make incremental calls to internal LaGriT memory allocation (mmgetblk) until failure. The report will include the total Megabytes where allocation succeeded, and amount at which allocation failed. This command will also print a map of the memory manager storage. EXAMPLES memory / verify Will be silent if no problems are detected. memory / print Sample for 64 bit output showing sizes and allocated memory: MEMORY SIZES : Sizeof char (type 3) = 1 bytes Sizeof long = 8 bytes Sizeof real*8 (type 2) = 8 bytes Sizeof pointer = 8 bytes Sizeof integer (type 1) = 4 bytes Sizeof INT_PTRSIZE = 8 bytes INDEX LENGTH TYPE ADDRESS NAME PARTITION 29 40000000 2 -14248416 xic cmo1 1 10 3 143632720 global_name global_lg 31 40000000 2 1760710688 zic cmo1 30 40000000 2 2080714784 yic cmo1 Total BYTES = 2.400E+09 Total MEGABYTES = 2.400E+03 memory/maxmalloc Sample 64 bit output showing max allocation on Ubuntu Linux (this can take awhile before failure): Looking for malloc to fail, expect errors .... Allocate blocks of 200000 real values and 1600000.0000000000 bytes Max unsigned for 32 bit is 4,294,967,295 Max unsigned for 64 bit is 18,446,744,073,709,551,615 Stop test value for allocated bytes is 1.8000000404716257E+019 1 &gt;&gt; 1 number reals = 200000.00000000000 total bytes = 1600000.0000000000 2 &gt;&gt; 1 number reals = 400000.00000000000 total bytes = 3200000.0000000000 3 &gt;&gt; 1 number reals = 800000.00000000000 total bytes = 6400000.0000000000 ... 18 &gt;&gt; 1 number reals = 26214400000.000000 total bytes = 209715200000.00000 Killed",
    "tags": "memory",
    "url": "/pages/docs/commands/memory.html"
  },{
    "title": "Mesh Design and Considerations",
    "text": "Mesh Design Considerations LaGriT provides a variety of meshing tools with capabilities specific to geologic applications and Voronoi control volume solvers. These tools were developed to generate and modify meshes, and also to create meshes with control volume discretization such that the underlying control volumes are Voronoi tessellations as preferred by modeling applications such as FEHM. Some basic considerations include dimension, domain, and mesh size restrictions (number of degrees of freedom) versus mesh resolution needed for model features. What are the modeling application requirements? Are mesh properties defined on the cell or the vertices? What element types do you need, hexahedral, tetrahedral? Choose a mesh design and meshing method that gives the best performance from the modeling application possible, with respect to the difficulty in generating the mesh. Choose a design and method to create a mesh that is appropriate for the constraints for accuracy and numerical stability imposed by the modeling application and the simulations being run. Consider the physics to be modeled, mesh size restrictions (number of degrees of freedom) versus mesh resolution needed for model features, and the mesh and model information needed by the model application. Some modeling applications can solve problems only on orthogonal regular structured meshes, while others can handle unstructured meshes that conform to complex geologic stratigraphy and geologic structures such as sloped layers, faults, erosion and deposition. The unstructured approach allows the creation of meshes that exactly conform to the geometric model, but requires some expertise in building the mesh such that it will also meet the Delaunay criteria if required. The easier method is to use a structured mesh with fine resolution, or a coarser mesh that uses octree refinement to increase resolution in user specified regions of interest. These result in stair-stepped geometries instead of smooth, but can be acceptable for where the geometry spacing is small relative to the full model domain. (Sentis and Gable, 2017). For modeling applications with complex stratigraphy, depending on the mesh, you can get a stable but inaccurate solution to the physics (Zyvoloski and Vesselinov, 2006). Choose a mesh design and meshing method that gives the best performance from the modeling application possible, with respect to the difficulty in generating the mesh. Structured Mesh Methods Although structured meshes are not as flexible as unstructured meshes in fitting complex geometry, tests have shown that they provide accurate solutions so long as there is adequate resolution to represent the geometry of the different materials in each hydrogeologic layer. Moreover, there must be enough resolution to account for any large gradients. The sufficiency of grid resolution is usually investigated by running a flow model using various grids of differing resolutions. Example mregion with surface command Structured Mesh with Octree Refinement Methods For a model with intersecting internal surfaces a mesh that conforms with the material layers is more difficult, especially in 3 dimensions. Rather than using an unstructured mesh requiring careful design and discretization, you can create a structured mesh and use octree refinement to capture the material geometry. Start with a hexahedral mesh with coarse spacing. LaGriT is used to intersect the extracted interfaces with the coarse hex mesh, the intersected cells are refined with the octree method multiple times to achieve the desired resolution at these interfaces. This point distribution can be connected into a tetrahedral Delaunay mesh. Example Octree Refinement Stacked Unstructured Methods For a model with horizontal non-intersecting surfaces, you can create a computational mesh with conforming interfaces by using a stacked mesh method. This works well for modeling applications like Amanzi/ATS that can compute on hexahedral or prism elements. This method stacks quad or triangle surfaces and connects layers into a 2 ½ Dimension hex or prism mesh. Example stack Unstructured Methods A fully unstructured mesh can be built using volume surfaces that represent a geometry. It is necessary that these surfaces are coincident where they share a boundary. There cannot be any gaps or intersections where surfaces cross each other. The interface nodes may need refinement or buffering to ensure elements conform at the boundary. For modeling applications that require the Delaunay criteria, this can be very difficult. The mesh elements will conform to the geometry, but the mesh quality will likely contain a poor topology and generate negative coupling coefficients. The solutions from simulations may be inaccurate. You can mitigate the impact by adjusting the mesh resolution. Generally high aspect ratio tet elements (long dimension along the external boundary) are more of a problem. This means that mesh refinement that brings the mesh closer to unit aspect ratio will help. Example sphere in box Examples Manual Tutorial and Examples LANL Meshing Projects GDSA Example with 4 Geologic Model Types Tet Element Quality Measures with LaGriT References 2017 Sentis, M.L., Gable, C.W., Coupling LaGrit unstructured mesh generation and model setup with TOUGH2 flow and transport: A case study, Computers &amp; Geosciences, 2017, DOI:doi.org/10.1016/j.cageo.2017.06.012. 2006 Zyvoloski, G. &amp; Vesselinov, Velimir. An Investigation of Numerical Grid Effects in Parameter Estimation. Ground water. 44. 814-25. 10.1111/j.1745-6584.2006.00203.x.",
    "tags": "mesh design, quality",
    "url": "/pages/docs/meshing.html"
  },{
    "title": "Fortran Mesh Object Subroutines",
    "text": "Fortran Mesh Object Subroutines Create a new mesh object called cmo_name cmo_create(cmo_name,ierror) Get values of scalar attribute of the mesh object. cmo_get_intinfo(ioption,cmo_name,iout,lout,itype,ierror) ioption is the name of the mesh object attribute whose value is to be retrieved; the information retrieved may be one of these key words or it may be the name of a user supplied integer attribute  (generated by a cmo_addatt command): ----------- ------------------------------------------------ ioption number_of_attributes nnodes (number of nodes in the mesh) nelements (number of elements in the mesh) nfaces (number of unique topological facets) nedges (number of unique edges in mesh) mbndry (boundary node flag value) ndimensions_topo (topological dimensionality) ndimensions_geom nodes_per_element edges_per_element faces_per_element cmo_name name of mesh object iout value of attribute returned lout length of attribute always 1 itype type of attribute always 1 ierror return flag (0= no errors) ----------- ------------------------------------------------ Return pointer to array attributes. cmo_get_info(ioption, cmo_name, iout, lout, itype, ierror) ioption - name of mesh object attribute.  It may be one of these keywords or a users supplied array attribute. --------------------- ------------------------------------------------------- ioption (key words) isetwd ( pset membership information) ialias (alternate node numbers) imt1 (node material) itp1 (node type) icr1 (constraint numbers for nodes) isn1 (child, parent node correspondence) ign1 (igeneration numbers for nodes) xic, yic, zic (node coordinates itetclr (integer array of element material) itettyp (geometry of element) xtetwd (eltset membership information) itetoff (index into itet array for an element) jtetoff (index into jtet array for an element) itet (node vertices for each element) jtet (element connectivity) cmo_name name of mesh object iout pointer to the attribute if the attribute is a vector lout length of array associated with this pointer  itype type of attribute always 4 ierror return flag (0= no errors) --------------------- ------------------------------------------------------- Set values of integer  attribute of the mesh object. cmo_set_info(ioption,cmo_name,data,lin,itype,ierror) ----------- ----------------------------------------- ioption  attribute name cmo_name name of mesh object data  value of the scalar attribute to be set lin  length code of attribute (1) itype type of attribute (1) ----------- ----------------------------------------- Get the name of the current mesh object. cmo_get_name(cmo_name,ierror) This routine is useful when looping through all the attributes of a mesh object. To get the number of attributes use cmo_get_intinfo(‘number_of_attributes’). cmo_get_attribute_name(cmo_name,attribute_index,attribute_name,ierror) Adjust memory associated with mesh object. Must be called whenever the size of the mesh is adjusted in order to provide memory to the pointered attributes. cmo_newlen(cmo_name,ierror) Release a mesh object called cmo_name and release its memory.  cmo_release(cmo_name,ierror) Retrieve a mesh object value,  the attribute type will determine what is returned. cmo_get_attinfo (ioption, cmo_name, iout, rout, cout, ipout, lout,itype, ierror) ----------------------- ------------------------------------------------------------------------------------------------- ioption name of mesh object attribute  cmo_name  name of mesh object iout,rout,cout,ipout  returned value of attribute - only one of the four will be returned depending on attribute type ierror error return - 0 if no errors itype attribute type returned ( 1= integer, 2=real, 3=character, 4=pointer) ----------------------- ------------------------------------------------------------------------------------------------- Retrieve the integer values of the requested mesh object attributes length and rank. cmo_get_length(att_name,cmo_name,length,irank,ierror) ----------- ------------------------------- att_name name of mesh object attribute cmo_name name of mehs object length  length of attribute (integer) irank rank of attribute (integer) ierror return flag (0 = no errors) ----------- ------------------------------- Set mesh object attribute values for integer, real or character attributes. cmo_set_attinfo(ioption,cmo_name,idata,rdata,cdata,type_data,ierror) -------------------- ------------------------------------------------ ioption name of attribute cmo_name name of mesh object  idata,rdata,cdata  value to be set depending on type of attribute type_data type of data, 1=integer, 2=real, 3=character ierror return flag (0 = no errors) -------------------- ------------------------------------------------ Return attribute definition: cmo_get_attparam(ioption,cmo_name,index,ctype,crank,clen,cinter,cpers,cio,ierror) ----------- ----------------------------------------------------------------------------------------------------------- ioption character string that gives name of attribute.  This is required input parameter cmo_name name of mesh object. This is an input parameter that is usually a character variable that contains the name of the mesh object. index attribute number  ctype character string that gives type of attribute:  'INT' ,' REAL'   'CHARACTER', ' VINT (Vector of integers), 'VDOUBLE' (vector of reals),  'VCHAR' (vector of characters) crank character string that gives rank of attribute: e.g.'scalar', 'vector', or the name of a user defined INT attribute. clen chracter string that gives length of attribute: e.g. 'nnodes', 'nelements', 'scalar', 'vector', or a user defined INT attribute cinter character string that gives interpolation method: e.g. 'linear', 'log' cpers character string that gives persistence: 'permanent' or 'temporary' cio character string that gives i/o flags for writing attributes to a mesh file ierror error flag ( 0= no errors) ----------- ----------------------------------------------------------------------------------------------------------- ## CODE EXAMPLES   call get_attinfo (‘ipointi’, acmo, firstpt, rout, cout, ipout, itype, ierror) The value of the mesh object attribute ipointi wil be returned in the variable called firstpt.  A 1 will be returned in itype. cmo_get_attinfo(‘geom_name’, cmoa, iout,rout,gname, ipout,itype,ierror) The value of the mesh object attribute called geom_name in the mesh cmoa will be returned in the variable gname.  A 3 will be returned in itype. cmo_get_attparam(‘ipointi’, cmoa, index, ctype,crank,clen,cinter,cpers,cio,ierror) Returns: index=37, ctype=’INT’, crank=’scalar’,  clen=  ‘scalar’, cinter=  ‘constant’,  cpers =   ‘permanent’,cio=’l’. cmo_set_attinfo(‘epsilonl’, -def-, idum, epsilonnew,cdum,2,ierror) Changes the value of the current mesh object attribute named epsilonl to the value of the local real variable epsilonnew.    ",
    "tags": "",
    "url": "/pages/docs/meshob.html"
  },{
    "title": "METIS",
    "text": " METIS ——- This command may not work with 64 bit machines, this version of METIS is 32 bit Interface to the METIS graph partition and reorder package with LaGriT. See METIS package description at http://glaros.dtc.umn.edu/gkhome/views/metis Partition algorithm divides mesh into npartition parts attempting to assign an equal number of graph vertices (nodes or elements) to each partition and also the number of adjacent elements assigned to different processors is minimized. New attributes are created to hold partition information. Node partition number is in inodeprt, element partition number is in ielemprt. Reorder algorithm computes a permutation vector, iperm, and an inverse permutation vector, invperm. The mesh can be reordered using the permutation vector in reorder. The reorder algorithms will compute fill-reducing orderings of sparse matrices. METIS Interface to LaGriT PARTITION metis / partition / metis_partmeshnodal metis_partmeshdual/ node dual / npartitions / inodeprt / ielemprt REORDER metis / reorder / metis\\_edgend metis\\_nodend / node dual /[iperm] / [invperm] REORDER WITH WEIGHTS metis / reorder / mmetis\\_nodewnd / node dual / [iperm] /[invperm] / ivert_weight EXAMPLES metis / partition / metis\\_partmeshnodal / node / 32 / inodeprt / ielemprt metis / partition / metis\\_partmeshdual / dual / 32 / inodeprt / ielemprt metis / partition / metis\\_partmeshnodal / node / 32 / -def- / -def- metis / partition / metis\\_partmeshnodal / node / 32 metis / reorder / metis\\_edgend / dual metis / reorder / metis\\_nodend / node metis / reorder / metis\\_nodend / dual metis / reorder / metis\\_nodend / dual / -def- / -def- metis / reorder / metis\\_nodend / dual / ieprm1 / ieinvprm1 metis / reorder / metis\\_edgend / nodereorder/-def-/ieprm1 EXAMPLE LaGriT Control File: * * Build some meshes, tri,quad,hex,tet * define / NP / 21 cmo / create / mo_hex / / / hex createpts / brick / xyz / NP NP NP / 0. 0. 0. / 1. 1. 1. / 1 1 1 cmo / setatt / mo_hex / itetclr / 1 0 0 / 1 resetpts / itp define / NP / 101 cmo/create/mo_qua/ / / quad quadxy/ NP NP / 0. 0. 0. / 1. 0. 0. / 1. 1. 0. / 0. 1. 0. createpts/brick/xyz/NP NP 1/1 0 0 / connect cmo / setatt / mo_qua / itetclr / 1 0 0 / 1 resetpts / itp hextotet / 4 / mo_tri / mo_qua resetpts / itp hextotet / 24 / mo_tet / mo_hex resetpts / itp cmo / status / brief * * Run Metis partition into 16, 33 and 128 * cmo / select / mo_qua metis/partition/metis_partmeshnodal/node/ 16 idn016 ide016 metis/partition/metis_partmeshnodal/node/ 33 idn033 ide033 metis/partition/metis_partmeshnodal/node/128 idn128 ide128 metis/partition/metis_partmeshdual/dual/ 16 iddn016 idde016 metis/partition/metis_partmeshdual/dual/ 33 iddn033 idde033 metis/partition/metis_partmeshdual/dual/128 iddn128 idde128 metis / reorder / metis_nodend / node / iperm1 / invperm1 cmo / select / mo_tri metis/partition/metis_partmeshnodal/node/ 16 idn016 ide016 metis/partition/metis_partmeshnodal/node/ 33 idn033 ide033 metis/partition/metis_partmeshnodal/node/ 128 idn128 ide128 metis/partition/metis_partmeshdual/dual/ 16 iddn016 idde016 metis/partition/metis_partmeshdual/dual/ 33 iddn033 idde033 metis/partition/metis_partmeshdual/dual/128 iddn128 idde128 metis / reorder / metis_nodend / node / iperm1 / invperm1 cmo / select / mo_hex metis/partition/metis_partmeshnodal/node/ 16 idn016 ide016 metis/partition/metis_partmeshnodal/node/ 33 idn033 ide033 metis/partition/metis_partmeshnodal/node/ 128 idn128 ide128 metis/partition/metis_partmeshdual/dual/ 16 iddn016 idde016 metis/partition/metis_partmeshdual/dual/ 33 iddn033 idde033 metis/partition/metis_partmeshdual/dual/128 iddn128 idde128 metis / reorder / metis_nodend / node / iperm1 / invperm1 cmo / select / mo_tet metis/partition/metis_partmeshnodal/node/ 16 idn016 ide016 metis/partition/metis_partmeshnodal/node/ 33 idn033 ide033 metis/partition/metis_partmeshnodal/node/ 128 idn128 ide128 metis/partition/metis_partmeshdual/dual/ 16 iddn016 idde016 metis/partition/metis_partmeshdual/dual/ 33 iddn033 idde033 metis/partition/metis_partmeshdual/dual/128 iddn128 idde128 metis / reorder / metis_nodend / node / iperm1 / invperm1 dump / gmv / metis_qua.gmv / mo_qua dump / gmv / metis_tri.gmv / mo_tri dump / gmv / metis_hex.gmv / mo_hex dump / gmv / metis_tet.gmv / mo_tet * * Create an attribute which is the node number * cmo / set_id / mo_qua / node / idnode0 cmo / set_id / mo_tri / node / idnode0 cmo / set_id / mo_hex / node / idnode0 cmo / set_id / mo_tet / node / idnode0 * * Reorder each mesh using the Metis permutation vector * reorder / mo_qua / iperm1 reorder / mo_tri / iperm1 reorder / mo_hex / iperm1 reorder / mo_tet / iperm1 * * Create an attribute which is the node number after reorder * cmo / set_id / mo_qua / node / idnode1 cmo / set_id / mo_tri / node / idnode1 cmo / set_id / mo_hex / node / idnode1 cmo / set_id / mo_tet / node / idnode1 dump / gmv / metis_qua_reorder.gmv / mo_qua dump / gmv / metis_tri_reorder.gmv / mo_tri dump / gmv / metis_hex_reorder.gmv / mo_hex dump / gmv / metis_tet_reorder.gmv / mo_tet finish METIS can be freely distributed provided that: A reference to the following paper is included: *“A Fast and Highly Quality Multilevel Scheme for Partitioning Irregular Graphs”. George Karypis and Vipin Kumar. SIAM Journal on Scientific Computing, Vol. 20, No. 1, pp. 359—392, 1999.* and copyright notice is include METIS 4.0 Copyright 2001-06, Regents of the University of Minnesota",
    "tags": "",
    "url": "/pages/docs/commands/metis.html"
  },{
    "title": "7",
    "text": "Miscellaneous setsize The subroutine setsize sets the mesh object attriburtes: xmin, xmax, ymin, ymax, zmin, zmax, epsilona, epsilonv setsize( ) xmin, xmax, ymin, ymax, zmin, zmax are set from the minimum and maximum xic,yic,zic values of all ‘real’ points (dudded and merged points will be ignored). epsilona is set to : ((xmax-xmin) * *2+(ymax-ymin) * *2+(zmax-zmin) * *2) *epsilonr *1000. epsilonv is set to : abs(xmax-xmin) *abs(ymax-ymin) *abs(zmax-zmin) *epsilonr *1000. getsize The subroutine getsize returns the mesh object attributes:   xmin, xmax, ymin, ymax, zmin, zmax, epsilona, epsilonv getsize(xmin,xmax,ymin,ymax,zmin,zmax,epsilona,epsilonv) set_user_bounds This routine allows the user to set boundary values. See the boundary command. set_user_bounds(nubndpts,ubndpts,cmo,ipattr, idfield) nubndpts - number of boundary nodes ubndpt - integer array of boundary node indices cmo - a mesh object name ipattr - pointer to mesh object attribute to contain boundary values idfield - identifier used to identify the set of boundary nodes. inside routines The inside set of subroutines test whether a query point is strictly inside, strictly outside or on the surface of the specified element.  The value returned in iflag is 0 if the query point is inside the element, -1 if outside, or is set to the local face number containing the query point.  Coordinates of the query point are in xq, yq, zq.  Coordinates of the vertices of the element are in x1, y1, z1, x2…..  The coordinates of these vertices of the element must be specified in the correct order (see the section on Mesh Object Connectivity).  For triangular elements both inside_tri and inside_tri2d  must be called; the first call will determine if the query point is in the plane of the triangle;  the second, if it is in the interior of the triangle.  Similar calls must be made for planar quad meshes. inside_pyr(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,x5,y5,z5,xq,yq,zq,iflag) inside_pri(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,x5,y5,z5,x6,y6,z6,xq,yq,zq,iflag) inside_hex(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,x5,y5,z5,x6,y6,z6,x7,y7,z7,x8,y8,z8, xq,yq,zq,iflag) inside_tet(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,xq,yq,zq,iflag) inside_quad2d(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,xq,yq,zq,iflag) inside_tri2d(x1,y1,z1,x2,y2,z2,x3,y3,z3,xq,yq,zq,iflag) These routines should not be confused with inside_quad(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,xq,yq,zq,iflag) inside_tri(x1,y1,z1,x2,y2,z2,x3,y3,z3,xq,yq,zq,iflag) which return in iflag: 1 if the query point is on the plane of the element, 0 if below the plane and -1 if above. The generic subroutine inside_element (element_type, xcoords, ycoords, zcoords, xq,yq,zq,iflag) which returns iflag = -1 if the query point (xq,yq,zq) is outside the element, 0 if it is inside, 1 &lt; n &lt; 6 where n is the face of the element on which the query point sits.  element_type is an integer, 1 = point, 2 = line, 3= triangle, 4= quad, 5=tet, 6= pyramid, 7= prism, 8=hex).  The x,y,z coordinates of the vertices of the element are given in xcoords, ycoords, zcoords.  The order of the vertices is important.   volume_element return the volume of an element. volume_element (ielmtyp,xicvol,yicvol,zicvol,volelm) ilemtyp is the element type (input, usually extracted from the ittettyp attribute) xicvol, yicvol, zicvol are arrays of the coordinates of the vertices of the element (input) volelm is the volume of the element (output) user_interpolate         user_interpolate(cmo_sink,cmo_src,cmolength,cname,nlist,list,ierror_return) Supplying this subroutine and linking it in when building the executable allows the user to supply the interpolation formula for an attribute whose interpolation has been set to user.  By default several mesh object attributes have interpolation type user, for example, isn1, itetoff ( there is no obvious way to assign a correct value to new nodes or elements based on the values of old elements and other parts of the LaGriT code take care of assigning correct values).  Therefore if a user attribute is created with interpolation type user and the subroutine user_interpolate is supplied, this routine must check the cname argument to make sure it matches the name of the user attribute. (e.g.  if the user attribute is called my_attribute then the routine must contain a statement such as:          if(cname.eq.’my_attribute’) then                  cmo_sink        is the SINK mesh object                  cmo_src          is the SOURCE mesh object                  cmolength        is “nnodes” or “nelements”                  cname               is the name of the attribute                  nlist                  number of items to interpolate                  list(nlist)          the list of items for which new interpolated values are to be produced                  ierror_return    0 = no error                                                &gt;1 = error",
    "tags": "",
    "url": "/pages/docs/miscell.html"
  },{
    "title": "",
    "text": " “30” “30”](mstkla.md#parent-child) “30” “30”](mstkla.md) “30” “30”](prelim.md)  Parent-Child Node (Vertex) Issues    All the operators are designed to work consistently with parent and child nodes(if they exist) consistently. Operators exist for getting the parent of a vertex, edge and face. The parent edge/face of a  edge/face is constructed from the parents of its component vertices. Operators also exist for obtaining the child vertices/edges/faces of vertices/edges/faces. The upward and downward adjacency information is designed to be returned in a consistent manner as described below. If upward adjacency information is requested for a child entity then only those higher order entities connected to the child will be returned. On the other hand, if it is requested for a parent, upward adjacency information from all its children will be consolidated and returned. For example, if regions of a child vertex (node) are requested, then only the regions classified in that model region will  be returned. On the other hand if one wants all the regions in all model regions connected to the node, one should get the parent of the vertex and ask for the regions connected to the parent vertex.  The behavior of downward adjacency information queries is determined by the type of entity and how it is constructed. Asking for the nodes of a vertex will return only the child nodes if any of the nodes are on  an interface. Parent faces and edges on an interface will return parent nodes and child faces and edges on an interface will return child nodes. Lastly, if the entity is not on an interface, it is its own parent or its own child. “30” “30”](mstkla.md#parent-child) “30” “30”](mstkla.md) “30” “30”](prelim.md)",
    "tags": "",
    "url": "/pages/mstkla/parent-child.html"
  },{
    "title": "picture index",
    "text": "Unlinked File LaGriT Pictures “21” “21”Mesh for scanning microscopy simulation “21” “21”Tetrahedral LaGriT mesh “21” “21”Finite Element Calculation “21” “21”Laplacian smoothing “21” “21”[Biological Structures](biology.pdf” download&gt; &lt;/a&gt; “21” “21”Movie - Grain growth in large cube [gif animation (5MB)](99.gif”&gt; “21” “21”Movie - Grain growth with temperature-dependent mobility [gif animation (5MB)](tmap-a.gif”&gt; “21” “21”Movie - Grain growth in line to bamboo [gif animation (1.5MB)](tmap.gif”&gt; “21” “21”Movie - GMMFE (Graph Massage w/ Moving Finite Elements)       Shallow Water Equations – Evolving Adaptive Grid     [gif animation (4MB)](vertgridshort_swe_10-3.gif”&gt;       Shallow Water Equations – Perspective view of water height          with grid  [gif animation (2MB)](sidegridshort_swe_10-3.gif”&gt;      Shallow Water Equations – Alternate view of water height     [gif animation (3MB)](backsideshort_swe_10-3.gif”&gt; “21” “21”Movie - GMMFE (Graph Massage w/ Moving Finite Elements)       Rotating Hump – Evolving Adaptive Grid     [gif animation (6MB)](vertgrid_rotation_10-4.gif”&gt; [gif animation (0.6 MB)](vertgridshort_rotation_10-4.gif”&gt;       Rotating Hump – Perspective view     [gif animation (3MB)](side_rotation_10-4.gif”&gt;  [gif animation (0.3 MB)](sideshort_rotation_10-4.gif”&gt; “21” “21”Movie - Graph Massage for the shear flow (x,y)’=(-xy,0).       Evolving Triangular Grid with Graph Massage     [gif animation (6MB)](gmtri_shear.gif”&gt; [gif animation (0.6 MB)](gmtrishort_shear.gif”&gt;       Evolving Quadrilateral Grid with Graph Massage     [gif animation (3MB)](gmquad_shear.gif”&gt;  [gif animation (0.3 MB)](gmquadshort_shear.gif”&gt;       Evolving Quadrilateral Grid without Graph Massage     [gif animation (3MB)](nogmquad_shear.gif”&gt;  [gif animation (0.3 MB)](nogmquadshort_shear.gif”&gt; “21” “21”Movie - Dendrite formation.       Dendrite surface with grid - adaptive refine used to maintain grid     [gif animation (10MB)](dendrite.gif”&gt;       Dendrite surface without grid - temperature field displayed     [gif animation (10MB)](dendriteng.gif”&gt;       Return to LaGriT home page",
    "tags": "review, graphics, unlinked",
    "url": "/pages/docs/picturesweek.html"
  },{
    "title": "",
    "text": "“30” “30”](mstkla.md#typedefs) “30” “30”](parent-child.md) “30” “30”](Mesh.md)   TYPEDEFS FOR MESH AND MODEL ENTITIES   A mesh object (actually a pointer to it) in the interface can be declared as  PMeshObj mesh1, mesh2;   Mesh entity types are as follows:  / Mesh Regions */  PMeshRegn reg1, oreg, regarr[50];    / Mesh Vertices (nodes) */  PMeshVert vert, *verts. vert[20][30];  / Mesh Face */  PMeshFace rface;  / Mesh Edge */  PMeshEdge face_edges[4];  / Type of mesh region or element       */  / This is an enum decl which can be    */  / TET, PYRAMID, PRISM, HEX or RDELETED */  ElType reg_type;  / Type of mesh vertec */  / Can be VIGNORE, VPARENT, VDELETED */  VType vert_type;     Geometric model entity types are:  / Model entity - can be a region, face, edge or a vertex */  PGeomEntity  gent;  / Model region */  PGeomRegn greg;    / Model face */  PGeomFace gfaces[20], * *gfaces2, interface;  / Model edge - not used at this point */  PGeomEdge geds[], *gfeds;  / Model vertex - not used at this point */  PGeomVert gv1, gv2;  / Type of model entity - can be GREGION, GFACE, GEDGE, GVERTEX */  GType geomtype;    “30” “30”](mstkla.md#typedefs) “30” “30”](parent-child.md) “30” “30”](Mesh.md)",
    "tags": "",
    "url": "/pages/mstkla/prelim.html"
  },{
    "title": "RANKVOLUME",
    "text": "RANKVOLUME rankvolume prints out the lowest volume elements from a mesh, ranked in increasing order. The default is to print out the 100 lowest volume elements, but this number can be changed by specifying it as an optional second argument to the command. Also printed are the number of exterior boundary faces and number of interfaces faces for each of these elements. SYNTAX rankvolume/[number_of_elements_to_rank] EXAMPLES rankvolume/10 write 10 lowest volume elements in increasing order. The output will look like: elt. no. volume #ext.bound.faces #int.bound.faces 6 0.666667E+03 4 1 5 0.666667E+03 4 0 4 0.666667E+03 3 1 1 0.666667E+03 4 0 2 0.666667E+03 4 0 3 0.666667E+03 3 0 12 0.100000E+04 5 0 11 0.100000E+04 5 0 7 0.150000E+04 4 0 10 0.150000E+04 4 0",
    "tags": "rankvolume",
    "url": "/pages/docs/commands/rankvolume.html"
  },{
    "title": "REFINE2D",
    "text": "REFINE2D This routine deterministically refines a triangle by bisecting all the edges and connect these bisection points to form new triangles. Thus, after calling REFINE2D once, a triangle will be tessellated into 4 triangles. SYNTAX refine2d Examples The following command file will refine an input triangulation for resampling. read / avs / generic_source.inp / mo_z refine2d refine2d refine2d refine2d refine2d read / avs / generic_template.inp / mo_sink cmo / addatt / mo_z / zsave / vdouble / scalar / nnodes cmo / addatt / mo_sink / zsave / vdouble / scalar / nnodes cmo / copyatt / mo_z / mo_z / zsave / zic cmo / setatt / mo_z / zic / 1 0 0 / 0.0 cmo / setatt / mo_sink / zic / 1 0 0 / 0.0 interpolate / continuous / mo_sink / zsave / 1 0 0 / &amp; mo_z / zsave / nearest zsave cmo / copyatt / mo_sink / mo_sink / zic / zsave cmo / setatt / mo_sink / itetclr / 1 0 0 / 1 dump / gmv / generic_out.gmv / mo_sink finish",
    "tags": "refine2d",
    "url": "/pages/docs/commands/refine2d.html"
  },{
    "title": "FACE REFINEMENT",
    "text": "II. Refinement or Derefinement of Faces Each face is tested separately for refinement or derefinement. For the tetrahedral face defined by nodes 1, 2, and 3, we have where A is the area of the face. Criteria: 1) Junction: Refine if any of the faces field values straddle c. Tag for refinement if f(1) c and f(2), f(3) &lt; c or f(2) c and f(1), f(3) &lt; c or f(3) c and f(1), f(2) &lt; c or all of the above with &gt; instead of &gt;. example: For c = 0, refine if f changes sign between any of the three nodes. 2) Constant: Refine if any of the face field values exceed c. Tag for refinement if f(1) 2 or f(2) c or f(3) c. 3) Maxsize: Refine if the face area exceeds c. Tag if A &gt; c. 4) Aspect Ratio: Refine if the faces aspect ratio is less than c. The aspect ratio (AR) is defined as the ratio of the radius of the inscribed circle of the triangular face to the radius of the circumscribed circle. We renormalize this ratio of multiplying by 2 so that the ratio equals one for an equilateral triangle. AR = 2 RIN/ROUT where RIN = radius of inscribed circle ROUT = radius of circumscribed circle AR is never greater than one. Tag if AR &lt; c. Generally the smaller AR is the more elongated the face is. 5) Lambda Refine:** Refine if lamda/dx &lt; c. Where dx is taken to be the radius of the circumscribed circle RIN of the triangular face lambda = f(xcen)/grad f f(xcen) = (f(1) + f(2) +f(3))/3 where xcen is the centroid of the triangular face, and we have assumed a linear interpolation of f. grad f is evaluated on the face by a suitable approximation involving a linear interpolation of f and the line integral around the edge of the face.",
    "tags": "refine faces",
    "url": "/pages/docs/refine_faces.html"
  },{
    "title": "ELEMENT REFINEMENT",
    "text": "III. Refine or Derefine Tets: Each tetrahedron is tested separately for refinement or derefinement, where V is the volume of the tetrahedron. Criteria: 1) Junction: Refine if any of the tets field values straddle c. example: For c = 0 refine if f changes sign between any of the four nodes. **2) Constant: Refine if any of the tets field values exceed c. Tag for refinement if f(1) c or f(2) c or f(3) c or f(4) c 3) Maxsize: Refine if the tet volume exceeds c. Tag if V &gt; c 4) Aspect Ratio: Refine if the tet’s aspect ratio is less than c. For the tet the aspect ratio (AR) is defined as the ratio of the radius of the inscribed sphere of the tet to the radius of the circumscribed sphere. We renormalize this ratio by multiplying by three so that the ratio equals one for a regular tetrahedron (composed of equilateral triangular faces). AR = 3 RIN/ROUT, where RIN radius of inscribed sphere ROUT radius of circumscribed sphere AR is never greater than one. Tag if AR &lt; c. Generally the smaller AR is, the more elongated the tet is. 5) Lambda Refine: Refine if lamda/dx &gt; c . Where lambda is taken to be the radius of the circumscribed sphere ROUT of the tet. lambda = f(xcen) /grad f f(xcen) = (f(1) + f(2) + f(3) + f(4))/4 where xcen is the centroid of the tet, and we have assumed linear interpolations of f. grad f is evaluated for the tet by an approximation involving linear interpolation au the surface integral over the surface of the tet.",
    "tags": "refine elements",
    "url": "/pages/docs/refine_tets.html"
  },{
    "title": "Regions and Points to Tetrahedral Mesh",
    "text": "Regions and Points to Tetrahedral Mesh Generating Initial Grids Using the LaGriT Command Language The steps involved in generating three dimensional grids in the LaGriT command language are: Define mesh objects. Define an enclosing volume. Define interior interfaces. Divide the enclosing volume into regions. Assign material types to the regions. Distribute points within the volume. Connect the points into tetrahedra Detailed descriptions of the LaGriT commands are given in Section II. This tutorial covers just the commands needed to generate a simple grid. The tutorial will explain how to generate a grid in a unit cube containing two materials separated by a plane. Lines that begin with an asterisk (*) are comments; keywords are in bold. 1. Define mesh objects Define all Mesh Objects to be used in this problem using the cmo/create command. The cmo/create command establishes an empty Mesh Object data structure (see Section III.a for a description). For this example we will need only a single 3D Mesh Object: Create a 3D tetrahedral mesh object and name it 3dmesh: cmo/create/3dmesh/ 2. Define an enclosing volume Define an enclosing volume using the surface command. Since we are defining an exterior boundary, the boundary type is reflect. The next item of information needed is the geometry of the volume; some common geometry types are box, cylinder, and sphere. Geometry types box and sphere define closed volumes; whereas a cylinder is open on both ends and must be capped by planes. Along with the geometry type, the extent of the volume is defined by specifying for the box its corners, or for the cylinder its radius and end point of its axis of rotation. The enclosing volume must be convex. Complicated enclosing volumes can be described by their bounding surfaces including planes and sheets. Some simple examples of enclosing volumes are: Unit cube: surface/cube/reflect/box/0.0,0.0,0.0/1.0,1.0,1.0 Cylinder whose axis is the x axis with radius 1 and height 1: surface/cyl_vol/reflect/cylinder/0.,0.,0./1.,0.,0./1. surface/end1/reflect/plane/0.,0.,0./0.,0.,1./0.,1.,1. surface/end2/reflect/plane/1.,0.,0./1.,0.,1./1.,1.,1. 3. Define interior interfaces Interfaces are defined with the surface command. In this case the boundary type is intrface. If the command defines a volume (e.g. box, cylinder) then the interface is the surface of the volume defined. If the command defines a plane or sheet then the interface is the plane or sheet. It is important to remember that planes are infinite and that the order of points specifying the plane determines a normal to the plane in the usual right-hand-rule sense (see Section II.a.9). This direction is important in determining regions. In order to divide the unit cube defined above in half vertically, define a plane by: surface/cutplane/intrface/plane/0.,0.,.5/1.,0.,.5/1.,1.,.5 The normal to this plane points in the positive z direction. Interfaces must not be coincident with reflective boundaries. For example to embed a rectangle inside a cube, it is necessary to extend the ends of the rectangle beyond the cube to avoid coincident reflective and interface surfaces: surface/cube/reflect/box/0.0,0.0,0.0/1.0,1.0,1.0 surface/rect/intrface/box/-0.1,0.5,0.2/1.1,0.6,0.5 4. Divide the enclosing volumes into regions The region command is used to divide the enclosing volume into regions. The directional operators lt, le, gt, and ge are applied to previously defined surfaces according to the following rules. lt – if the surface following is a volume then lt means inside not including the surface of the volume. If the surface is a plane or a sheet lt means the space on the side of the plane or sheet opposite to the normal not including the plane or sheet itself. le – if the surface following is a volume then le means inside including the surface of the volume. If the surface is a plane or a sheet le means the space on the side of the plane or sheet opposite to the normal including the plane or sheet itself. gt – if the surface following is a volume then gt means outside not including the surface of the volume. If the surface is a plane or a sheet gt means the space on the same side of the plane or sheet as the normal not including the plane or sheet itself. ge – if the surface following is a volume then ge means outside including the surface of the volume. If the surface is a plane or a sheet ge means the space on the same side of the plane or sheet as the normal including the plane or sheet itself. In region comands, surface names must be preceeded by a directional operator. The logical operators or, and, and not mean union, intersection and complement respectively. Parentheses are operators and are used for nesting. Spaces are required as delimiters to separate operators and operands. To define the two regions created by the plane bisecting the unit cube: region/top/ le cube and gt cutplane region/bottom/ le cube and le cutplane The region bottom contains the interface cutplane; top contains none of the interface. Interior interfaces must be included in one and only one region. If a region touches an external boundary, include the surface that defines the enclosing volume in region and mregion commands. For example, the regions top and bottom are enclosed by the surface cube 5. Assign material types to the regions Assign materials to regions using the mregion command. This command has similar syntax to the region command except that the interface should not be assigned to any material region. To assign two materials, mattop and matbot, to the regions top and bottom: mregion/ mattop/ le cube and gt cutplane / mregion/ matbot/ le cube and lt cutplane / 6. Distribute points within the volume There are many methods of distributing points within a volume.  For simple geometries refer to the createpts command.  This example uses the regnpts command which, although more complicated, provides greate flexibility.  Points are distributed within regions using Cartesian, cylindrical or spherical coordinates by constructing rays that travel through regions and distributing points along these rays. For this example, points are distributed using Cartesian coordinates. The rays are specified by defining a set of points and a plane. For each point in the set, a ray is constructed normal to the plane passing through the point. In general rays are constructed in sets, each set is specified by a single plane and a set of points. The createpts command is used to create the points. The regnpts command is used to specify the plane, to specify the region, and to specify the number of points to be distributed along the rays. The points and the plane should lie outside the enclosing volume and on opposite sides. The normal to the plane should point toward the point. As rays are created, if they do not pass through the specified region, no points are distributed. Points may be spaced evenly along the ray or they may be spaced according to a ratio. The following commands will place points in the unit cube. # create 25 points (5x5x1) in a plane above the unit cube # place points on the boundaries in the x and y directions (1,1,0) createpts/xyz/5,5,1/0.,0.,1.1/1.,1.,1.1/1,1,0/ # give the points defined by the createpts command the name, rayend pset/rayend/seq/1,0,0/ # create rays between points in rayend and the plane below the cube # distribute 3 points along these rays in the region top # add one point at the upper external boundary for each ray regnpts/top/3/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/0,0/ # distribute 4 points along these rays in the region *bottom* # add one point at the lower external boundary for each ray # add one point at the material interface for each ray since # *bottom* contains the interface - a total of 5 points for each ray. # points will be distributed such that the ratio of distances between # any two consecutive pairs of points is 0.6 traveling from the source # of the ray (the plane) to the ray end. regnpts/bottom/4/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/1,.6/ Other versions of the regnpts are appropriate for cylindrical and spherical geometries. For cylindrical geometries the createpts command specifies points in a cylindrical shell outside the volume. The regnpts command specifies a line (usually the cylinder axis), and the rays are constructed normal to this line and containing one of the createpts points. For spherical geometries the createpts command specifies points in a spherical shell outside the volume. The regnpts command specifies a point (usually the center of the sphere) from which rays are constructed to the createpts points. 7. Connect the points into tetrahedra The mesh designer may use the following set of command to connect the points into a tetrahedral mesh: # eliminate coincident or nearly coincident points # 1,0,0 means consider all points filter/1,0,0/ # rayend points are set to invisible (21 is the code for invisible) # they were used as end points of the rays in the regnpts command cmo/setatt//itp/pset,get,rayend/21/ # assign material colors to the points # identify points that are on material interfaces # identify constrained points setpts # connect the points into a Delaunay tetrahedral mesh # do not connect across material interfaces - # add points if necessary to resolve material interfaces connect # set element (tetrahedral) type settets # dump mesh to some output form dump/gmv/filename # terminate processing finish Full Tutorial Code: # create a 3D tetrahedral mesh object and name it *3dmesh* cmo/create/3dmesh/ # unit cube surface/cube/reflect/box/0.0,0.0,0.0/1.0,1.0,1.0/ # define z=.5 plane as interface surface/cutplane/intrface/plane/0.,0.,.5/1.,0.,.5/1.,1.,.5/ # define geometric regions region/top/ le cube and gt cutplane/ region/bottom/ le cube and le cutplane / # define material regions mregion/mattop/ le cube and gt cutplane / mregion/matbot/ le cube and lt cutplane / # create 25 points (5x5x1) in a plane above the unit cube # place points on the boundaries in the x and y directions (1,1,0) createpts/xyz/5,5,1/0.,0.,1.1/1.,1.,1.1/1,1,0/ # give the points defined by the createpts command the name, rayend pset/rayend/seq/1,0,0/ # create rays between points in rayend and the plane below the cube # distribute 3 points along these rays in the region top # add one point at the upper external boundary for each ray regnpts/top/3/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/0,0/ # distribute 4 points along these rays in the region *bottom* # add one point at the lower external boundary for each ray # add one point at the material interface for each ray since # *bottom* contains the interface - a total of 5 points for each ray. # points will be distributed such that the ratio of distances between # any two consecutive pairs of points is 0.6 traveling from the source # of the ray (the plane) to the ray end. regnpts/bottom/4/pset,get,rayend/xyz/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/1,.6/ # eliminate coincident or nearly coincident points # 1,0,0 means consider all points filter/1,0,0/ # rayend points are set to invisible (21 is the code for invisible) # they were used as end points of the rays in the regnpts command cmo/setall//itp/pset,get,rayend/21/ # assign material colors to the points # identify points that are on material interfaces # identify constrained points setpts # connect the points into a Delaunay tetrahedral mesh # do not connect across material interfaces - # add points if necessary to resolve material interfaces connect # set element (tetrahedral) type settets # dump mesh to some output form dump/gmv/filename # terminate processing finish",
    "tags": "",
    "url": "/pages/tutorial/tutorials/regions_points_to_tet.html"
  },{
    "title": "LaGriT Release Notes",
    "text": "Release Notes LaGriT V3.3.3 2021 Release Open Source LA-CC-15-069 LaGriT V3.2 and V3.3.2 2017 Release Open Source LA-CC-15-069 LaGriT V3.1 2012 Release Added ExodusII Libraries LaGriT V3.0 2011 Release V3 64 bit LA-CC-07-084 LaGriT V2.002 2010 Release V2 Open Distribution LA-CC-07-038 LaGriT V1.1.4 2005 V1.1.3 and V1.1.4 Notes LaGriT V1.1.2 2003 to 2004 V1.1.1 and V1.1.2 Notes LaGriT V1 2002 Release YMP QA/QA STN: 10212-1.1-00 LaGriT V1.0.3 2001 V1.0.3 Notes LaGriT V1.0.2 2000 V1.0.1 to V1.0.2 Notes LaGriT V1.10 1999 V1.100 Notes LaGriT V1.00 1999 V1.00 Notes",
    "tags": "",
    "url": "/pages/release.html"
  },{
    "title": "Demo Stack Layers",
    "text": "Demo stack/layers Example 1 no buffers, no refinement, no truncation STACK TRI LAYERS into cmo name cmo1. Read 4 AVS triangulated surfaces into 3 materials. Stack and pinchout if layers cross. Label material colors with 1 on bottom and 3 on top. The syntax stack/layers/avs means stack a list of AVS triangle surface files. This is followed by a list of files with integers after each file, the first file in the list is the bottom, the last is the top. The first integer after each file name is the material value for cells between layers. (a second integer would be the refinement number, default is 0) cmo create cmo1 stack/layers/avs/ &amp; surf-12.inp 1 / surf-5.inp 2/ surf5.inp 3/ surf25.inp Screen output: ******************************************************************* * Example 1 * file: demo_tri_simple.in * stack/layers * no buffers, no refinement, no truncation ******************************************************************* * STACK TRI LAYERS into cmo name cmo1 * read 4 AVS triangulated surfaces into 3 material units * stack and pinchout if layers cross * label unit colors with 1 on bottom and 3 on top * details: * the syntax stack/layers/avs * means stack a list of AVS triangle surface files * this is followed by a list of files with integers after each file * the first file in the list is the bottom, the last is the top * the first integer after each file name is the material value * (a second integer would be the refinement number) * after the list of surface files, there are command options * the option \"pinch\" represents the thinness of a layer before * it is pinched out. If a layer crosses, the lower surface truncates. ********************************************************************* cmo create cmo1 stack/layers/avs surf-12.inp 1 surf-5.inp 2 surf5.inp 3 surf25.inp pinch 0. Layers to create: 4 Max material number: 4 Reading 4 surface files... ................................................................ surface name layer color type llcorner zic surf-12.inp 1 1 -1 1) -1.200000E+01 surf-5.inp 2 2 0 37) -5.000000E+00 surf5.inp 3 3 0 73) 5.000000E+00 surf25.inp 4 4 -2 109) 2.500000E+01 Elements per layer: 48 total: 192 Nodes per layer: 36 total: 144 STACK DONE: 4 files read out of 4 ................................................................ ********************************************************************* * STACK to PRISM to TET * convert stacked layers in cmo1 into a tet grid named cmotet * The stacked layers are filled to create a prism grid. * The prism grid is then converted to a tet grid. * hextotet will check cmo for mesh type then use hextotet/6 ********************************************************************* stack/fill/cmopri/cmo1/ hextotet// cmotet / cmopri boundary_components 1 different boundary components identified. 2 is a representative vertex finish LaGriT successfully completed   The following commands convert the stacked 2D layers into 3D volumes. In this example, triangles are stacked into prism elements. Each of the prism elements are then converted into 6 tet elements. The command boundary components will check for 1 single boundary. stack/fill/cmopri/cmo1/ hextotet/6/ cmotet / cmopri boundary_components finish Screen output: 1 different boundary components identified. 2 is a representative vertex   Example 2 Reverse Material Colors Stack/layers with material colors reversed. Material 1 (green) is now the top unit. Material 2 (purple) is middle and 1 (red) is bottom. The unit value was changed from above example on the command line: cmo/create/cmo1 stack/layers/avs/ surf-12.inp 3/ surf-5.inp 2/ surf5.inp 1/ surf25.inp 1 Screen output: cmo create cmo1 stack/layers/avs surf-12.inp 3 surf-5.inp 2 surf5.inp 1 surf25.inp 1 ................................................................ surface name layer color type llcorner zic surf-12.inp 1 3 -1 1) -1.200000E+01 surf-5.inp 2 2 0 37) -5.000000E+00 surf5.inp 3 1 0 73) 5.000000E+00 surf25.inp 4 1 -2 109) 2.500000E+01 Elements per layer: 48 total: 192 Nodes per layer: 36 total: 144 STACK DONE: 4 files read out of 4 ................................................................ Example 3 buffered Stack quad layers and fill with hex elements, with buffered interfaces. Read 6 AVS quad surfaces into 5 material units. Label unit colors with 1 on bottom and 5 on top. Stack and pinchout if layers are closer than .19 meters. Add a buffer layer .2 meters above and below each interface. Truncate by 5th file to read. Note the &amp; character added so command line is not too long to read. cmo/create/cmo1 stack/layers/avs &amp;   q-1.inp   1   &amp;   q0.inp    2   &amp;   qhole.inp 3   &amp;   q3.inp    4   &amp;   qtop.inp  5   &amp;   q5.inp    5   &amp;   truncate 5 / buffer .2 / pinch .19 stack/fill/cmohex/cmo1 Screen output: ******************************************************** * file: demo_quad_buffers.in * stack/layers * buffers, truncation, no refinement ******************************************************** * STACK QUAD LAYERS into cmo named cmo1 * Read 6 AVS quad surfaces into 5 material units * label unit colors with 1 on bottom and 5 on top * stack and pinchout if layers closer than .19 meters * add a buffer layer .2 meters above and below each interface * truncate by 5th file to read cmo create cmo1 stack/layers/avs &amp; q-1.inp 1 &amp; q0.inp 2 &amp; qhole.inp 3 &amp; q3.inp 4 &amp; qtop.inp 5 &amp; q5.inp 5 &amp; truncate 5 / buffer .2 / pinch .19 ................................................................ surface name layer color type llcorner zic q-1.inp 1 1 -1 1) -1.000000E+00 buffer 2 1 1 34) -2.000000E-01 q0.inp 3 2 0 67) 0.000000E+00 buffer 4 2 1 100) 2.000000E-01 buffer 5 2 1 133) 8.000000E-01 qhole.inp 6 3 0 166) 1.000000E+00 buffer 7 3 1 199) 1.000000E+00 buffer 8 3 1 232) 1.000000E+00 q3.inp 9 4 0 265) 1.000000E+00 buffer 10 4 1 298) 1.000000E+00 buffer 11 4 1 331) 1.000000E+00 qtop.inp 12 5 0 364) 1.000000E+00 buffer 13 5 1 397) 1.200000E+00 q5.inp 14 5 -2 430) 5.000000E+00 Elements per layer: 20 total: 280 Nodes per layer: 33 total: 462 Layers truncated by qtop.inp layer 12 STACK DONE: 6 files read out of 6 STACK DONE: 8 layers created for total 14 ................................................................ * STACK to HEX to TET * convert stacked layers in cmo1 into a tet grid named cmotet stack/fill/cmohex/cmo1 hextotet// cmotet / cmohex * CHECK the GRID * boundary_components should return 1 boundary * otherwise there are holes in the mesh quality boundary_components Example 4 tri layers to prisms tri layer to prism then to tet with truncating surface and layer refinement. STACK TRI LAYERS into cmo named cmo1. Read 5 AVS triangulated surfaces into 4 material units. Label unit colors with 1 on bottom and 3 on top. Stack and pinchout if layers cross. Add two layers for refinement in second unit. Note layer type attribute: -1 is bottom, -2 is top surface 0  is surface read from file 1  is layer derived between surface at constant distance 2  is layer derived between surface at proportional distance cmo create cmo1 stack/layers/avs    &amp;   surf-12.inp      1   &amp;   surf-5.inp       2   &amp;   surf5.inp        3 2 &amp;   surf2_slope.inp  4   &amp;   surf25.inp       4   &amp;   truncate 4 / pinch 0. stack/fill/ cmopri /cmo1 hextotet // cmotet / cmopri Screen output: ................................................................ surface name layer color type llcorner zic surf-12.inp 1 1 -1 1) -1.200000E+01 surf-5.inp 2 2 0 37) -5.000000E+00 refine 3 2 2 73) -1.666667E+00 refine 4 2 2 109) 1.666667E+00 surf5.inp 5 3 0 1) 5.000000E+00 surf2_slope.inp 6 4 0 181) 1.800000E+01 surf25.inp 7 4 -2 217) 2.500000E+01 Elements per layer: 48 total: 336 Nodes per layer: 36 total: 252 Layers truncated by surf2_slope.inp layer 6 STACK DONE: 5 files read out of 5 ................................................................ Back to STACK",
    "tags": "stack layers fill",
    "url": "/pages/docs/stack_demo.html"
  },{
    "title": "Demo Stack Layers",
    "text": "Demo stack/layers Feature: truncating surface cmo/create/cmo1 stack/layers/avs/ surf-12.inp 1/ surf-5.inp 2/ surf5.inp 3/surf_slope3.inp 4/ surf25.inp 4 / trunc 4 / pinch 0. stack/fill/ mohex /cmo1 Read 5 surface files, truncate by 4th surface. No buffers at interfaces, no refinements. ................................................................ surface name layer color type llcorner zic surf-12.inp 1 1 -1 1) -1.200000E+01 surf-5.inp 2 2 0 37) -5.000000E+00 surf5.inp 3 3 0 73) 5.000000E+00 surf_slope3.inp 4 4 0 109) 1.800000E+01 surf25.inp 5 4 -2 145) 2.500000E+01 Elements per layer: 48 total: 240 Nodes per layer: 36 total: 180 Layers truncated by surf_slope3.inp layer 4 STACK DONE: 5 files read out of 5 ................................................................ Feature: truncating surface and buffered interfaces cmo create cmo1 stack/layers/avs/ surf-12.inp 1/ surf-5.inp 2/ surf5.inp 3/ &amp; surf_slope3.inp 4/ surf25.inp 4 / trunc 4 / buffer 1. pinch 0. stack/fill/ mohex / cmo1 Read 5 surface files, truncate by 4th surface. buffers at interfaces, no refinements. ................................................................ surface name layer color type llcorner zic surf-12.inp 1 1 -1 1) -1.200000E+01 buffer 2 1 1 37) -6.000000E+00 surf-5.inp 3 2 0 73) -5.000000E+00 buffer 4 2 1 109) -4.000000E+00 buffer 5 2 1 145) 4.000000E+00 surf5.inp 6 3 0 181) 5.000000E+00 buffer 7 3 1 217) 6.000000E+00 buffer 8 3 1 253) 1.700000E+01 surf_slope3.inp 9 4 0 289) 1.800000E+01 buffer 10 4 1 325) 1.900000E+01 surf25.inp 11 4 -2 361) 2.500000E+01 Elements per layer: 48 total: 528 Nodes per layer: 36 total: 396 Layers truncated by surf_slope3.inp layer 9 STACK DONE: 5 files read out of 5 STACK DONE: 6 layers created for total 11 Feature: truncation with no refinement cmo create cmo1 stack/layers/avs/surf-12.inp 1/surf-5.inp 2/surf5.inp 3/surf_slope3.inp 4/ trunc 4 / pinch 0. stack/fill/ moprism / cmo1 Read 4 surface files, truncate by last surface. No buffers at interfaces, no refinements. ................................................................ surface name layer color type llcorner zic surf-12.inp 1 1 -1 1) -1.200000E+01 surf-5.inp 2 2 0 37) -5.000000E+00 surf5.inp 3 3 0 73) 5.000000E+00 surf_slope3.inp 4 4 -2 109) 1.800000E+01 Elements per layer: 48 total: 192 Nodes per layer: 36 total: 144 Layers truncated by surf_slope3.inp layer 4 STACK DONE: 4 files read out of 4 ................................................................ Feature: truncate, buffers, no refinement cmo create cmo1 stack/layers/avs/surf-12.inp 1/surf-5.inp 2/surf5.inp 3/surf\\_slope3.inp 4/ trunc 4 / buffer 1. pinch 0. stack/fill/ moprism / cmo1 Read 5 surface files, truncate by last surface. buffers at interfaces, no refinements.` Warnings are from post-processer that checks buffer points. It happens because there is not a buffer under the truncated surface. IMPLEMENTATION QUESTION: Should this top layer be buffered? As is, code does not buffer the top layer, just the interfaces. WARNING: znext for buffer not found 13 6 0.500000E+01 WARNING: znext for buffer not found 14 6 0.500000E+01 WARNING: znext for buffer not found 15 6 0.500000E+01 WARNING: znext for buffer not found 16 6 0.500000E+01 ................................................................ surface name layer color type llcorner zic surf-12.inp 1 1 -1 1) -1.200000E+01 buffer 2 1 1 37) -6.000000E+00 surf-5.inp 3 2 0 73) -5.000000E+00 buffer 4 2 1 109) -4.000000E+00 buffer 5 2 1 145) 4.000000E+00 surf5.inp 6 3 0 181) 5.000000E+00 buffer 7 3 1 217) 6.000000E+00 surf_slope3.inp 8 4 -2 253) 1.800000E+01 Elements per layer: 48 total: 384 Nodes per layer: 36 total: 288 Layers truncated by surf_slope3.inp layer 7 Feature: bead on a string algorithm bead 0 buffer 2. pinch 0. unit 2 thickness = 1. SUMMARY VOLUME/AREA of ELEMENT COLORS Color nelem volume fractional volume 1 288 0.2140000E+05 0.180743243 2 432 0.1620000E+04 0.013682432 3 432 0.2618000E+05 0.221114865 4 288 0.6920000E+05 0.584459459 bead 1 buffer 2.  / dpinch 0.0  dmin 1. Post process node changes =         76 unit 2 thickness = 2.0 SUMMARY VOLUME/AREA of ELEMENT COLORS Color nelem volume fractional volume 1 288 0.1942000E+05 0.164020270 2 432 0.3600000E+04 0.030405405 3 432 0.2618000E+05 0.221114865 4 288 0.6920000E+05 0.584459459 bead 3 buffer 2. /  dpinch .0   dmin 1.5   move 3 unit 2 thickness = 3. SUMMARY VOLUME/AREA of ELEMENT COLORS Color nelem volume fractional volume 1 288 0.1706000E+05 0.144087838 2 432 0.5400000E+04 0.045608108 3 432 0.2674000E+05 0.225844595 4 288 0.6920000E+05 0.584459459 bead 4 buffer 2. / dpinch .0   dmin 1.5    move 2 SUMMARY VOLUME/AREA of ELEMENT COLORS Color nelem volume fractional volume 1 288 0.2140000E+05 0.180743243 2 432 0.5400000E+04 0.045608108 3 432 0.2430000E+05 0.205236486 4 288 0.6730000E+05 0.568412162 bead 5 buffer 2. / dpinch .0   dmin 1.5   move 1 SUMMARY VOLUME/AREA of ELEMENT COLORS Color nelem volume fractional volume 1 288 0.1923000E+05 0.162415541 2 432 0.5400000E+04 0.045608108 3 432 0.2552000E+05 0.215540541 4 288 0.6825000E+05 0.576435811 bead 2 - last image buffer 2. / dpinch 1.0   dmin 2.0 SUMMARY VOLUME/AREA of ELEMENT COLORS Color nelem volume fractional volume 1 288 0.2284000E+05 0.192905405 2 432 0.0000000E+00 0.000000000 3 432 0.2636000E+05 0.222635135 4 288 0.6920000E+05 0.584459459 Back to STACK",
    "tags": "stack layers fill",
    "url": "/pages/docs/stack_demo2.html"
  },{
    "title": "",
    "text": "\"30\" \"30\"](mstkla.md#MODEL%20ENTITY:) **Trivia** How to pronounce MSTKLA? Well..... MSTKLA is the precursor to MSTK. It is hoped that the underlying structure of MSTK will be all new code independent of LaGriT. However, since we are using LaGriT as the underlying structure for now, the toolkit is called MSTKLA. M-S-T-K rolls off the tongue nicely, not so M-S-T-K-L-A. Therefore, judging by the people's first reaction to the name (the second reaction is Blechhhch!!), why not pronounce it as *misticlaa*? Rao P.S.: Sorry, I am lousy at christening pieces of code!! Just take a look at my API...  ",
    "tags": "",
    "url": "/pages/mstkla/trivia.html"
  },{
    "title": "",
    "text": " \"30\" \"30\"](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#UTILITIES:) \"30\" \"30\"](http://www.ees.lanl.gov/staff/rao/mstkla/GeomVertex.md) \"30\" \"30\"](http://www.ees.lanl.gov/staff/rao/mstkla/example.md) \"169\" \"131\" ------------------------------------------------------------------------ ------------------------------------------------------------------------    **UTILITIES:** ------------------------------------------------------------------------   *void* **ReportError**(*char* *modulename, *char* *message, *ErrType* severity); Report an error message. The severity may be specified as **MESSG**: Print a message to the screen **WARNING**: Print message with additional attention grabbing text **ERROR**: Print message with additional attention grabbing text **FATAL**: Print attention grabbing message and exit.     ------------------------------------------------------------------------ ------------------------------------------------------------------------  \"31\" \"12\" **VECTOR FUNCTIONS:** ------------------------------------------------------------------------ *void* **vdiff**(*double* *a, *double* *b, *double* *a\\_minus\\_b); ------------------------------------------------------------------------ *void* **vsum**(*double* *a, *double* *b, *double* *a\\_plus\\_b); ------------------------------------------------------------------------ *double* **vmag2**(*double* *v); ------------------------------------------------------------------------ *double* **vmag**(*double* *v); ------------------------------------------------------------------------ *void* **vcross**(*double* *a, *double* *b, *double* *a\\_cross\\_b); ------------------------------------------------------------------------ *double* **vdot**(*double* *a, *double* *b); ------------------------------------------------------------------------ *void* **vnorm**(*double* *a, *double* *unita); ------------------------------------------------------------------------ ------------------------------------------------------------------------   ** \"31\" \"12\"REAL NUMBER COMPARISON FUNCTIONS:** ------------------------------------------------------------------------   *int* **REAL\\_le**(*double* a, *double* b); ------------------------------------------------------------------------ *int* **REAL\\_ge**(*double* a, *double* b); ------------------------------------------------------------------------ *int* **REAL\\_eq**(*double* a, *double* b); ------------------------------------------------------------------------   ------------------------------------------------------------------------ ------------------------------------------------------------------------  \"31\" \"12\" **COMP GEOM FUNCTIONS:** ------------------------------------------------------------------------ *int* **pntInTriangle2**(*double* *pnt, *double* ( *tri)[3], *double* tol, *int* flag, *int* *mtype, *int* *locID);   Check if a point that is guaranteed to be in the plane of a triangle is inside the triangle itself. If **flag = 1**, check if point is strictly inside     **flag = 0**, check if point is inside or on the boundary within a real tolerance 'tol' Return **value =  1 (inside), 0 (outside), -1 (on boundary)** If point is on the boundary, **mtype** indicates type of entity it is on **locID** indicates the local ID number of the vertex or edge it is on   ------------------------------------------------------------------------ *int* **pntInTet**(*double* *pnt, *double* ( *tet)[3], *double* tol, *int* flag, *int* *mtype, *int* *locID); Check if a point is inside a tet If **flag = 1**, check if point is strictly inside     **flag = 0**, check if point is inside or on the booundary               within a real tolerance 'tol' Return **value =  1 (inside), 0 (outside), -1 (on boundary)** If point is on the boundary, **mtype** indicates type of entity it is on **locID** indicates the local ID number of the vertex or edge it is on   ------------------------------------------------------------------------ *void* **Tri\\_CircumCen**(*double* ( *xyz)[3], *double* *cen); ------------------------------------------------------------------------ *double* **Tri\\_Area**(*double* ( *xyz)[3]); ------------------------------------------------------------------------ *void*   **Tri\\_Normal**(*double* ( *xyz)[3], *double* *normal); ------------------------------------------------------------------------ *double* **Tet\\_Volume**(*double* ( *xyz)[3]); ------------------------------------------------------------------------ *void*   **Tet\\_CircumCen**(*double* ( *xyz)[3], *double* *cen); ------------------------------------------------------------------------          \"30\" \"30\"](http://www.ees.lanl.gov/staff/rao/mstkla/mstkla.md#UTILITIES:) \"30\" \"30\"](http://www.ees.lanl.gov/staff/rao/mstkla/GeomVertex.md) \"30\" \"30\"](http://www.ees.lanl.gov/staff/rao/mstkla/example.md)",
    "tags": "",
    "url": "/pages/mstkla/utilities.html"
  },{
    "title": "LaGriT Commands by Category",
    "text": "LaGriT Commands by Category =========================== ## Geometry Commands: [GEOMETRY](/pages/docs/commands/geometry.html) (set the geometry name) [MREGION](/pages/docs/commands/MREGION.html) (define a material region) [OFFSETSURF](/pages/docs/commands/OFFSETSURF.html) (..triangulated surface) [REGION](/pages/docs/commands/REGION.html) (define a geometric region) [RZS](/pages/docs/commands/RZS.html) (depreciated, see createpts) [SURFACE](/pages/docs/commands/SURFACE.html) (define a geometric surface) ## Point Placement: [COPYPTS](/pages/docs/commands/COPYPTS.html) (copy existing points) [CREATEPTS](/pages/docs/commands/createpts.html) (create points) [QUADXY](/pages/docs/commands/QUADXY.html) (define a logical xy node set) [QUADXYZ](/pages/docs/commands/QUADXYZ1.html) (define a logical xyz node set) [RZAMR](/pages/docs/commands/RZAMR.html) (depreciated, see createpts) [REGNPTS](/pages/docs/commands/REGNPTS.html) (distributes nodes in region) [REFINE2D](/pages/docs/commands/refine2d.html) (refine a triangle) [REORDER](/pages/docs/commands/REORDER.html) (reorder nodes in a mesh) [RZ](/pages/docs/commands/RZ.html) (depreciated, see createpts) [RZRAN](/pages/docs/commands/RZRAN.html) (depreciated, see createpts) [SURFPTS](/pages/docs/commands/SURFPTS.html) (make nodes on a surface) ## Point Modification and Selection: [COORDSYS](/pages/docs/commands/COORDSY.html) (change coordinate system) [COPYPTS](/pages/docs/commands/COPYPTS.html) (copy existing points) [FILTER](/pages/docs/commands/FILTER.html) (filter nodes) [PERTURB](/pages/docs/commands/PERTURB.html) (perturb node locations) [PSET](/pages/docs/commands/PSET.html) (define, name sets of nodes) [PSTATUS](/pages/docs/commands/PSTATUS.html) (operate on point set) [RESETPTS](/pages/docs/commands/RESETPT.html) (reset node values) [RM](/pages/docs/commands/RM.html) (remove nodes in area) [RMMAT](/pages/docs/commands/RMMAT.html) (remove a material) [RMPOINT](/pages/docs/commands/RMPOINT.html) (remove nodes/elements) [RMREGION](/pages/docs/commands/RMREGION.html) (remove a geometric region) [RMSPHERE](/pages/docs/commands/RMSPHERE.html) (remove nodes in a sphere) [RMSURF](/pages/docs/commands/RMSURF.html) (remove nodes in /on a surface [ROTATELN](/pages/docs/commands/ROTATELN.html) (rotate nodes about a line) [ROTATEPT](/pages/docs/commands/ROTATEPT.html)  (rotate nodes about a point) [SCALE](/pages/docs/commands/SCALE.html) (scale node coordinates) [TRANS](/pages/docs/commands/TRANS.html) (translate node coordinates) [ZQ](/pages/docs/commands/UNG2AVS.html) (depreciated, see cmo/setatt) ## Connecting the Mesh: [CONNECT](/pages/docs/commands/CONNECT1.html) (make tetrahedral mesh) [GENIEE](/pages/docs/commands/GENIEE.html) (make element connectivity) [RZBRICK](/pages/docs/commands/RZBRICK.html) (create a brick, hex mesh) [SETPTS](/pages/docs/commands/SETPTS.html) (set node type and material) [SETTETS](/pages/docs/commands/SETTETS.html) (make child nodes, set element material) [TRIANGULATE](/pages/docs/commands/TRIAGN.html) (make triangles) ## Element Modification and Selection: [ELTSET](/pages/docs/commands/ELTSET2.html) (select, name a set of elements) [FSET](/pages/docs/commands/FSET.html) (define a face set) [RMPOINT](/pages/docs/commands/RMPOINT.html) (remove nodes/elements) ## Creating, modifying, assessing and deleting mesh objects and their attributes: [ADDMESH](/pages/docs/commands/ADDMESH.html) (join meshes) [BOUNDARY](/pages/docs/commands/BOUNDAR1.html) (set attributes on surfaces) [BOUNDARY_COMPONENTS](/pages/docs/commands/BOUNDARY_C.html) (count boundary edges) [CALC_RDIST](/pages/docs/commands/calc_rdist.html) (calculate radial distance) [CMO](/pages/docs/commands/CMO2.html) (modify mesh object) [COLORMAP](/pages/docs/commands/COLORMAP.html) (build adjacency map) [COMPUTE](/pages/docs/commands/COMPUTE.html) (compute a new mesh attribute) [COPYPTS](/pages/docs/commands/COPYPTS.html) (copy points) [CREATE_GRAPH](/pages/docs/commands/create_graph.html) (create adjacency graph) [DOPING](/pages/docs/commands/DOPING1.html) (set an attribute; depreciated, see interpolate) [EXTRACT](/pages/docs/commands/EXTRACT1.html) (extract a surface) [EXTRUDE](/pages/docs/commands/extrude.html) (extrude a surface) [FIELD](/pages/docs/commands/FIELD.html) (manipulate a field attribute) [GRID2GRID](/pages/docs/commands/GRID2GRID.html) (element type conversion) [INTERPOLATE](/pages/docs/commands/main_interpolate.html) (interpolate attribute values from nodes or elements ) [INTERSECT](/pages/docs/commands/INTERSECT.html) (intersect 2d meshes to get line) [INTERSECT_ELEMENTS](/pages/docs/commands/intersectelements.html) (intersect mesh elements) [KDTREE](/pages/docs/commands/kdtree.html) (represent mesh as kd-tree) [LOWER_D](/pages/docs/commands/lower_d.html) (create lower dimen. structs.) [MATH](/pages/docs/commands/MATH.html) (do math on attributes) [QUALITY](/pages/docs/commands/QUALITY.html) (evaluate mesh quality) [RANKVOLUME](/pages/docs/commands/rankvolume.html)(list small volume elements) [SORT](/pages/docs/commands/SORT.html) (sort an attribute) [UPSCALE](/pages/docs/commands/UPSCALE.html) (attribute from fine to coarse grid) ## Optimize or customize the mesh: [BUBBLE](/pages/docs/commands/bubble.html) (extrude to 3d and extract bndry) [CRUSH_THIN_TETS](/pages/docs/commands/crush_thin_tets.html) (reduce number of thin tets) [DEREFINE](/pages/docs/commands/DEREFINE.html) (merge nodes away) [HEXTOTET](/pages/docs/commands/HEXTOTE.html) (convert element types) [MASSAGE](/pages/docs/commands/MASSAGE.html)(optimize the grid) [MASSAGE2](/pages/docs/commands/MASSAGE.html)(optimize the grid) [MERGE](/pages/docs/commands/MERGE.html) (remove nodes) [METIS](/pages/docs/commands/MERGE.html) (graph partition algorithms) [MODE](/pages/docs/commands/MODE.html) (set modes) [RADAPT](/pages/docs/commands/RADAPT.html) (adaptive smoothing) [RECON](/pages/docs/commands/RECON.html) (swap edges/faces) [REFINE](/pages/docs/commands/REFINE.html) (refine elements, edges) [SETSIZE](/pages/docs/commands/SETSIZE.html) (calc size of space, set epsilon) [SMOOTH](/pages/docs/commands/SMOOTH.html) (node smoothing) ## Input/Output: [DEFINE](/pages/docs/commands/DEFINE.html) (give a name to a number) [DUMP](/pages/docs/commands/DUMP2.html) (write output files) [DUMP_RECOLOR](/pages/docs/commands/DUMP_RECOLOR.html) (use adjacency map) [EDIT](/pages/docs/commands/EDIT2.html) (prints some mesh info) [HELP](/pages/docs/commands/HELP.html) (print global variable) [INFILE](/pages/docs/commands/INPUT.html) (read input from a file) [INPUT](/pages/docs/commands/INPUT.html) (read input from a file) [LOG](/pages/docs/commands/LOG.html) (turn log file off and on) [MEMORY](/pages/docs/commands/memory.html) (query state of memory) [READ](/pages/docs/commands/READ.html) (read data) [STACK](/pages/docs/commands/STACK.html) (read, merge surfaces) [UNG2AVS](/pages/docs/commands/UNG2AVS.html) (UNGenerate to AVS) ## Validation, Manipulation: [ASSIGN](/pages/docs/commands/ASSIGN.html) (set global variables) [ELMTEST](/pages/docs/commands/elmtest.html) (validate connectivity) [FINISH](/pages/docs/commands/FINISH.html) (end processing, EXIT) [LOOP](/pages/docs/commands/loop.html) (execute command multiple times) [NEGATIVE_AIJ](/pages/docs/commands/NEGATIVE.html) (test bndry for neg. coef.) [RZV](/pages/docs/commands/RZV_LG.html) (depreciated, see createpts)",
    "tags": "",
    "url": "/pages/commands_cat.html"
  },{
    "title": "Pictures Created By Denise George",
    "text": "Pictures Created By Denise George ---------------------------------",
    "tags": "",
    "url": "/pages/denise.html"
  },{
    "title": "LaGriT Code Development Team",
    "text": "LaGriT Code Development Team ---------------------------- [Carl W. Gable](http://www.lanl.gov/search-capabilities/profiles/carl-gable.shtml) Author (Retired from LANL) [Terry Miller](http://www.lanl.gov/search-capabilities/profiles/terry-miller.shtml) Support [Jeffrey De'Haven Hyman](http://www.lanl.gov/search-capabilities/profiles/jeffrey-hyman.shtml) Applications [Tinka Gammel](http://public.lanl.gov/jtg/) Denise George (Retired) [Andrew Kuprat](http://www.pnnl.gov/science/staff/staff_info.asp?staff_num=7019) Frank A. Ortega [Harold Trease](http://www.sysbio.org/resources/staff/trease.stm) Retired from LANL [Lynn Trease](http://www.sysbio.org/resources/staff/l-trease.stm) Retired from LANL Robert B. Walker",
    "tags": "",
    "url": "/pages/development.html"
  },{
    "title": "",
    "text": "**3. Define interior interfaces** Interfaces are defined with the **[surface](/pages/docs/commands/SURFACE.html)** command. In this case the boundary type is **intrface**. If the command defines a volume (e.g. box, cylinder) then the interface is the surface of the volume defined. If the command defines a plane or sheet then the interface is the plane or sheet. It is important to remember that planes are infinite and that the order of points specifying the plane determines a normal to the plane in the usual right-hand-rule sense ([see Section II.a.9](/pages/docs/conventions.html)). This direction is important in determining regions. In order to divide the unit cube defined above in half vertically, define a plane by: **surface**/cutplane**/intrface** **/plane**/0.,0.,.5/1.,0.,.5/1.,1.,.5 The normal to this plane points in the positive z direction. Interfaces must not be coincident with reflective boundaries. For example to embed a rectangle inside a cube, it is necessary to extend the ends of the rectangle beyond the cube to avoid coincident reflective and interface surfaces: **surface**/cube**/reflect** **/box**/0.0,0.0,0.0/1.0,1.0,1.0 **surface**/rect **/intrface/box**/-0.1,0.5,0.2/1.1,0.6,0.5",
    "tags": "",
    "url": "/pages/docs/DEFINEII.html"
  },{
    "title": "LaGriT References",
    "text": "# LaGriT References To reference LaGriT in a publication use the following citation: Los Alamos Grid Toolbox, LaGriT, Los Alamos National Laboratory, &lt;http://lagrit.lanl.gov&gt;, *year_of_lagrit_version*. For example: Los Alamos Grid Toolbox, LaGriT, Los Alamos National Laboratory, &lt;http://lagrit.lanl.gov&gt;, 2013. 1.  Kuprat, Andrew, \"[Modeling Microstructure Evolution using Gradient-Weighted Moving Finite Elements \" LA-UR-98-4879, submitted to SIAM J. Sci. Comp. (1998). 2.  Kuprat, Andrew and George, Denise, \"[Maintaining Tetrahedral Mesh Quality in Response to Time-DependentTopological    and Geometrical Deformation \", LA-UR--5187, Proceedings of the 6th International Conference on  Numerical Grid Generation in Computational Field Simulations, M. Cross (ed.), International Society of Grid Generation  (ISBN 0-9651627), pp. 5-598, May 1998. 3.  George, Denise, \"[Unstructured Toolbox for Modeling and Simulation\" , LA-UR--3052, presented at the 19 Workshop on Computational Electronics and Nanoelectronics, Urbana, Illinois, October 20-22, 19. 4.  Kuprat, Andrew; Cartwright David; Gammel J. Tinka; George Denise; Kendrick Brian; Kilcrease David; Trease Harold;  and Walker, Robert,[\"X3D, Moving Grid Methods for Semiconductor Applications\" ,LA-UR--21. 5.  Kuprat, Andrew, \"[Adaptive Smoothing Techniques for 3-D Unstructured Meshes \", LA-UR-96-1 (1996). 6.   Kuprat, Andrew, Denise George, Eldon Linnebur, Harold Trease , R. Kent Smith, \"[Moving Adaptive Unstructured 3-D  Meshes in Semiconductor Process Modeling Applications \", LA-UR-95-4128, VLSI Design, Vol. 6(1-4), (1998),  pp373-378. 7.  Khamayseh, Ahmed; Ortega,Frank; Trease, Harold, \"Ray Tracing for Point Distribution in Unstructured Grid Generation\",  LA-UR-95-4470 (1995). 8.  Kuprat, Andrew and Khamayseh, Ahmed, \"[Non-Parametric Volume Conserving Smoothin g, LA-UR-98-3381 (1998). 9.  Khamayseh, Ahmed and Kuprat, A, \"[Anisotropic Smoothing and Solution Adaption for Unstructured Grids, \"   LA-UR-95-2205, International Journal for Numerical Methods in Engineering, Vol. 39, pp. 3163-3174 (1996). 10.  Khamayseh, Ahmed; Ortega,Frank; Kuprat, Andrew, \"A Robust Point Location Algorithm for General Polyhedra\",   LA-UR-95-4465 (1995). 11.  Khamayseh, A., and Kuprat, A., \"Surface Grid Generation Systems,\" LA-UR--87, CRC Handbook ofGrid Generation,  ed. Joe Thompson , CRC Press, (ISBN 0849326877), (1998). 12.  Khamayseh, A., Kuprat, A., and W. Mastin, \"Boundary Orthogonality in Elliptic Grid Generation\", LA-UR--3827, CRC Handbook of Grid Generation, ed. 13.  Gammel, J. Tinka and Kuprat, Andrew, \"Modeling Metallic Microstructure Using Moving Finite Elements\", presented at the Computational and Theory Symposium Pacific Coast Meeting of the American Ceramic Society, IRvine, CA, Oct.  21-24, 1998. 14.  Gammel, J. Tinka; Kuprat, A; Carlson, N.N.; George D.C, \"Modeling Metallic Microstructure: OrientationDependence\",to be presented at the APS meeting, March 1999. 15.  Denise C. George, Andrew P. Kuprat, \"[Optimizing 3D Tetrahedral Grids \"  Theoretical Division - Self Assessment, April 2000. LA-UR-00-1.",
    "tags": "",
    "url": "/pages/docs/References.html"
  },{
    "title": "FEHMN Stor File Format",
    "text": "# FEHMN Stor File Format The sparse matrix data file is both an input and an output file the FEHM application uses for storing or reading geometric coefficients associated with a finite element mesh. The sparse matrix data file is read during FEHM initialization if being used for input. The generated name is of the form filename.stor and can be written in ascii or binary (unformatted) mode. The stor file is written with \"blocks\" of information data in the following format. 1. ASCII Header consisting of 2 lines giving code version information, date, and time. 2. Single line with matrix integer parameters; number_coefs, nodes, memory_size, num_area_coefs, max_num_connections. 3. List of Voronoi Volumes associated with each node. 4. List indicating the number of entries for each row of the matrix. If a node in a mesh has N edge connections, this number is N+1. 5. Connectivity list. Row i is a list of all nodes j1, j2, j3... connected to node i. The list contains the matrix diagonal entry, i. 6. Pointers or index numbers into the last block containing values for area coefficients. 7. List of Geometric area coefficients. In general this is the area of each face of the Voronoi polygon associate with node i, face j ## ASCII Header Lines ``` fehmstor ascir8i4 LaGriT Sparse Matrix Voronoi Coefficients Thu Jul 25 08:41:03 20193-D Linear Diffusion Model (matbld3d_astor) ``` Title Line: The first line consists of a character string of 72 or less characters. Characters 14-17 should be labled as one of r4i4 r4i8 r8i4 r8i8. This signifies the number of bytes used for reals 'r' and integers 'i'. For instance, r8i4 means 8 byte reals, 4 byte integer. The second word also contains information stating whether the file is binary or ASCII (text). If it is ASCII, then characters 10-16 should be 'asci.' If it is binary, then characters 10-16 should be 'ieee'. Date Line: The second line contains a character string of 72 or less characters. This line contains a time stamp of when the file was written and the code option used for writing this file. ## Matrix Parameters ``` 3 12 65 1 5 ``` The Parameter line has integer values: NUM_WRITTEN_COEFS, NEQ, NCOEF+NEQ+1, NUM_AREA_COEF, and optional value NCON_MAX. NUM_WRITTEN_COEFS: is the number coefficient values written in the .stor file. If compression is not used, then this is number is equal to the number of connections in the grid. If compression is used, each unique value will be written once and pointers will reference the appropriate value. NEQ: signifies the number of equations and is equivalent to the number of nodes in a triangular or tetrahedral grid. NCOEF+NEQ+1: is a value used to allocate memory in FEHM for the integer pointers. NUM_AREA_COEF: Can be (1,3, or 4) number of area coefficients. The area/distance coefficients are the area of a Voronoi face divided by the Delaunay edge length. This coefficient is either written as a scalar (1), a vector area (3), or both vector and scalar areas are written (4). NCON_MAX: is an optional parameter indicating the maximum number of connections to a single node in the entire mesh. This is used for memory allocation. If omitted, FEHM will default to a value that might cause problems in highly unstructured meshes. ## Voronoi Volumes ## ``` 1.250000000000E-01 2.500000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 2.500000000000E-01 2.500000000000E-01 2.500000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 ``` This block has NEQ (number of nodes) floating point values which are the Voronoi Volumes associated with each node. Each mesh node is a voronoi center for the volume. So nodes on the boundary will have a fractional volume, for instance a 90 degree corner node will have half or quarter volumes compared to the nodes internal to the mesh. A bottom node will have half the volume of nodes above and internal given the same spacing. ## Row Counts for Matrix ## ``` 13 17 22 26 30 34 39 44 49 53 57 61 65 ``` The purpose of this block is to indicate the number of specified entries each row of the matrix contains. (All unspecified entries are assumed to be 0). The representation is circuitous. There are a total of NEQ+1 entries. The first entry is the value NEQ+1. The second entry is the value NEQ+1+the number of connections the in the first row. The third entry is value of the second entry + the number of connections in the second row. In general, the ith entry (for i1) is the i-1th entry + the number of specified entries in the row i-1. In this way, the difference between the i+1st and the ith value indicates how many entries row i has in the matrix. In the above example the matrix has 13 entries as indicated in the first number (12 nodes + 1). After the first, there are 12 numbers, each representing the number of values in each row of the matrix. ## Row Entries ## ``` 1 2 3 2 3 ``` This block is used to state which entries of the matrix are explicitly represented. Since we know the number of entries per row, (given above), we can do this by stating which columns of each row are represented. In above example we have a 3x3 matrix, use these numbers in the following manner: The first row has specified entries in the first, second, and third columns (i.e, entries (1,1), (1,2) and (1,3) are specified ; the second row has an entry specified in the second column entry (i.e., (2,2)); the third row has an entry specified in the third column (i.e. (3,3)). ## Indices into Coefficient List ## This block contains NCOEF integer pointers to entries to the Coefficient Block (described below.) The actual values of a matrix entry can be repeated many times, particularly in a matrix arising from the discretization of a structured mesh. Because floating point values require more storage than integers, we have set up the following data structure to allow compression: View the floating point values as two dimensional array of dimensions NUM_WRITTEN_COEFS by NUM_AREA_COEF. To represent a matrix entry, give the index of value contained in the floating point values block here. If a 0 is given, then the writer of the .stor file has explicitly stated he wants the value to be 0.0. Following the NCOEF integer pointers are: 1) NEQ+1 0's for padding and 2) a set of NEQ+1 integer pointers stating which pointers correspond to diagonal elements. ## Geometric Area Coefficient Values ## ``` -5.000000000000E-01 -2.500000000000E-01 0.000000000000E+00 ``` This block contains NUM_WRITTEN_COEFS x NUM_AREA_COEF floating point values. NUM_AREA_COEF = 1 The scalar area for each connection a(i=1,k). This is the default. NUM_AREA_COEF = 3 The vector area for each connection in the order a_x(i=1,k), a_y(i=1,k), a_z(i=1,k). NUM_AREA_COEF = 4 The vector areas first followed by the scalar area. Note that a(i) = sqrt(a_x^2 + a_y^2 + a_z^2) Note the negative values because flow is from high to low. The flow (energy/temperature, fluid/Darcy) is governed by the diffusion equation q = C x grad(P) The geometric part of the equation is area/distance. The area comes in for figuring out the mass flow given the material properties, gradient, etc. The distance is use in computing grad(P). The negative comes in because the grad(P) vector points from low to high P, but flow is from high to low. ## LaGriT Output ## In addition to the .stor file, LaGriT writes a summary to the screen and file output. This includes information useful to the modeler such as the min and max voronoi volumes (should be greater or equal to zero), total voronoi volume, and possible negative coupling coefficients which can occur on non-convex boundaries. ``` # use default format for ASCII file with compression dump/stor/ tet / cmotet *** Construct and Compress Sparse Matrix:3D *** *** Compress Area Coefficient Values *** AMatbld3d_stor: Matrix compress_eps: 0.1000000E-07 AMatbld3d_stor: Local epsilon: 0.1000000E-14 SparseMatrix initialize epsilon to 1.000000e-08 SparseMatrix using Epsilon 1.000000e-08 AMatbld3d_stor: *****Zero Negative Coefficients ****** AMatbld3d_stor: Number of 'zero' (< compress_eps) coefs 0 AMatbld3d_stor: npoints = 12 ncoefs = 52 AMatbld3d_stor: Number of unique coefs = 3 AMatbld3d_stor: Maximum num. connections to a node = 5 AMatbld3d_stor: Volume min = 1.2500000E-01 AMatbld3d_stor: Volume max = 2.5000000E-01 AMatbld3d_stor: Total Volume: 2.0000000E+00 AMatbld3d_stor: abs(Aij/xij) min = 0.0000000E+00 AMatbld3d_stor: abs(Aij/xij) max = 5.0000000E-01 AMatbld3d_stor: (Aij/xij) max = 0.0000000E+00 AMatbld3d_stor: (Aij/xij) min = -5.0000000E-01 AMatbld3d_stor Matrix coefficient values stored as scalar area/distance AMatbld3d_stor Matrix compression used for graph and coefficient values ascii STOR file written with name tet.stor *** SPARSE COEFFICIENT MATRIX _astor SUCCESSFUL *** 3D Matrix Coefficient file written with name tet.stor ``` ## Example STOR file compress all, graph and coef (astor) ## This is the default stor format and will compress values into an ASCII file. (Binary files can only be read on machines they have been written on). This provides the smallest possible file size based on the number of unique coefficient values in the mesh. This example file is summarized in the above output report. ``` fehmstor ascir8i4 LaGriT Sparse Matrix Voronoi Coefficients Thu Jul 25 14:23:32 20193-D Linear Diffusion Model (matbld3d_astor) 3 12 65 1 5 1.250000000000E-01 2.500000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 2.500000000000E-01 2.500000000000E-01 2.500000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 13 17 22 26 30 34 39 44 49 53 57 61 65 1 2 3 4 1 2 7 8 11 1 3 5 8 1 4 5 7 3 4 5 6 5 6 7 8 12 2 4 6 7 9 2 3 6 8 10 7 9 11 12 8 10 11 12 2 9 10 11 6 9 10 12 3 2 2 2 2 3 1 1 2 2 3 2 2 2 3 2 2 2 2 3 2 2 3 1 1 2 1 2 1 3 2 1 2 1 3 2 2 3 2 2 2 3 2 2 2 2 2 3 2 2 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 14 19 24 28 33 36 43 48 51 55 61 65 -5.000000000000E-01 -2.500000000000E-01 0.000000000000E+00 ``` ## Example STOR file with no compression (nstor) ## This is used if you want a file with all values in the matrix written, no compression. ``` fehmstor ascir8i4 LaGriT Sparse Matrix Voronoi Coefficients 08/14 10:23:54 20093-D Linear Diffusion Model (matbld3d_nstor) 46 8 55 1 8 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 9 14 22 27 32 37 42 50 55 1 2 3 5 7 1 2 3 4 5 6 7 8 1 2 3 4 7 2 3 4 7 8 1 2 5 6 7 2 5 6 7 8 1 2 3 4 5 6 7 8 2 4 6 7 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 46 0 0 0 0 0 0 0 0 0 10 16 25 30 35 40 49 55 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 ``` ## Example STOR file with coef compression but no graph compression (cstor) ## ``` fehmstor ascir8i4 LaGriT Sparse Matrix Voronoi Coefficients 08/13 15:40:06 20093-D Linear Diffusion Model (matbld3d_cstor) 2 8 55 1 8 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 9 14 22 27 32 37 42 50 55 1 2 3 5 7 1 2 3 4 5 6 7 8 1 2 3 4 7 2 3 4 7 8 1 2 5 6 7 2 5 6 7 8 1 2 3 4 5 6 7 8 2 4 6 7 8 1 2 2 2 1 2 1 1 2 1 2 1 1 2 1 1 2 2 2 2 1 1 2 2 1 1 2 2 2 2 1 1 2 1 1 2 1 2 1 1 2 1 2 2 2 1 0 0 0 0 0 0 0 0 0 10 16 25 30 35 40 49 55 0.000000000000E+00 -2.500000000000E-01 ``` ## Example STOR file with coef compression off and graph compression on (gstor) ## ``` fehmstor ascir8i4 LaGriT Sparse Matrix Voronoi Coefficients 08/13 15:40:06 20093-D Linear Diffusion Model (matbld3d_gstor) 20 8 41 1 4 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 9 13 17 21 25 29 33 37 41 1 2 3 5 1 2 4 6 1 3 4 7 2 3 4 8 1 5 6 7 2 5 6 8 3 5 7 8 4 6 7 8 1 2 3 4 2 5 6 7 3 8 9 10 6 9 11 12 4 13 14 15 7 14 16 17 10 15 18 19 12 17 19 20 0 0 0 0 0 0 0 0 0 10 15 19 24 27 32 36 41 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 -2.500000000000E-01 0.000000000000E+00 ``` ## Example STOR file compress all, graph and coef (astor) ## This is the default stor format and provides the smallest possible file size based on the number of unique coeficient values in the mesh. ``` fehmstor ascir8i4 LaGriT Sparse Matrix Voronoi Coefficients 08/13 15:40:06 20093-D Linear Diffusion Model (matbld3d_astor) 2 8 41 1 4 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 1.250000000000E-01 9 13 17 21 25 29 33 37 41 1 2 3 5 1 2 4 6 1 3 4 7 2 3 4 8 1 5 6 7 2 5 6 8 3 5 7 8 4 6 7 8 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 2 0 0 0 0 0 0 0 0 0 10 15 19 24 27 32 36 41 -2.500000000000E-01 0.000000000000E+00 ```",
    "tags": "",
    "url": "/pages/docs/STOR_Form.html"
  },{
    "title": "",
    "text": "**Array Compression** The following utility routines compress arrays. Note that the output array may be the same as the input array in which case the compression is done in place. Also the mask array may be the same as the input array. The name suffixes of the compression routine may be decoded as **m** minus (negative), **n** non-zero, **p** positive, **z** equal to zero. If the routine name ends in **rrr**, the mask, input and output arrays are all real. If the name ends in a single **r** , the mask is real, the input and output arrays are integers. Otherwise the mask, input and output arrays are all integers. For example kmprsn(100, int, 1, int, 1, int, 1, num) will compress all the zeros out of array int. :x n              length of z and x z               array of masks iz              stride in z x               array of source ix              stride in x y               array of output iy              stride in y count       length of y **kmprsn(n, z, iz, x, ix, y, iy, count)** **kmprsnr(n, z, iz, x, ix, y, iy, count)** **kmprsnrrr(n, z, iz, x, ix, y, iy, count)** **kmprsp(n, z, iz, x, ix, y, iy, count)** **kmprspr(n, z, iz, x, ix, y, iy, count)** **kmprsz(n, z, iz, x, ix, y, iy, count)** **kmprszr(n, z, iz, x, ix, y, iy, count)**",
    "tags": "",
    "url": "/pages/docs/arrcomp.html"
  },{
    "title": "",
    "text": "**Array sorting** The following utility routines sort arrays. **hpsort1(n, ra, ascend, iprm)** --------- --------------------------------------- n number of elements to be sorted ra  a real array ascend  real which controls direction of sort iprm  integer arry to be reordered --------- --------------------------------------- **hpsorti(n, ia)** ---- --------------------------------- n  number of elements to be sorted ia integer array to be sorted ---- --------------------------------- **hpsortim(n, m, md, itemp, ia)** ------- -------------------------------------------------------------- n     no. of columns to sort into ascending order m     maximum number of keys (rows) to consult for comparisons md      column length of array IA (M&lt;=MD) itemp     temp array of length MD. ia     integer array of MD-tuples to be reordered ------- -------------------------------------------------------------- **hpsortimp(n, m, md, ia, ascend, iprm)** -------- -------------------------------------------------------------------- n no. of elements to be sorted m we interpret array IA as M-tuples md actual first dimension of arry IA ia integer array of values which determine how IPRM will be reordered ascend real *8 which controls direction of sort. iprm integer array to be reordered -------- -------------------------------------------------------------------- (this routine available but not distributed - contact site manager)   **hpsort(n, ra)** ---- --------------------------------------- n          no. of elements to be sorted ra          real *8 array to be sorted ---- --------------------------------------- **hpsortrmp(n, m, md, a, ascend, iprm)** -------- ------------------------------------------------------------------------- n no. of elements to be sorted m array A is treated a M-tuples md actual first dimension of A a real *8 array to be used in ordering  IPRM ascend real *8 to control ascending descending sort order (1=ascend, 0=descend) iprm integer array that will be reordered -------- ------------------------------------------------------------------------- **hpsortip(n, ia, ascent, iprm)** -------- --------------------------------------------------------------------------- n number to sort ia integer array that determines ho IPRM will be sorted ascend real *8 that controls if sort order is ascending or descending (1=ascend) iprm sorted array of integers  -------- ---------------------------------------------------------------------------",
    "tags": "",
    "url": "/pages/docs/arrsort.html"
  },{
    "title": "",
    "text": "**5. Assign material types to the regions** Assign materials to regions using the [**mregion**](/pages/docs/commands/MREGION.html) command. This command has similar syntax to the **[region](/pages/docs/commands/REGION.html)** command except that the interface should not be assigned to any material region. To assign two materials, *mattop* and *matbot,* to the regions *top* and *bottom:* **mregion**/ mattop/ **le** cube **and gt** cutplane / **mregion**/ matbot/ **le** cube **and lt** cutplane /",
    "tags": "",
    "url": "/pages/docs/assignmt.html"
  },{
    "title": "",
    "text": "**Character Length** The following functions are provided to return character string length (number of characters in iword ignoring terminator character). **icharln**(iword) Get length by searching forward for first blank or null. **icharlnf**(iword) Ignore leading blanks then search for terminating blank or null. **icharlnb**(iword) Search backwards for first non-blank or non-null - uses FORTRAN function **len** to give starting point (this is a risky assumption). **nulltoblank\\_lg**(iword, length) iword is the character string that will be searched for null characters. All null characters will be replaced by blanks. length is the number of characters in iword.",
    "tags": "",
    "url": "/pages/docs/charlen.html"
  },{
    "title": "",
    "text": "--- title: GENIEE tags: geniee, connectivity --- # GENIEE ----------------- Generate the element the connectivity list (jtet array). The **jtet** attribute contains for each facet of an element the neighboring element and its local face.  For 3D grids the jtet relationship is reflexsive; each element-face pair has exactly one neighboring element-face pair.  For 2D grids the jtet relationship can include cycles; a triangle or quad edge may have many edge neighbors.  In this case the jtet is constructed as a closed cycle where the jtet of one element-edge pair will be a neighboring element-edge pair whose jtet wil be another neighboring element-edge pair and so on until all neighbors are included in the cycle exactly once. The **jtet** is constructed by looking at matching node numbers and will use the parent nodes if they exist.  Faces with matching node coordinates but different node numbers will not be matched. For hybrid grids that contain degenerate elements there are two options.  If the mesh object attribute **jtet_reduce_nnd** exists and is set to 1, then faces with repeated node numbers will be matched to faces with the same numbers but not repeated.  For example if a degenerate hex has a face 1 1 2 3 and there is an element (prism, tet, pyramid) with face 1 2 3 and if **jtet_reduce_nnd** is 1, then these faces will be matched.  Otherwise they will be marked as external boundary faces. ## SYNTAX geniee geniee / mo_name / 2dnormal / reference_element_number / [ addatt ] **`geniee`** with no arguments will generate element the connectivity list (jtet) that gives neighbor information. Element connectivity is maintained within LaGriT, but can also be generated by the user with this command. `mo_name` is the mesh object to operate on. Can be / / or /-def-/ **`2dnormal`** Check or change the topological orientation (itet array) of a triangle, quad, or hybrid tri/quad mesh consistent so that shared edges are traversed in opposite directions. This is only possible in a mesh with **jtet_loop_max** = 2. For networks with **jtet_loop_max** &gt; 2 there may not be a configuration that meets the goal. `reference_element_number` - Default value is 1. This is the element number that will be the reference element that all other elements are compared to. If this parameter is a negative number, the orientation of element number abs(`reference_element_number`) is reversed and then used as the reference. `reference_element_number` = 0 will check and report if orientation is consistent, but will not do any flipping. For example this command will check and report orientation without making any changes: geniee / -def- / 2dnormal / 0 This command can be used to flip the normals of a mesh that is already consistent. For example: geniee / -def- / 2dnormal / -1 **addatt** is optional keyword that will create two new arrays ipath and ifflip to the mesh object. ipath - The order in which elements are visited. ifflip - 0 if the element orientation was NOT changed, 1 if the element orientation was changed. Note the ifflip array will not make sense for jtet loops greater than 2 for which there is no single solution. Note: For the case where a mesh is not completely edge connected, this module will detect that all elements have not been tested and will warn the user and suggest a command line syntax to test elements not visited. Note: Code not set up for a mesh with parent/child chains. When check is made, it compares child points. When permutation of elements is done, only itet and jtet arrays are updated. ## EXAMPLES geniee / cmo / 2dnormal Check orientation of tri/quad elements and if their orientation is different than element 1, then flip their orientation. geniee / cmo/2dnormal/-1 Flip the orientation of element one and then make the rest of the mesh consistent with element 1. If the mesh object is already consistent, then this command will reverse the orientation of all the elements in a surface (tri, quad) mesh. geniee / -def- / 2dnormal / 17 Check orientation of tri/quad elements and if their orientation is different than element 17, then flip their orientation. geniee / cmo / 2dnormal / 0 Check orientation of tri/quad elements and if their orientation is different than element 1, report the difference but do not change the mesh object orientation. geniee / cmo / 2dnormal / 0 / addatt Check orientation of tri/quad elements and if their orientation is different than element 1, report the difference but do not change the mesh object orientation. Create two new attributes: ipath is the search path the algorithm followed through the mesh. ifflip reports the orientation of each element as compared to element 1. ## Testing Topology or watertightness for Multi-Materials For a single material watertight mesh, there will be no boundaries, that is **geniee** will report no more than 2 jtet loops. If you run **boundary_components** the result will show \"0 different exterior boundary components\". For a watertight mesh, each edge needs to appear in (at least) two facets, but can appear in more than two. For instance if a surface is extracted on a 2 material mesh, the material boundary faces will also be extracted. These boundary faces will share an edge with outside faces so that 3 faces share a single edge. **geniee** will report as shown in this example with 4 boundary edges and no more than 3 faces sharing an edge: geniee: mesh has 4 jtet loops, max cycle length = 3 The basic test is to compute a face graph of the mesh. We visit all cells and look across the face and ask if I look across face i of cell J what is the cell m and face n on the other side. If the answer is, nothing is on the other side the face is labeled as 'boundary'. The tests are not geometric, they are topological. The test is on the cell connectivity list. That is if cell a has edge i,j then we are looking in the connectivity list for a cell with edge j,i (or i,j). In general in a 'good' mesh we expect the shared edge to be traversed in the opposite direction. However, in the multi-material models where 3 (or more) triangles share an edge, we cannot expect the edges to be traversed in opposite directions.",
    "tags": "",
    "url": "/pages/docs/commands/GENIEE.html"
  },{
    "title": "",
    "text": "--- title: LOG tags: log --- # LOG --------------------- Turn the batch output file and tty output file **off** and **on**. The tty prints to and reads from the user's screen. The batch file is the output file called outx3dgen. Default is **on** for both files. ## SYNTAX ``` log / ba or ty / on or off ``` ## EXAMPLES ``` log/ty/off ```",
    "tags": "",
    "url": "/pages/docs/commands/LOG.html"
  },{
    "title": "",
    "text": "Notes on connect algorithm: Connect uses the standard point insertion method of tetrahedralization which consists of the following steps: First an enclosing tetrahedra is constructed which contains the nodes to be tetrahedralized. Then the nodes are processed in a random order and inserted one at a time. To insert node n+1: Find a tetrahedra whose circumsphere contains node n+1.  Place this tetrahedron on the stack.  Pop a tetrahedron off the stack.  Look at all face neighbors of this containing tetrahedron to determine if their circumspheres contain node n+1.  Place the containing neighbor tetrahedra onto the stack.  Continue until the stack is empty.  Keep track of the set of containing tetrahedra as the stack is depleted.  The union of these tetrahedra is the insertion cavity into which the new node is placed; so we remove the containing tetrahedra and construct new tetrahedra by connecting the new node to the faces of the cavity. If for some reason a node cannot be inserted, it is placed in a fail list and subsequent passes will attempt to insert the node by using looser 'inside' tests. When all nodes are inserted, we inspect all edges to see if there are any edges that cross material interfaces. If so we construct a node at the intersection of the edge and interface.  These new nodes (if any) are then inserted into the mesh using the algorithm described above.  This process is repeated until no more 'multi-material' edges are encountered or until the maximum number of iterations is reached.  This step is skipped if the **noadd** option has been specified. Finally the initial enclosing tetrahedron vertices and the attached tetrahedra are removed. To determine if a node is 'inside' a tetrahedron's circumsphere we compare the distance from the tetrahedron's voronoi point to a vertex of the tetrahedron (i.e. the circumsphere radius) with the distance from the voronoi point to the node in question.  If the second distance is less than the first, the node is 'inside' the circumsphere.  Obviously the comparison of these distances should involve an epsilon which is dependent upon both the machine accuracy and the problem scale.  For computational efficiency we compare the distances squared. Currently the 'inside' test is as follows: Since we are comparing distances squared the appropriate test is an area test.  We construct a variable called **smalarea** = [ ((machine precision) *10,000) * *(boxsizex *boxsizey *boxsizez) * *(2.d0/3.d0)] where boxsize is the (max coordinate value - min coordinate value) in each of the 3 directions, machine precision is usually around 2 *10-16 for double precision. So for a unit cube the test value is about 7 *10-11. For a 1000x1000x1000 cube the test value is about .07. For the first pass we use smalarea *100. We loop until no more nodes can be added using this value. For the second pass we use smalarea For the third pass smalarea/100. For the fourth pass we use zero For the fifth pass we use -100 *smalarea The inside test requires that the coordinates of the circumcenter of the new tetrahedra be calculated.  As this calculation uses the squares of the coordinates of the vertices, we first translate the tetrahedron so that the coordinates one of its vertices lie at zero.  This simplifies the calculation and avoids loss of precision when the values of the coordinates are very large.  After calculating the coordinates of the circumcenter, the tetrahedron and its circumcenter are translated back to their original location. As the insertion cavity is filled with new tetrahedra, the new tetrahedra are subjected to two tests.  The first test checks that the volume of each new tetrahedron is positive.  This test uses a volume epsilon that represents the smallest volume that can be handled computationally.  We use the mesh object attribute **epsilonv** which is set to [ ((machine precision) *1000) * *(boxsizex *boxsizey *boxsizez)].  The second test compares the sum of the volumes of the new tetrahedra to the sum of the volumes of the removed tetrahedra.  This test fails if: [ (volnewt-vololdt)/vololdt &gt; machine precision *10 * *8]. The user can change the 'tightness' of the circumsphere test by adding an attribute to the mesh object called **circumsphere\\_factor** and setting this factor, e.g.: **cmo** **/addatt**/**/circumsphere\\_factor** **/REAL** **/scalar** **/scalar** **cmo** **/setatt**/**/circumsphere\\_factor**/1,0,0/.125 This factor will only be required in extreme circumstances.  If a node distribution has an extremely high aspect ratio, the user might see warning messages about circumsphere problems and connect may fail to connect all nodes.  In this case one might try adjusting the circumsphere\\_factor. The requirement for a delaunay tessellation is that the circumcircle or circumsphere of each element enclose no other nodes in the tessellation.  If nodes on the boundary of the mesh are nearly coplanar or nearly collinear, it is possible that the big tetrahedron or big triangle constructed automatically will not be large enough.  For illustration purposes consider the 2D case in which there are 3 nodes on the boundary that are nearly collinear say (0,0,0) (.5,.05,0.) and (1,0,0), then the circumcircle determined by these three nodes is very large and may contain node(s) of the big triangle, and the triangle consisting of these three nodes will not be formed.   In this case it is necessary for the user to supply the coordinates of the 'big' triangle in the connect command.",
    "tags": "",
    "url": "/pages/docs/connect_notes.html"
  },{
    "title": "",
    "text": "**7. Connect the points into tetrahedra** The mesh designer may use the following set of command to connect the points into a tetrahedral mesh: * eliminate coincident or nearly coincident points * 1,0,0 means consider all points **[filter](/pages/docs/commands/FILTER.html)/1,0,0**/ * rayend points are set to invisible (21 is the code for invisible) * they were used as end points of the rays in the regnpts command **[cmo](/pages/docs/commands/cmo/cmo_setatt.html)/setatt//itp/pset,get,rayend/21**/ * assign material colors to the points * identify points that are on material interfaces * identify constrained points **[setpts](/pages/docs/commands/SETPTS.html)** * connect the points into a Delaunay tetrahedral mesh * do not connect across material interfaces - add points if necessary o resolve material interfaces **[connect](/pages/docs/commands/CONNECT1.html)** * set element (tetrahedral) color * spawn child points at material interfaces **[settets](/pages/docs/commands/SETTETS.html)** * dump mesh to some output form **dump** **/gmv**/filename * terminate processing **[finish](/pages/docs/commands/FINISH.html)** The complete input for the tutorial is: * create a 3D tetrahedral mesh object and name it *3dmesh* **cmo/create**/3dmesh/ * unit cube **surface**/cube**/reflect** **/box**/0.0,0.0,0.0/1.0,1.0,1.0/ * define z=.5 plane as interface **surface** /cutplane**/intrface/plane/0.,0.,.5/1.,0.,.5/1.,1.,.5**/ *define geometric regions **region**/top**/ le** cube **and gt** cutplane ** ** / **region**/bottom**/ le** cube **and le** cutplane / *** define material regions** **mregion**/mattop**/ le** cub**e and gt** cutplane / **mregion**/matbot**/ le** cube **and lt** cutplane / * create 25 points (5x5x1) in a plane above the unit cube * place points on the boundaries in the x and y directions (1,1,0) **createpts/xyz**/5,5,1/0.,0.,1.1/1.,1.,1.1/1,1,0/ * give the points defined by the createpts command the name, rayend **pset**/rayend**/seq**/1,0,0/ * create rays between points in rayend and the plane below the cube * distribute 3 points along these rays in the region top * add one point at the upper external boundary for each ray **regnpts**/top/3**/pset**,**get**,rayend**/xyz**/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/0,0/ * distribute 4 points along these rays in the region *bottom* * add one point at the lower external boundary for each ray * add one point at the material interface for each ray since * *bottom* contains the interface - a total of 5 points for each ray. * points will be distributed such that the ratio of distances between * any two consecutive pairs of points is 0.6 traveling from the source * of the ray (the plane) to the ray end. **regnpts**/bottom/4**/pset**,**get**,rayend**/xyz**/0.,0.,-.1/0.,1.,-.1/1.,1.,-.1/1,.6/ * eliminate coincident or nearly coincident points * 1,0,0 means consider all points **filter/1,0,0**/ * rayend points are set to invisible (21 is the code for invisible) * they were used as end points of the rays in the regnpts command **cmo/setall//itp/pset,get,**rayend/21** **/ * assign material colors to the points * identify points that are on material interfaces * identify constrained points **setpts** * connect the points into a Delaunay tetrahedral mesh * do not connect across material interfaces - * add points if necessary to resolve material interfaces **connect** * set element (tetrahedral) type **settets** * dump mesh to some output form **dump/gmv**/filename * terminate processing **finish**",
    "tags": "",
    "url": "/pages/docs/connecttet.html"
  },{
    "title": "Conventions",
    "text": "# Conventions Following in Section II.b is a alphabetic list of the LaGriT commands. Conventions that apply to all commands include: - Lines are a maximum of 80 characters long, identifiers are a maximum of 32 characters long. - Continuation lines are signaled by an \"&\" as the last character of a line to be continued. A command can be up to 1024 characters long. - Delimiters are comma, slash, equal sign, or blank. (',' '/', '=', ' '). Blanks on either side of other delimiters are ignored. Leading blanks are ignored. Commas are usually used for parameters that belong to the same logical set such as first point, last point, stride. Slashes are usually used to separate sets of parameters. - The three parameters: first point, last point, stride can have integer values which refer to actual sequential point numbers or they can have the character- string values: **[pset](/pages/docs/commands/PSET.html)**, **get**, name where name has been defined by a previous **[pset](/pages/docs/commands/PSET.html)** command. The triplet: `1, 0, 0` refers to all points. The triplet: `0, 0, 0` refers to the set of points defined in the last geometry command. - Commands should be typed in lower case, however names are case sensitive. In the command description that follows certain symbols have special meaning. - `[ ]`          surround optional parameters - `,` or `/`      separates parameters - \\_\\_\\_        underline specifies default - **bold** is used for literal keywords such as **xyz**. - Comments are identified by \\# or \\* in the first column. Comments are parsed; avoid using special characters especially `&` in comments. - All names (`surface`, `region`, `pset`, ...) should be limited to 32 characters. - The right hand rule is used to determine normals to planes and to sheet surfaces. The first two points determin the first vector and the first and third point determine the second vector. By curling the fingers of the right hand from the first vector toward the second vector, the right thumb will point in the direction of the normal. - To separate commands on the same line use a semicolon (`;`). - Three coordinate systems are used. **xyz** refers to the standard Cartesian coordinate system **rtz** refers to a cylindrical coordinate system aligned along the z-axis, where **r** is the radius measured from the zaxis, **t** (theta) is the angle measured in the xy-plane from the positive x-axis toward the positive y-axis and **z** is the height measured from the xy-plane. **rtp** refers to a spherical coordinate system, where **r** is the radius measured from the origin, **p** (phi) is the angle in the xy-plane measured from the positive x-axis toward the positive y-axis, **t** (theta) is the angle measured from the positive z-axis to the positive y axis.",
    "tags": "",
    "url": "/pages/docs/conventions.html"
  },{
    "title": "",
    "text": "**2. Define an enclosing volume** Define an enclosing volume using the [**surface**](/pages/docs/commands/SURFACE.html) command. Since we are defining an exterior boundary, the boundary type is **reflect**. The next item of information needed is the geometry of the volume; some common geometry types are **box**, **cylinder**, **sphere.** Geometry types, **box** and **sphere,** define closed volumes; whereas a **cylinder** is open on both ends and must be capped by planes**.** Along with the geometry type, the extent of the volume is defined by specifying for the box its corners, or for the cylinder its radius and end point of its axis of rotation. The enclosing volume must be convex. Complicated enclosing volumes can be described by their bounding surfaces including planes and sheets . Some simple examples of enclosing volumes are: **Unit cube**: **surface**/cube**/reflect** **/box**/0.0,0.0,0.0/1.0,1.0,1.0 \"237\" \"212\" **Cylinder whose axis is the x axis with radius 1 and height 1**: **surface/cyl\\_vol/reflect/cylinder**/0.,0.,0./1.,0.,0./1. **surface/end1/reflect/plane**/0.,0.,0./0.,0.,1./0.,1.,1. **surface/end2/reflect/plane**/1.,0.,0./1.,0.,1./1.,1.,1.",
    "tags": "",
    "url": "/pages/docs/defineev.html"
  },{
    "title": "",
    "text": "**1. Define mesh objects** Define all Mesh Objects to be used in this problem using the[**cmo** **/create**](/pages/docs/commands/cmo/cmo_create.html) command. The[**cmo** **/create**](/pages/docs/commands/cmo/cmo_create.html) command establishes an empty Mesh Object data structure ([see Section III.a](/pages/docs/meshobject.html) for a description). For this example we will need only a single 3D Mesh Object: * create a 3D tetrahedral mesh object and name it 3dmesh cmo/create/3dmesh/",
    "tags": "",
    "url": "/pages/docs/definemo.html"
  },{
    "title": "Example: Use Spherical Hex Mesh to Stack Layers into Cylinder Hex Mesh",
    "text": "# Example: Use Spherical Hex Mesh to Stack Layers into Cylinder Hex Mesh This demo shows how these commands are used to create a quad surface that is stacked into a cylinder shaped mesh. ### Step 1 createpts/interp Interpolate cube onto sphere to create hex mesh. LaGriT command file: [full_sphere.lgi.txt](/pages/docs/demos/input/full_sphere.lgi.txt) LaGriT report file: [full_sphere.out.txt](/pages/docs/demos/output/full_sphere.out.txt) ### Step 2 extract/surfmesh Extract 2D quad surface from hex sphere. LaGriT command file: [extract_2d_surf.lgi.txt](/pages/docs/demos/input/extract_2d_surf.lgi.txt) LaGriT report file: [extract_2d_surf.lgi.txt](/pages/docs/demos/output/extract_2d_surf.out.txt) ### Step 3 stack/layers Stack 2D quad surfaces into 3D hex cylinder mesh. LaGriT command file: [stack_into_cylinder.lgi.txt](/pages/docs/demos/input/stack_into_cylinder.lgi.txt) LaGriT report file: [stack_into_cylinder.lgi.txt](/pages/docs/demos/output/stack_into_cylinder.out.txt) ### Step 4 dump Write mesh formats exodus, avs, gmv. LaGriT command file: [write_mesh_formats.lgi.txt](/pages/docs/demos/input/write_mesh_formats.lgi.txt) LaGriT report file: [write_mesh_formats.out.txt](/pages/docs/demos/output/write_mesh_formats.out.txt)",
    "tags": "",
    "url": "/pages/docs/demos/demo_creatept_interp.html"
  },{
    "title": "",
    "text": "Example 1: addmesh / add The objective is to join two meshes to create a third using the **addmesh / add** command. Two cubes, one smaller than the other, each having a different grid resolution are combined. The **add** option finds the intersection and refines one mesh to interface with the boundary of the other mesh using cell volume ration criterion. Input [lagrit_input_add](/pages/docs/demos/input/lagrit_input_add.txt) Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description1_add.html"
  },{
    "title": "",
    "text": "Example 1: createpts in a rectangular geometry The objective is to add points to a rectangular mesh using the **createpts** command. A rectangular geometry is defined. The **createpts/xyz** command is used to create a point distribution within the geometry exercising various options available to the command. The output consists of one gmv file. Input [lagrit_input_createxyz](/pages/docs/demos/input/lagrit_input_createxyz.txt) Images of GMV output:",
    "tags": "",
    "url": "/pages/docs/demos/description1_xyz.html"
  },{
    "title": "Example: 3D connect/noadd for non-convex boundary",
    "text": "# Example: 3D connect/noadd for non-convex boundary **`connect / noadd`** with input points from a hex mesh created with **`stack/layers`**. This example has a non-convex boundary and bad elements are created connecting across the outside boundary. This fix uses **`interpolate/map`** from the hex mesh to the tet mesh to tag and remove bad tets connecting outside the boundary. [](#step-1-create-surfaces) [Step 1. Create surfaces](#step-1-create-surfaces) [](#step-2-stack-hex-mesh) [Step 2. Stack surfaces into hex mesh](#step-2-stack-hex-mesh) [](#step-3-connect) [Step 3. Connect points into tetrahedral mesh](#step-3-connect) [](#step-4-interpolate) [Step 4. Interpolate hex colors to tet mesh](#step-4-interpolate) [](#step-5-remove-outside-tets) [Step 5. Remove Outside Tets from the mesh](#step-5-remove-outside-tets) ### LaGriT input command file with all steps: [wave_connect_interpolate.in.txt](/pages/docs/demos/output/wave_connect_interpolate.in.txt) ### LaGriT output report for all steps: [wave_connect_interpolate.out.txt](/pages/docs/demos/output/wave_connect_interpolate.out.txt) ## Step 1 Create Surfaces ### Commands to create quad surface * Define variables for spacing * spacing near .25 define / XMAX / 9.5 define / YMAX / 1. define / NX / 40 define / NY / 5 *------------------------------------------------- * Create the quad mesh with wave as top surface * Use x coordinates to compute z based on cos() * z(i)=cos(x(i)) cmo / create / mosurf / / / quad quadxy/NX NY/0. 0. 0./ XMAX 0. 0./ & XMAX YMAX 0./0. YMAX 0./ 1 1 1 createpts/brick/xyz/NX,NY,1/1 0 0 / connect cmo / setatt / mosurf / imt / 1 0 0 / 1 cmo / setatt / mosurf / itetclr / 1 0 0 / 1 resetpts / itp cmo / printatt / mosurf / -xyz- / minmax math/cos/mosurf/zic/1,0,0/mosurf/xic cmo / printatt / mosurf / -xyz- / minmax dump / surf_wave.inp / mosurf dump / surf_wave.gmv / mosurf QUADXY GENERATED POINTS 1 TO 200 createpts/brick/xyz/NX,NY,1/1 0 0/connect Number of nodes: 200 Number of elements: 156 Number of negative volume elements: 0 Total volume: 0.950000000000E+01 math/cos/mosurf/zic/1,0,0/mosurf/xic cmo/printatt/mosurf/-xyz-/minmax ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH xic 0.000000000E+00 9.500000000E+00 9.500000000E+00 200 yic 0.000000000E+00 1.000000000E+00 1.000000000E+00 200 zic -9.996856634E-01 1.000000000E+00 1.999685663E+00 200 ### Commands to make surfaces for stacking * make layers for for input into stack * translate surfaces for vertical spacing define ZBOT 0. define S1 2. define S2 .8 define S3 1.5 cmo select mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S1 dump / surf_wave_low.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S2 dump / surf_wave_high.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S3 dump / surf_wave_top.inp / mosurf cmo/setatt/mosurf/ zic/ ZBOT dump / surf_flat_bot.inp / mosurf ### Output quad surfaces Created quad surface with z(i)=cos(x(i)) This surface is used as template to create additional surfaces. ## Step 2 Stack Hex Mesh ### Commands to stack layers into a hex mesh *------------------------------------------------- * MAKE HEX for POINT DISTRIBUTION and INTERPOLATE * Stack from bottom to top and add refine layers cmo/create/mo_stack stack/layers/avs/ & surf_flat_bot.inp 1 & surf_wave_low.inp 2 3 & surf_wave_high.inp 3 2 & surf_wave_top.inp 3 3 * fill stacked quad surfaces with hex elements stack/fill/mohex / mo_stack cmo select mohex resetpts itp * write information about this mesh object cmo/printatt/mohex/-xyz- minmax quality * check hex volumes cmo/addatt/mohex/volume hex_vol cmo/printatt/mohex/hex_vol minmax eltset/ ebad / hex_vol/le 0. dump hex_stack.inp mohex dump hex_stack.gmv mohex ### Output stacked hex mesh The **`stack/layers`** command is used to stack layers and create refined layers. For this example there are top and bottom layers plus 2 internal layers to seperate materials. The vertical spacing between these input layers are refined proportionally by adding refine layers. - Bottom (yellow), internal interfaces (green), top (red) - Blue surfaces are the added proportional layers. surface name layer color type llcorner zic surf_flat_bot.inp 1 1 -1 1) 0.000000E+00 refine 2 1 2 201) 7.500000E-01 refine 3 1 2 401) 1.500000E+00 refine 4 1 2 601) 2.250000E+00 surf_wave_low.inp 5 2 0 801) 3.000000E+00 refine 6 2 2 1001) 3.266667E+00 refine 7 2 2 1201) 3.533333E+00 surf_wave_high.inp 8 3 0 1401) 3.800000E+00 refine 9 3 2 1601) 4.175000E+00 refine 10 3 2 1801) 4.550000E+00 refine 11 3 2 2001) 4.925000E+00 surf_wave_top.inp 12 3 -2 2201) 5.300000E+00 Elements per layer: 156 stacked total: 1872 Nodes per layer: 200 stacked total: 2400 No Truncating layer specified. files read: 4 from total: 4 The stacked layers are connected into hex elements. The **`quality`** and **`cmo/addatt/cmo/volume`** commands are used to check that volumes are positive. ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH hex_vol 1.535352422E-02 4.552152812E-02 3.016800390E-02 1716 eltset/ebad/hex_vol/le 0. THE ELTSET ebad HAS 0 ELEMENTS ## Step 3 Connect Copy the hex points into a new mesh object and connect into tetrahedrals. ### Commands to connect # CONNECT POINTS INTO TET MESH # copy points from hex mesh into new mesh object # connect points with no geometry and single material # no new points will be added cmo/create/motet copypts/motet/mohex # remove duplicate points # set some defaults for the connect routine filter/1,0,0 ; rmpoint/compress # Initialize to single material and no boundaries cmo / setatt / motet / imt / 1 0 0 / 1 cmo / setatt / motet / itp / 1 0 0 / 0 # connect input points and do not add points # material interface detection is turned off connect / noadd quality ### Output Connected Tet Mesh The boundary of this point distribution is non-convex and connections are made across the outside boundary. This is easy to see visually, the quality command also indicates elements with high aspect ratios. connect/noadd Coordinates of enclosing tetrahedron are: -0.19000D+02 -0.75000D+00 -0.39750D+01 0.47500D+01 -0.75000D+00 0.22525D+02 0.28500D+02 -0.75000D+00 -0.39750D+01 0.47500D+01 0.42500D+01 0.26500D+01 The mesh is now complete! quality epsilonl, epsilonaspect: 2.4256785E-12 1.4272489E-35 -------------------------------------------- elements with aspect ratio ## Step 4 Interpolate ### Commands to interpolate hex materials to tet materials The hex mesh with 3 materials can be interpolated on to the tet mesh to find elements outside the mesh. The outside elements are tagged within the command so they can be identified and removed. * INTERPOLATE HEX to TET * interpolate hex materials on to tet mesh elements * this will tag tets outside boundary with value 5 * valid imt and itetclr values are int values gt 0 interpolate/map/motet itetclr/1,0,0/mohex itetclr/ 5 dump/tet_connect_color.inp/motet dump/tet_connect_color.gmv/motet cmo/printatt/mohex/ itetclr minmax cmo/printatt/motet/ itetclr minmax ### Output Colored Tet Mesh The tet mesh now has the 3 materials interpolated from the hex mesh. The elements outside the source hex mesh have been tagged (red). interpolate/map/motet itetclr/1,0,0/mohex itetclr/5 elements in indexed set = 10656 INTRP METHOD: map FUNCTION: user TIEBREAKER: maxtie FLAG: user 0.500000000000E+01 Total Source Elements: 1716 Total Sink Centroids: 10656 WARNING: Sink points not inside source grid: 360 Outside sink points flagged with value: 5.00 interpolate/map done. ## Step 5 Remove Outside Tets The tagged elements are removed and the final mesh files written. The mesh statistics are reported and checked for possible issues before being used by a modeling application. ### Commands to remove tets * remove bad tets crossing non-convex boundary * set interface and boundary nodes with itp values cmo/select/motet rmmat/ 5 rmpoint/compress resetpts/itp * get mesh quality statistics cmo/addatt/motet/volume/tet_vol cmo/addatt/motet/voronoi_volume/vor_vol cmo/printatt/motet/tet_vol/minmax cmo/printatt/motet/vor_vol/minmax quality * write AVS and GMV mesh file formats dump/tet_connect.inp/motet dump/tet_connect.gmv/motet * write minmax of all mesh attributes cmo/printatt/motet/ -all- minmax * Exit finish ### Output Final Colored Tet Mesh rmmat/5 RMMAT DUDDED 0 POINTS: FLAGGED 360 ELEMENTS rmpoint/compress 0 points removed and 360 elements removed. RMPOINT: new point count is 2400 RMPOINT: new element count is 10296 ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH tet_vol 2.538190758E-03 8.066814185E-03 5.528623427E-03 10296 vor_vol 1.908426385E-03 4.559428664E-02 4.368586025E-02 2400 quality epsilonl, epsilonaspect: 2.4256785E-12 1.4272489E-35 -------------------------------------------- elements with aspect ratio END Example",
    "tags": "",
    "url": "/pages/docs/demos/description2_connect.html"
  },{
    "title": "Example: 3D connect with sloped interfaces",
    "text": "# Example: 3D connect with sloped interfaces **`connect`** with input points from a convex hex mesh created with **`stack/layers`**. This example has a thin layer formed from sloped internal interfaces. Bad elements are created across the internal interfaces resulting in \"popped\" tets. This example is fixed with resolution that improves the height to width ratio of the mesh spacing. [](#step-1-create-surfaces) [Step 1. Create surfaces](#step-1-create-surfaces) [](#step-2-stack-hex-mesh) [Step 2. Stack surfaces into hex mesh](#step-2-stack-hex-mesh) [](#step-3-connect) [Step 3. Connect points into tetrahedral mesh](#step-3-connect) [](#step-4-interpolate) [Step 4. Interpolate hex colors to tet mesh](#step-4-interpolate) ### LaGriT input command file with all steps: [wave_connect_highres.in.txt](/pages/docs/demos/output/wave_connect_highres.in.txt) ### LaGriT output report for all steps: [wave_connect_highres.out.txt](/pages/docs/demos/output/wave_connect_highres.out.txt) ## Step 1 Create Surfaces Use the **define** command to set parameters for mesh resolution and file names. Here the resolution is redefined by setting the define variables to new values. The first set are those associated with hex.gmv and tet.gmv. The second set doubles the resolution and assigns new file names hex2.gmv and tet2.gmv. This example takes advantage of the **define** command to run variations on the mesh using a single input file. Notice the first set of defined variables are for the coarse mesh, the second set overwrites the first set to create a mesh with added refinement and new file names.LaGriT is run first with the coarser mesh, then re-run with the modified values that fix the popped tets at the interface. ### Commands to create quad surfaces # Use x coordinates to compute z based on cos() # z(i)=cos(x(i)) # EDIT Variables to define resolution and file names # spacing near .25 horizontal define / XMAX / 9.5 define / YMAX / 1. define / NX / 40 define / NY / 5 define HEX_MESH hex.gmv define TET_MESH tet.gmv # MODIFY Variables to fix popped tets on interface # ADD resolution so height to width ratio is near 1 to 2 # spacing near .125 horizontal define / NX / 80 define / NY / 10 define HEX_MESH hex2.gmv define TET_MESH tet2.gmv # Create the quad surface with wave topology cmo / create / mosurf / / / quad quadxy /NX NY/0. 0. 0./ XMAX 0. 0./XMAX YMAX 0./0. YMAX 0./ 1 1 1 createpts/brick/xyz/NX,NY,1/1 0 0 / connect cmo / setatt / mosurf / imt / 1 0 0 / 1 cmo / setatt / mosurf / itetclr / 1 0 0 / 1 resetpts / itp cmo / printatt / mosurf / -xyz- / minmax math/cos/mosurf/zic/1,0,0/mosurf/xic cmo / printatt / mosurf / -xyz- / minmax dump / surf_wave.inp / mosurf #------------------------------------------------- # make surfaces for stack input files using the quad surface # Make top and bottom surfaces flat define ZBOT 0. define ZTOP 4. # translate surfaces for vertical thickness define S1 2. define S2 .6 define S3 1.5 cmo select mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S1 dump / surf_wave_low.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S2 dump / surf_wave_high.inp / mosurf cmo/setatt/mosurf/ zic/ ZBOT dump / surf_flat_bot.inp / mosurf cmo/setatt/mosurf/ zic/ ZTOP dump / surf_flat_top.inp / mosurf ### Commands to make surfaces for stacking Use the quad surface to assign Z values for layers to stack. The top and bottom of this mesh will be flat. There are 2 wave surfaces being used as internal interfaces for the middle material given a thickness of .6 using the translate command. # Make top and bottom surfaces flat define ZBOT 0. define ZTOP 4. # translate surfaces for vertical thickness define S1 2. define S2 .6 cmo select mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S1 dump / surf_wave_low.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S2 dump / surf_wave_high.inp / mosurf cmo/setatt/mosurf/ zic/ ZBOT dump / surf_flat_bot.inp / mosurf cmo/setatt/mosurf/ zic/ ZTOP dump / surf_flat_top.inp / mosurf ### Output quad surfaces Created quad surface with z(i)=cos(x(i)) This surface is used as template to create additional surfaces. ## Step 2 Stack Hex Mesh The **`stack/layers`** command reads the four surfaces that were created. Material ids are assigned and refinement layers created between input surfaces that will detirmine vertical resolution. ### Commands to stack layers into a hex mesh # Stack layers from bottom to top # Define material id and add refine layers cmo/create/mo_stack stack/layers/avs/ & surf_flat_bot.inp 1 & surf_wave_low.inp 2 3 & surf_wave_high.inp 3 3 & surf_flat_top.inp 3 3 dump gmv tmp_stack_layers.gmv mo_stack # connect statcked surfaces into 3D elements stack/fill/mohex / mo_stack resetpts/itp # write information about this mesh object cmo/printatt/mohex/-xyz- minmax quality # check hex volumes cmo/addatt/mohex/volume hex_vol cmo/printatt/mohex/hex_vol minmax eltset/ ebad / hex_vol/le 0. dump HEX_MESH mohex ### Output stacked hex mesh For this example there are flat top and bottom layers plus 2 internal layers to seperate materials. The vertical spacing between these input layers are refined proportionally by adding refine layers. - Bottom (yellow), internal interfaces (green), top (red) - Blue surfaces are the added proportional layers. surface name layer color type llcorner zic surf_flat_bot.inp 1 1 -1 1) 0.000000E+00 refine 2 1 2 801) 7.500000E-01 refine 3 1 2 1601) 1.500000E+00 refine 4 1 2 2401) 2.250000E+00 surf_wave_low.inp 5 2 0 3201) 3.000000E+00 refine 6 2 2 4001) 3.150000E+00 refine 7 2 2 4801) 3.300000E+00 refine 8 2 2 5601) 3.450000E+00 surf_wave_high.inp 9 3 0 6401) 3.600000E+00 refine 10 3 2 7201) 3.700000E+00 refine 11 3 2 8001) 3.800000E+00 refine 12 3 2 8801) 3.900000E+00 surf_flat_top.inp 13 3 -2 9601) 4.000000E+00 Elements per layer: 711 stacked total: 9243 Nodes per layer: 800 stacked total: 10400 No Truncating layer specified. files read: 4 from total: 4 The stacked layers are connected into hex elements. Note the vertical resolution for the coarse and the high resolution 2nd mesh are the same. Only the horizontal spacing has changed. The **`quality`** and **`cmo/addatt/cmo/volume`** commands are used to check that volumes are positive. Hex Mesh Coarse XY Hex Mesh Refine XY ## Step 3 Connect Copy the hex points into a new mesh object and connect into tetrahedrals. ### Commands to connect cmo/create/motet copypts/motet/mohex # set some defaults for the connect routine filter / 1 0 0 rmpoint / compress cmo / setatt / motet / imt / 1 0 0 / 1 cmo / setatt / motet / itp / 1 0 0 / 0 # connect and ignore interface materials connect/ noadd ### Output Connected Tet Mesh The internal interfaces are steep slopes, if the width to height ratio is too large, connect may form connections across the interface resulting in \"popped\" tets. This is easy to see visually by selecting materials, or by displaying the tet volumes as shown in these images. Coarse Added resolution These images show tet volumes colored by added attribute *tet_vol* with element volumes. It is easy to see where tets in the coarser mesh cross the material interface and are not conforming with the input surface as shown in the higher resolution mesh on the right. ## Step 4 Interpolate ### Commands to interpolate hex materials to tet materials The hex mesh with 3 materials can be interpolated on to the tet mesh. # interpolate element materials from hex mesh interpolate/map/motet itetclr/1,0,0/mohex itetclr resetpts / itp # report mesh quality and check for neg ccoefs quality cmo/addatt/motet/volume/tet_vol cmo/addatt/motet/voronoi_volume/vor_vol cmo/printatt/motet/tet_vol/minmax cmo/printatt/motet/vor_vol/minmax dump TET_MESH motet finish ### Output Colored Tet Mesh The tet mesh now has the 3 materials interpolated from the hex mesh. The refined mesh has internal interfaces conforming to the input surfaces. Tet Mesh Tet Mesh Explode These images show results from the coarse mesh with connections crossing the material interface. Tet 2 Mesh Tet 2 Mesh Explode These images show results from the higher resolution mesh with connections conforming to the material interface.",
    "tags": "",
    "url": "/pages/docs/demos/description3_connect.html"
  },{
    "title": "Example: 3D connect/check_interface with sloped interfaces",
    "text": "# Example: 3D connect/check_interface with sloped interfaces **`connect`** with input points from a convex hex mesh created with **`stack/layers`**. This example has a thin layer formed from sloped internal interfaces. Bad elements are created across the internal interfaces resulting in \"popped\" tets. This example is fixed by using **connect/check_interface**. This option requires mesh object geometry as defined by the **region** and **mregion** commands. If geometry is not defined, **check_interfaces** will behave as if there are no internal interfaces. [](#step-1-create-surfaces) [Step 1. Create surfaces](#step-1-create-surfaces) [](#step-2-stack-hex-mesh) [Step 2. Stack surfaces into hex mesh](#step-2-stack-hex-mesh) [](#step-3-set-geometry) [Step 3. Define geometry for the tetrahedral mesh](#step-3-set-geometry) [](#step-4-connect) [Step 4. Connect points into tetrahedral mesh](#step-3-connect) [](#step-5-interpolate) [Step 5. Interpolate hex colors to tet mesh](#step-4-interpolate) ### LaGriT input command file with all steps: [wave_connect_check.in.txt](/pages/docs/demos/output/wave_connect_check.in.txt) ### LaGriT output report for all steps: [wave_connect_check.out.txt](/pages/docs/demos/output/wave_connect_check.out.txt) ## Step 1 Create Surfaces Use **createpts** to create boundary and internal interfaces. These surfaces will also be used to define the mesh **geometry** in latter steps. ### Commands to create quad surfaces # spacing near .25 define / XMAX / 9.5 define / YMAX / 1. define / NX / 40 define / NY / 5 define HEX_MESH hex.gmv define TET_MESH tet.gmv cmo / create / mosurf / / / quad quadxy /NX NY/0. 0. 0./ XMAX 0. 0./XMAX YMAX 0./0. YMAX 0./ 1 1 1 createpts/brick/xyz/NX,NY,1/1 0 0 / connect cmo / setatt / mosurf / imt / 1 0 0 / 1 cmo / setatt / mosurf / itetclr / 1 0 0 / 1 resetpts / itp math/cos/mosurf/zic/1,0,0/mosurf/xic cmo / printatt / mosurf / -xyz- / minmax dump / surf_wave.inp / mosurf ### Commands to make surfaces for stacking Use the quad surface to assign Z values for layers to stack. The top and bottom of this mesh will be flat. There are 2 wave surfaces being used as internal interfaces for the middle material. These will be used to define the mesh geometry as required by the **check_interface** option of connect. # these are the values for flat top and flat bottom define ZBOT 0. define ZTOP 4. # these are translate values for vertical spacing define S1 2. define S2 .6 cmo select mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S1 dump / surf_wave_low.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S2 dump / surf_wave_high.inp / mosurf cmo/setatt/mosurf/ zic/ ZBOT dump / surf_flat_bot.inp / mosurf cmo/setatt/mosurf/ zic/ ZTOP dump / surf_flat_top.inp / mosurf ## Step 2 Stack Hex Mesh The **`stack/layers`** command reads the four surfaces that were written. Material ids are assigned and refinement layers are created between input surfaces that will detirmine the vertical resolution. Write this hex mesh and use it to interpolate material ids on to the tet mesh when done. ### Commands to stack layers into a hex mesh # Stack layers from bottom to top with vertical refinement cmo/create/mo_stack stack/layers/avs/ & surf_flat_bot.inp 1 & surf_wave_low.inp 2 3 & surf_wave_high.inp 3 3 & surf_flat_top.inp 3 3 # connect stacked layers into 3D elements stack/fill/mohex / mo_stack resetpts/itp # write information about this mesh object cmo/printatt/mohex/-xyz- minmax quality # check hex volumes cmo/addatt/mohex/volume hex_vol cmo/printatt/mohex/hex_vol minmax eltset/ ebad / hex_vol/le 0. dump HEX_MESH mohex ### Output stacked hex mesh For this example there are flat top and bottom layers plus 2 internal layers to seperate materials. The vertical spacing between these input layers are refined proportionally by adding refine layers. - Bottom (yellow), internal interfaces (green), top (red) - Blue surfaces are the added proportional layers. surface name layer color type llcorner zic surf_flat_bot.inp 1 1 -1 1) 0.000000E+00 refine 2 1 2 801) 7.500000E-01 refine 3 1 2 1601) 1.500000E+00 refine 4 1 2 2401) 2.250000E+00 surf_wave_low.inp 5 2 0 3201) 3.000000E+00 refine 6 2 2 4001) 3.150000E+00 refine 7 2 2 4801) 3.300000E+00 refine 8 2 2 5601) 3.450000E+00 surf_wave_high.inp 9 3 0 6401) 3.600000E+00 refine 10 3 2 7201) 3.700000E+00 refine 11 3 2 8001) 3.800000E+00 refine 12 3 2 8801) 3.900000E+00 surf_flat_top.inp 13 3 -2 9601) 4.000000E+00 Elements per layer: 711 stacked total: 9243 Nodes per layer: 800 stacked total: 10400 No Truncating layer specified. files read: 4 from total: 4 The stacked layers are connected into hex elements. The **`quality`** and **`cmo/addatt/cmo/volume`** commands are used to check that volumes are positive. Hex Mesh ## Step 3 Set Geometry Read the surfaces used to define material interfaces for the hex mesh, and use them to define the mesh geometry that will be used by **connect/check_interface**. The geometry is defined by regions above and below the surfaces. Here we set region 2 **r2** and mregion 2 **mr2** as the volume between surf_wave_low.inp and surf_wave_high.inp. The interfaces will be equal to these surfaces. # GEOMETRY defined for tet mesh cmo/create/motet copypts/motet/mohex # define geometry using surfaces used in stack read avs surf_wave_low.inp mos1 read avs surf_wave_high.inp mos2 cmo select motet surface/slow/intrface/sheet/ mos1 surface/shigh/intrface/sheet/ mos2 # define regions # interfaces must have exactly one region region/r1/ lt slow region/r2/ ge slow and le shigh region/r3/ gt shigh # define material regions # exclude internal interfaces mregion/mr1/ lt slow mregion/mr2/ gt slow and lt shigh mregion/mr3/ gt shigh ## Step 4 Connect Copy the hex points into a new mesh object and connect into tetrahedrals. The **check_interface** option will add points as necessary to maintain the defined interfaces. ### Commands to connect # set some defaults for the connect routine filter / 1 0 0 rmpoint / compress setpts dump gmv tmp_input_nodes.gmv motet cmo/printatt/motet/imt minmax # connect and check interface connections connect / check_interface The command **setpts** will assign imt material values as defined in the region and mregion commands. Use this to check that the mesh geometry has beed defined as intended. setpts FOR imt= 1 NAME= mr1 THERE ARE 800 POINTS FOR imt= 2 NAME= mr2 THERE ARE 600 POINTS FOR imt= 3 NAME= mr3 THERE ARE 800 POINTS FOR imt= 4 NAME= intrface THERE ARE 400 POINTS Image shows the input points as colored by imt values set in the **setpts** command. The result is 600 points in region mr2 with imt=2, there are 800 points in the top and bottom regions. The imt=4 values (red) are points on the interface between region 2 and the other regions. ### Output Connected Tet Mesh connect/check_interface Coordinates of enclosing tetrahedron are: -0.19000D+02 -0.75000D+00 -0.30000D+01 0.47500D+01 -0.75000D+00 0.17000D+02 0.28500D+02 -0.75000D+00 -0.30000D+01 0.47500D+01 0.42500D+01 0.20000D+01 Candidate connections that may cross boundaries = 72 Adding 72 points to break multimaterial connections Points 2601 - 2672 are being added to break multimaterial connections. Successfully eliminated all multimaterial connections. The mesh is now complete! LaGriT FINISH: connect The LaGriT output report and image show that points were added to maintain the material interfaces. The added nodes are shown in the images as black dots. Click on image to enlarge. The tet elements are colored based on the 4 regions, mr1 (blue), mr2 (green), mr3 (lime), interface (red). ## Step 5 Interpolate ### Commands to interpolate hex materials to tet materials The hex mesh with 3 materials can be interpolated on to the tet mesh. # interpolate element materials from hex mesh interpolate/map/motet itetclr/1,0,0/mohex itetclr resetpts / itp # report mesh quality and check for neg ccoefs quality cmo/addatt/motet/volume/tet_vol cmo/addatt/motet/voronoi_volume/vor_vol cmo/printatt/motet/tet_vol/minmax cmo/printatt/motet/vor_vol/minmax dump TET_MESH motet finish ### Output Colored Tet Mesh The mesh has 3 materials interpolated from the hex mesh and has internal interfaces conforming to the input surfaces. elements with aspect ratio b/w .2 and .5 : 235 elements with aspect ratio b/w .5 and 1. : 11381 min aspect ratio = 0.3142E+00 max aspect ratio = 0.8686E+00 element volumes b/w 0.1533E-03 and 0.3386E-03: 56 element volumes b/w 0.3386E-03 and 0.7481E-03: 380 element volumes b/w 0.7481E-03 and 0.1653E-02: 4520 element volumes b/w 0.1653E-02 and 0.3651E-02: 2244 element volumes b/w 0.3651E-02 and 0.8067E-02: 4416 min volume = 1.5327704E-04 max volume = 8.0668142E-03 ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH tet_vol 1.532770444E-04 8.066814185E-03 7.913537141E-03 11616 vor_vol 7.612179487E-04 4.559428664E-02 4.483306869E-02 2672 AMatbld3d_stor: Matrix compress_eps: 0.1000000E-07 AMatbld3d_stor: Local epsilon: 0.1000000E-14 AMatbld3d_stor: *****Zero Negative Coefficients ****** AMatbld3d_stor: npoints = 2672 ncoefs = 22504 AMatbld3d_stor: Number of unique coefs = 12588 AMatbld3d_stor: Maximum num. connections to a node = 17 AMatbld3d_stor: Volume min = 7.6121795E-04 AMatbld3d_stor: Volume max = 4.5594287E-02 AMatbld3d_stor: Total Volume: 3.8000000E+01 The LaGriT output reports mesh statistics. All element volumes are positive, aspect ratios are acceptable, node voronoi volumes are positive, and there are no negative coupling coefficients.",
    "tags": "",
    "url": "/pages/docs/demos/description4_connect.html"
  },{
    "title": "",
    "text": "Example 1: connect points in a 2d geometry The objective is to connect a set of existing nodes (2 dimensional) into a triangle mesh that satisfies the Delaunay criterion using the **connect** command. The output consists of two gmv files - one showing the point distribution and the other showing the resulting triangle mesh. Example: [lagrit_input_2dconnect](/pages/docs/demos/input/lagrit_input_2dconnect.txt) ``` # read the input points read / avs / input.inp / cmopts # create 2D mesh object and copy points cmo/create/cmotri/ / /triplane copypts/cmotri/ cmopts cmo/delete/cmopts # remove duplicate points if they exist cmo/select/cmotri filter/1,0,0 rmpoint/compress # connect the points and set itp array connect resetpts/itp # write AVS format file of the tri plane dump / avs / output_2d_conn.inp / cmotri # report mesh information cmo/status cmo/printatt//-all-/minmax quality ``` Input points: Triangulation after connect:",
    "tags": "",
    "url": "/pages/docs/demos/description_2dconn.html"
  },{
    "title": "",
    "text": "Example 1: reconnect points in a 2d geometry The objective is to reconnect a set of existing nodes (2 dimensional) using the command **recon**. The command rearranges connections in the mesh to ensure that the Delaunay criterion is satisfied, or to improve triangle shapes. The output consists of two gmv files. Output1a.gmv is the input mesh, and output1b.gmv is the reconnected mesh. Input: [LaGriT_input_2drecon](/pages/docs/demos/input/lagrit_input_2drecon.txt) Images of GMV output",
    "tags": "",
    "url": "/pages/docs/demos/description_2drecon.html"
  },{
    "title": "Example: Truncated Brick Mesh with Surface Regions",
    "text": "# Example: Truncated Brick Mesh with Surface Regions The objective is to create a structured mesh with materials and truncation defined by surfaces. The command **createpts/brick** is used to build a hex mesh. The hex mesh is colored by surface regions and then connected into a Delaunay tet mesh. Material cell colors are interpolated on to the tet mesh to maintain the cube shapes of the hex elements. When truncated the mesh is stair-stepped instead of dips and peaks if truncating by surface directly. The stair-step top needs careful methods to find the boundary tops and sides. The **zone_outside_minmax** is used in this example. The result will have stair-step geometries by will satisfy the Delaunay critera for modeling applications. This example command file creates the surfaces and mesh, there are no input files to read except the macro file included here. ### LaGriT command file: [lagrit_input_brick_trunc.lgi.txt](/pages/docs/demos/input/lagrit_input_brick_trunc.lgi.txt) ### LaGriT macro called by command file: [reset_truncated_nodes_imt.mlgi.txt](/pages/docs/demos/input/reset_truncated_nodes_imt.mlgi.txt) ### LaGriT output report: [lagrit_output_brick_trunc.txt](/pages/docs/demos/output/lagrit_output_brick_trunc.txt) Input Regular Hex Mesh and Surfaces Output Truncated tet Mesh Truncated tet mesh with outside top boundary nodes Truncated tet mesh with nodes defined by material regions ## Steps for this Example: ### Step 1. Create hex mesh using **createpts/brick** multiple calls for change in vertical resolution. ``` define/XMIN/ 0. define/YMIN/ 0. define/ZMIN/ 0. define/XMAX/ 20. define/YMAX/ 10. define NX 21 define NY 11 # Vertical spacing define/ZMAX/ 18. define/Z2 / 10. define/Z1 / 5. define/ZMIN/ 0. cmo/create/cmohex///hex cmo/select/cmohex # Vertical spacing from middle to top createpts/brick/xyz/NX NY 28 / XMIN YMIN Z2 / XMAX YMAX ZMAX # Vertical spacing from middle 1 to middle 2 createpts/brick/xyz/NX NY 11 / XMIN YMIN Z1 / XMAX YMAX Z2 # Vertical spacing bottom to middle createpts/brick/xyz/NX NY 6 / XMIN YMIN ZMIN / XMAX YMAX Z1 cmo/printatt/cmohex/ -xyz- minmax quality ``` ### Step 2. Create or Read Surfaces to define Material Regions ``` # Use x coordinates to compute z based on sin() # y coordinate detirmines length of surface define / XMAX / 20. define / NX / 40 define / YMAX / 10. define / NY / 10 define SCALE_VAL 2. cmo / create / mosurf / / / quad cmo select mosurf quadxy /NX NY/0. 0. 0./ XMAX 0. 0./XMAX YMAX 0./0. YMAX 0./ 1 1 1 createpts/brick/xyz/NX,NY,1/1 0 0 / connect math/sin/mosurf/zic/1,0,0/mosurf/xic scale / 1 0 0 / relative / xyz / SCALE_VAL SCALE_VAL SCALE_VAL cmo / setatt / mosurf / imt / 1 0 0 / 1 cmo / setatt / mosurf / itetclr / 1 0 0 / 1 resetpts / itp cmo / printatt / mosurf / -xyz- / minmax trans / 1 0 0 / 0. 0. 0. / -1. -1. 8.0 dump / surf_sin_01.inp / mosurf cmo/printatt/mosurf/ zic minmax cmo/copy/mosurf2/mosurf cmo/select/mosurf2 trans / 1 0 0 / 0. 0. 0. / -1. 0. 6.8 dump / surf_sin_02.inp / mosurf2 cmo/printatt/mosurf2/ zic minmax ``` ### Define Geometry using Regions defined by Surfaces ``` cmo select cmohex surface / s1 / intrface / sheet / mosurf surface / s2 / intrface / sheet / mosurf2 # set interfaces equal to one surface region / r1 / lt s1 and le s2 region / r2 / gt s1 and lt s2 region / r3 / ge s2 # interfaces are not equal to surface mregion / mr1 / lt s1 and lt s2 mregion / mr2 / gt s1 and lt s2 mregion / mr3 / gt s2 setpts settets resetpts/itp ``` ### Connect point distribution into Delaunay tet mesh ``` cmo/create/cmotet copypts/cmotet/cmohex # remove duplicate points, reset attributes filter/1,0,0 rmpoint/compress cmo / setatt / cmotet / imt / 1 0 0 / 1 cmo / setatt / cmotet / itp / 1 0 0 / 0 # connect without adding points connect noadd resetpts / itp quality ``` ### Interpolate Cell and Node Materials from Hex Mesh for brick shaped geometry ``` interpolate/map/cmotet itetclr /1,0,0/ cmohex itetclr interpolate/voronoi/cmotet imt /1,0,0/ cmohex imt cmo/printatt/cmotet/itetclr minmax # remove cells above material 2 # check for material 3 nodes left behind eltset/edel/ itetclr / gt 2 rmpoint element eltset,get,edel rmpoint/compress resetpts/itp cmo/printatt/cmotet/itetclr minmax cmo/printatt/cmotet/imt minmax # FIX imt of nodes left behind after removal of cells define CMO cmotet define MAX_MAT 2 infile reset_truncated_nodes_imt.mlgi ``` ### Set Boundary Node Zones ``` # tag outside nodes and save attributes # we need to use the max node located in each xyz direction # normal zone_outside will tag stair-steps incorrectly dump/ zone_outside_minmax/ tet_max /cmotet/ keepatt # check geometric coefficients cmo/setatt/cmotet/imt 1 dump/ stor/ tet_trunc / cmotet ``` ### LaGriT Output Report for Mesh Quality # check geometric coefficients dump/stor/tet_trunc/cmotet *** Construct and Compress Sparse Matrix:3D *** *** Compress Area Coefficient Values *** AMatbld3d_stor: Matrix compress_eps: 0.1000000E-07 AMatbld3d_stor: Local epsilon: 0.1000000E-14 AMatbld3d_stor: *****Zero Negative Coefficients ****** AMatbld3d_stor: Number of 'zero' (",
    "tags": "",
    "url": "/pages/docs/demos/description_brick_trunc.html"
  },{
    "title": "Example: connect 3D Cube",
    "text": "# Example: connect 3D Cube The objective is to connect a set of existing nodes (3 dimensional) into a tetrahedral mesh that satisfies the Delaunay criterion using the **connect** command. The output consists of two mesh files - one showing the point distribution and the other showing the resulting tetrahedral mesh. GMV and AVS format mesh files are written here. The AVS format is common and can be read by many applications. The GMV (General Mesh Viewer) files are best read by GMV but other applications such as VisIt and MATLAB can read them. Input Points Output Tet Mesh ## LaGriT command file input.lgi On the command line this would be: ``` lagrit cmo/create/cmo///tet createpts/xyz/nx ny nz/0. 0. 0./1. 1. 1./1 1 1 RZ GENERATED POINTS 1 TO 8000 cmo/setatt/cmo/imt/1 0 0/1 Warning: nelements = 0 8000 values reset for attribute imt1 connect/noadd Coordinates of enclosing tetrahedron are: -0.20000D+01 -0.75000D+00 -0.75000D+00 0.50000D+00 -0.75000D+00 0.42500D+01 0.30000D+01 -0.75000D+00 -0.75000D+00 0.50000D+00 0.42500D+01 0.50000D+00 ntets= 29572 node index= 5000 nlstfail= 0 %done= 61.58 The mesh is now complete! LaGriT FINISH: connect cmo/printatt//-all-/minmax ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH -def- 0.000000000E+00 0.000000000E+00 0.000000000E+00 8000 scalar 1 1 0 1 vector 3 3 0 1 nnodes 8000 8000 0 1 nedges 0 0 0 1 nfaces 0 0 0 1 nelements 40751 40751 0 1 mbndry 16000000 16000000 0 1 ndimensions_topo 3 3 0 1 ndimensions_geom 3 3 0 1 nodes_per_element 4 4 0 1 edges_per_element 6 6 0 1 faces_per_element 4 4 0 1 isetwd 0 0 0 8000 ialias 0 0 0 8000 imt1 1 1 0 8000 itp1 0 10 10 8000 icr1 0 0 0 8000 isn1 0 0 0 8000 xic 0.000000000E+00 1.000000000E+00 1.000000000E+00 8000 yic 0.000000000E+00 1.000000000E+00 1.000000000E+00 8000 zic 0.000000000E+00 1.000000000E+00 1.000000000E+00 8000 xtetwd 0 0 0 40751 itetclr 1 1 0 40751 itettyp 5 5 0 40751 itetoff 0 163000 163000 40751 jtetoff 0 163000 163000 40751 itet 1 8000 7999 40751x4 jtet 1 16000000 15999999 40751x4 epsilon 1.000000004E-15 1.000000004E-15 0.000000000E+00 1 epsilonl 3.845925373E-13 3.845925373E-13 0.000000000E+00 1 epsilona 6.661338148E-13 6.661338148E-13 0.000000000E+00 1 epsilonv 2.220446049E-13 2.220446049E-13 0.000000000E+00 1 ipointi 8000 8000 0 1 ipointj 8000 8000 0 1 idebug 0 0 0 1 itypconv_sm 1 1 0 1 maxiter_sm 25 25 0 1 tolconv_sm 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 nnfreq 1 1 0 1 ivoronoi 1 1 0 1 iopt2to2 2 2 0 1 xmin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 ymin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 zmin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 xmax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 ymax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 zmax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 kdtree_level 0 0 0 1 max_number_sets 64 64 0 1 number_of_psets 0 0 0 1 number_of_eltsets 0 0 0 1 number_of_fsets 0 0 0 1 quality epsilonl, epsilonaspect: 3.8459254E-13 5.6885628E-38 -------------------------------------------- elements with aspect ratio",
    "tags": "",
    "url": "/pages/docs/demos/description_connect.html"
  },{
    "title": "Example: Stacked Mesh using grid2grid",
    "text": "# Example: Stacked Mesh using grid2grid The objective is to stack quad surfaces into a hex mesh then convert each hex element into 5 tets using **`grid2grid/hextotet5`** Use of **hex2tet5** to convert a 3D mesh to a tetrahedral mesh will in general result in a non-Delaunay tetrahedral mesh. If the ultimate goal is a Delaunay mesh, use the connect command, see Examples at [connect 3D](/pages/docs/demos/main_connect.html) and [connect 2D](/pages/docs/demos/main_2d_connect.html). Input Stacked Hex Mesh Output Hex to 5 Tet Mesh ### LaGriT command file: [grid2grid_wave_tet5.in.txt](/pages/docs/demos/output/grid2grid_wave_tet5.in.txt) ### LaGriT output report: [grid2grid_wave_tet5.out.txt](/pages/docs/demos/output/grid2grid_wave_tet5.out.txt) ## Steps for this Example: ### Step 1. Create hex mesh using **createpts** and **stack/layers** ``` #--* LAGriT Example Input file #--* Create a non-convex hex and use grid2grid #---------------------------------------------- # Use x coordinates to compute z based on cos() # spacing near .25 define / XMAX / 9.5 define / YMAX / 1. define / NX / 40 define / NY / 5 #------------------------------------------------- # Create the quad mesh with wave topology # this is the template used for all surfaces cmo / create / mosurf / / / quad quadxy /NX NY/0. 0. 0./ XMAX 0. 0./XMAX YMAX 0./0. YMAX 0./ 1 1 1 createpts/brick/xyz/NX,NY,1/1 0 0 / connect cmo / setatt / mosurf / imt / 1 0 0 / 1 cmo / setatt / mosurf / itetclr / 1 0 0 / 1 resetpts / itp math/cos/mosurf/zic/1,0,0/mosurf/xic dump / surf_wave.inp / mosurf dump / surf_wave.gmv / mosurf cmo / printatt / mosurf / -xyz- / minmax #------------------------------------------------- # make layers for for input into stack # top is wave, bottom is flat define ZBOT 0. # translate surfaces for vertical spacing define S1 2. define S2 .8 define S3 1.5 cmo select mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S1 dump / surf_wave_low.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S2 dump / surf_wave_high.inp / mosurf trans /1,0,0/ 0. 0. 0./ 0. 0. S3 dump / surf_wave_top.inp / mosurf cmo/setatt/mosurf/ zic/ ZBOT dump / surf_flat_bot.inp / mosurf #------------------------------------------------- # Stack layers from bottom to top wave cmo/create/mo_stack stack/layers/avs/ & surf_flat_bot.inp 1 & surf_wave_low.inp 2 3 & surf_wave_high.inp 3 2 & surf_wave_top.inp 3 3 dump gmv tmp_stack_layers.gmv mo_stack cmo/printatt/mo_stack/ -xyz- minmax # connect statcked surfaces into 3D elements stack/fill/mohex / mo_stack cmo select mohex resetpts itp # write information about this mesh object cmo/printatt/mohex/-xyz- minmax quality # check hex volumes cmo/addatt/mohex/volume hex_vol cmo/printatt/mohex/hex_vol minmax eltset/ ebad / hex_vol/le 0. dump hex_stack.inp mohex dump hex_stack.gmv mohex ``` ### Step 2. Convert hex elements to tets using **grid2grid/hextotet5** ``` #------------------------------------------------- # convert each hex to 5 tetrahedrals cmo/select/mohex grid2grid/ hextotet5/ motet5 / mohex resetpts/itp cmo/select/motet5 # report mesh statistics quality cmo/addatt/motet5/volume/tet_vol cmo/addatt/motet5/voronoi_volume/vor_vol cmo/printatt/motet5/ -all- minmax finish ``` ### Check quality and volume reports for mesh statistics The mesh statistics show positive volumes for all elements and acceptable aspect ratios. The voronoi volumes for each mesh node are positive but there are many negative coupling coeficients. The impact of these coupling coeficients will depend on the simulation being used. # report mesh statistics quality epsilonl, epsilonaspect: 2.4256785E-12 1.4272489E-35 -------------------------------------------- elements with aspect ratio",
    "tags": "",
    "url": "/pages/docs/demos/description_hextet.html"
  },{
    "title": "",
    "text": "Example 1: test using rmmat to modify a mesh. The objective is to use the **rmmat** command to modify a mesh by removing one of the material regions. The output consists of five gmv files, one showing the single material region, one showing a mesh with two materials included, and one each for the results of **rmmat/node**, **rmmat/element**, **rmmat/all**. Input [lagrit_input_rmmat](/pages/docs/demos/input/lagrit_input_rmmat.txt) Images of GMV input and output Mesh with single material rmmat / element Mesh with two materials rmmat / node rmmat / all",
    "tags": "",
    "url": "/pages/docs/demos/description_rmmat.html"
  },{
    "title": "",
    "text": "Example 1: test using sort. The objective is to use the **sort** command to obtain some statistics of a point distribution. The output consists of one standard out file that contains the results of the **sort/bins**, **sort/index**, and **sort/rank** commands. [lagrit_input_sort](/pages/docs/demos/input/lagrit_input_sort.txt) Output Results: Initial point distribution The key **input** commands are shown in **red**, and the key **output** is shown in **purple**.",
    "tags": "",
    "url": "/pages/docs/demos/description_sort.html"
  },{
    "title": "",
    "text": "Example 1: test using triangulate to create a 2d mesh. The objective is to use the **triangulate** command to create a mesh on a polygonal point distribution. The output consists of four gmv files, two showing the original point distributions, two showing the respective triangulations. LaGriT Input Command file: [lagrit_input_tri](/pages/docs/demos/input/lagrit_input_tri.txt) LaGriT Output Log: [lagrit_output_tri](/pages/docs/demos/output/lagrit_output_tri.txt) Input Concave point distribution in clockwise order from node 1 to node 7 Output Triangulation of concave point distribution with 5 triangles Input Convex point distribution in clockwise order from node 1 to node 6 Output Triangulation of convex point distribution with 4 triangles",
    "tags": "",
    "url": "/pages/docs/demos/description_tri.html"
  },{
    "title": "Examples: connect 2D",
    "text": "## Examples: connect 2D The objective is to connect a set of random points into a triangle mesh. | Input Random Points | Output Triangle Mesh (boundary nodes red) | | :---: | :---: | | | | 1. Create a mesh object named mo_tri and create a set of random points within a box. 2. Connect and Set node itp to mark boundary nodes. 3. Check mesh quality and write mesh file. ### Input Commands ``` # create a 2D mesh object # triplane has ndimensions_topo=2 and ndimensions_geom=2 cmo / create / mo_tri / / / triplane # Make some points at the four corners createpts / xyz / 5 5 1 / 0. 0. 0. / 1. 1. 0. / 1 1 1 # Add some random points and delete duplicate points createpts / random / xyz / 0.4 / 0.1 0.1 0. / 0.9 0.9 0. filter / 1 0 0 rmpoint / compress # set some defaults for the connect routine # imt material set to 1 and itp boundaries set to 0 cmo / setatt / mo_tri / imt / 1 0 0 / 1 cmo / setatt / mo_tri / itp / 1 0 0 / 0 connect # set default materials and boundary tags cmo / setatt / mo_tri / itetclr / 1 0 0 / 1 resetpts / itp # check areas and write an AVS format file of the mesh quality dump / avs / tri.inp / mo_tri ``` ### Output from quality command This quality report confirms all areas are positive and the triangles do not have small aspect ratios. epsilonl, epsilonaspect: 3.1401849E-13 3.0964614E-38 -------------------------------------------- elements with aspect ratio ## [Old Example Antler Ridge](/pages/docs/demos/description_2dconn.html) *Note this old example is non-convex and has long tets outside the boundary that need to be removed.*",
    "tags": "",
    "url": "/pages/docs/demos/main_2d_connect.html"
  },{
    "title": "",
    "text": "Description: test recon (reconnect) The objective is to use the **recon** command to reconnect an existing triangular mesh into a new triangular mesh that satisfies the Delaunay criterion and has improved element shapes. [Example](/pages/docs/demos/description_2drecon.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_2d_recon.html"
  },{
    "title": "",
    "text": "Description: test addmesh The objective is to join two meshes using the **addmesh** command, excercising its various options. (add, amr, append, delete, intersect, match, and merge)The test consists of seven examples each exercising the **addmesh** using one of the mesh operations **add**, **amr**, **append**, **delete**, **intersect**, **match**, and **merge**. Each example has one gmv output file. Inidvidual Descriptions: [Example 1] (description1_add.md) **add** [Example 2] (description2_amr.md) **amr** [Example 9](/pages/docs/demos/hlres.lgc) -- Image [Example 10](/pages/docs/demos/slad.lgc) --Image",
    "tags": "",
    "url": "/pages/docs/demos/main_addmesh.html"
  },{
    "title": "Examples: connect 3D non-convex",
    "text": "# Examples: connect 3D non-convex ## [Example connect with sloped top boundary](/pages/docs/demos/description2_connect.html) **`connect / noadd`** with input points from a hex mesh created with **`stack/layers`**. This example has a non-convex boundary and bad elements are created connecting across the boundary. This fix uses **`interpolate/map`** from the hex mesh to the tet mesh to tag and remove bad tets connecting across the boundary. ## [Example connect for conforming sloped interfaces](/pages/docs/demos/description3_connect.html) **`connect`** with input points from a convex hex mesh created with **`stack/layers`**. This example has a thin layer formed from sloped internal interfaces. Bad elements are created across the internal interfaces resulting in \"popped\" tets. This example is fixed with resolution that improves the height to width ratio of the mesh spacing. ## [Example connect with check_interface for conforming interfaces ](/pages/docs/demos/description4_connect.html) **`connect / check_interface`** with input points from a convex hex mesh created with **`stack/layers`**. This example has a thin layer formed from sloped internal interfaces. Bad elements are created connecting across the internal interfaces resulting in \"popped\" tets. This example is fixed using defined geometry **`region`** and the option **`check_interface`** to add points at the interface. Note that the interface is preserved but the added nodes may result in thin tets. ## See Related Pages [**`connect`** command](https://lanl.github.io/LaGriT/pages/docs/commands/CONNECT1.html) description. [**`connect`** 3D box Example](/pages/docs/demos/description_connect.html) [**`grid2grid`** command](https://lanl.github.io/LaGriT/pages/docs/commands/GRID2GRID.html) convert each mesh element to tri or tet elements (such as hex to 5 tets). [**`grid2grid`** Example](/pages/docs/demos/description_hextet.html) convert hex mesh to 5 tets each hex.",
    "tags": "",
    "url": "/pages/docs/demos/main_connect.html"
  },{
    "title": "",
    "text": "The objective is to add points to a mesh using the **createpts** command. The test consists of eight examples each exercising the command in a specific geometry (rectangular, cylindrical, spherical) with some variations on input parameters. A geometry is defined in one of the coordinate systems. The **createpts** command is used to create a point distribution within the geometry. The output consists of one gmv file for each example. Inidvidual Descriptions [Example 3](/pages/docs/demos/description3_rtp.html) **createpts/rtp** spherical [Example 4](/pages/docs/demos/description4_brick.html) **createpts/brick/xyz** material interface [Example 2](/pages/docs/demos/description2_rtz.html) **createpts/rtz** (cylindrical) [Example 1](/pages/docs/demos/description1_xyz.html) **createpts/xyz** (rectangular) [Example 5](/pages/docs/demos/description5_sphere.html)  **createpts/sphere/diamond** partial sphere using region boundaries [Example 6](/pages/docs/demos/description6_sphereB.html) **createpts/sphere** full sphere using region boundaries [Example 7](/pages/docs/demos/description7_brickB.html) **createpts/brick/xyz** brick mesh [Example 8](/pages/docs/demos/description8_sphereC.html) **createpts/sphere**",
    "tags": "",
    "url": "/pages/docs/demos/main_createpts.html"
  },{
    "title": "",
    "text": "Description: test createpts The objective is to add points to a mesh using the **createpts** command. The test consists of eight examples each exercising the command in a specific geometry (rectangular, cylindrical, spherical) with some variations on input parameters. A geometry is defined in one of the coordinate systems. The **createpts** command is used to create a point distribution within the geometry. The output consists of one gmv file for each example. Individual Descriptions [Example 3](/pages/docs/demos/description3_rtp.html) **createpts/rtp** spherical [Example 4](/pages/docs/demos/description4_brick.html) **createpts/brick/xyz** material interface [Example 2](/pages/docs/demos/description2_rtz.html) **createpts/rtz** (cylindrical) [Example 1](/pages/docs/demos/description1_xyz.html) **createpts/xyz** (rectangular) [Example 5](/pages/docs/demos/description5_sphere.html) **createpts/sphere/diamond** partial sphere using region boundaries [Example 6](/pages/docs/demos/description6_sphereB.html) **createpts/sphere** full sphere using region boundaries [Example 7](/pages/docs/demos/description7_brickB.html) **createpts/brick/xyz** brick mesh [Example 8](/pages/docs/demos/description8_sphereC.html) **createpts/sphere** gridding a sphere, including materials [Example 9](/pages/docs/demos/description9_random.html) **createpts/random/xyz** random points [Next Demo](/pages/docs/demos/main_hextet1.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_createpts1.html"
  },{
    "title": "",
    "text": "Description: test dump The objective is to test the **dump** command for various file format options. [Example 1](/pages/docs/demos/description_dump.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_dump.html"
  },{
    "title": "",
    "text": "Description: test hextotet The objective is to test the **hextotet** command. [Example 1](/pages/docs/demos/description_hextet.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_hextet.html"
  },{
    "title": "",
    "text": "Description: test hextotet The objective is to test the **hextotet** command. [Example 1](/pages/docs/demos/description_hextet.html) <img height=\"300\" width=\"300\" src=\"https://lanl.github.io/LaGriT/assets/images/output_tet_tn.gif\" [Next Demo](/pages/docs/demos/main_pset1.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_hextet1.html"
  },{
    "title": "",
    "text": "Description: test pset The objective is to test the **pset** command. [Example 1](/pages/docs/demos/description_pset.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_pset.html"
  },{
    "title": "",
    "text": "Description: test pset The objective is to test the **pset** command. [Next Demo](/pages/docs/demos/main_rmmat.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_pset1.html"
  },{
    "title": "",
    "text": "Description: test quality The objective is to test the **quality** command. [Example 1](/pages/docs/demos/description_qual.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_qual.html"
  },{
    "title": "Example negative_aij / rivara",
    "text": "# Example negative_aij / rivara Example 1: test mesh edges and boundary faces for negative coupling coefficients. The objective is to use the negative_aij / rivara command that first identifies elements that have negative coupling coefficents, and then proceeds with a rivara boundary refinement to reduce or eliminate the negative couplings. Input Mesh Output Mesh Output Mesh Refine Detail ## LaGriT Command File ``` cmo/create/cmo surface/outside/reflect/box/0,0,0/3,2,1 region/all/le outside mregion/all/le outside createpts/xyz/3,3,3/0,0,0/3,2,1/1,1,1 createpts/xyz/2,2,2/.2,.05,.1/3,2,1/0,0,0 createpts/xyz/3,3,3/0,0,0/1.5,1.0 .5/1,1,1 createpts/xyz/2,2,2/.1,0,0/1.5,1.0 .5/0,0,0 # remove duplicate points filter/1,0,0 cmo/setatt/cmo/imt/1,0,0/1 # set node material imt setpts # connect points into Delaunay mesh connect dump/gmv/output1.gmv negative_aij/rivara/ negative_aij/eltset dump/gmv/output2.gmv # report results cmo/status cmo/printatt//-all-/minmax quality finish ``` ## LaGriT Output The output log is very long with information for each command and refinement operation. The following shows the end outpu of the commands. cmo/printatt//-all-/minmax ATTRIBUTE NAME MIN MAX DIFFERENCE LENGTH -def- 0.000000000E+00 0.000000000E+00 0.000000000E+00 840 scalar 1 1 0 1 vector 3 3 0 1 nnodes 840 840 0 1 nedges 0 0 0 1 nfaces 0 0 0 1 nelements 2432 2432 0 1 mbndry 16000000 16000000 0 1 ndimensions_topo 3 3 0 1 ndimensions_geom 3 3 0 1 nodes_per_element 4 4 0 1 edges_per_element 6 6 0 1 faces_per_element 4 4 0 1 isetwd 0 0 0 840 ialias 0 840 840 840 imt1 0 1 1 840 itp1 0 10 10 840 icr1 0 1 1 840 isn1 0 0 0 840 xic 0.000000000E+00 3.000000000E+00 3.000000000E+00 840 yic 0.000000000E+00 2.000000000E+00 2.000000000E+00 840 zic 0.000000000E+00 1.000000000E+00 1.000000000E+00 840 xtetwd 0 26688 26688 2432 itetclr 1 1 0 2432 itettyp 5 5 0 2432 itetoff 0 9724 9724 2432 jtetoff 0 9724 9724 2432 itet 3 840 837 2432x4 jtet 1 16000000 15999999 2432x4 epsilon 1.000000004E-15 1.000000004E-15 0.000000000E+00 1 epsilonl 8.308148362E-13 8.308148362E-13 0.000000000E+00 1 epsilona 3.108624469E-12 3.108624469E-12 0.000000000E+00 1 epsilonv 1.332267630E-12 1.332267630E-12 0.000000000E+00 1 ipointi 807 807 0 1 ipointj 840 840 0 1 idebug 0 0 0 1 itypconv_sm 1 1 0 1 maxiter_sm 25 25 0 1 tolconv_sm 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 nnfreq 1 1 0 1 ivoronoi 1 1 0 1 iopt2to2 2 2 0 1 xmin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 ymin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 zmin 0.000000000E+00 0.000000000E+00 0.000000000E+00 1 xmax 3.000000000E+00 3.000000000E+00 0.000000000E+00 1 ymax 2.000000000E+00 2.000000000E+00 0.000000000E+00 1 zmax 1.000000000E+00 1.000000000E+00 0.000000000E+00 1 kdtree_level 0 0 0 1 max_number_sets 64 64 0 1 number_of_psets 0 0 0 1 number_of_eltsets 0 0 0 1 number_of_fsets 0 0 0 1 ncon50 2500 2500 0 1 nconbnd 1 1 0 1 icontab 0 2 2 2500 num_neg_coup_coef 140 140 0 1 neg_coup_coeff -1.204850781E-01 -2.441406250E-04 1.202409374E-01 140 ietet_aij 1 2401 2400 140x3 Enter a command quality epsilonl, epsilonaspect: 8.3081484E-13 5.7347268E-37 -------------------------------------------- elements with aspect ratio",
    "tags": "",
    "url": "/pages/docs/demos/main_rivara.html"
  },{
    "title": "",
    "text": "Description: test rotatept The objective is to test the **rotatept** command. [Example 1](/pages/docs/demos/description_rotatept.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_rotatept.html"
  },{
    "title": "",
    "text": "Description: test sort The objective is to test the **sort** command. [Example 1](/pages/docs/demos/description_sort.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_sort.html"
  },{
    "title": "",
    "text": "Description: test trans The objective is to test the **trans** command. [Example 1](/pages/docs/demos/description_trans.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_trans.html"
  },{
    "title": "",
    "text": "Description: test triangulate The objective is to test the **triangulate** command. [Example 1](/pages/docs/demos/description_tri.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_tri.html"
  },{
    "title": "",
    "text": "Description: test triangulate The objective is to test the **triangulate** command. [Example 1](/pages/docs/demos/description_tri.html)",
    "tags": "",
    "url": "/pages/docs/demos/main_tri1.html"
  },{
    "title": "",
    "text": "Example 5: addmesh / intersect The objective is to create a point set that are the nodes in mesh1 that intersect elements of mesh2. Two cubes defined by mesh1 and mesh2 are read. The perimeter of mesh2 lies within that of mesh1. The **addmesh / intersect** command is used to determine the nodes in mesh1 that intersect elements of mesh2. Input [lagrit_input_inter](/pages/docs/demos/input/lagrit_input_inter.txt) Images of GMV output Input file: * TEST addmesh/intersect (lagrit\\_input\\_inter) read / gmv / input\\_mesh1.gmv / cmo1 read / gmv / input\\_mesh2.gmv / cmo2 * get nodes of cmo1 that intersect elements of mesh cmo2 * and put them into a pset called pset\\_overlap addmesh / intersect / pset\\_overlap / cmo1 / cmo2 cmo/setatt/cmo1/imt/1 0 0/1 cmo/setatt/cmo1/imt/pset get pset\\_overlap/2 dump/gmv/output\\_inter.gmv/cmo1 * begin compare here cmo/status cmo/printatt//-all-/minmax quality finish",
    "tags": "",
    "url": "/pages/docs/demos/test.html"
  },{
    "title": "",
    "text": "**4. Divide the enclosing volumes into regions** The [**region**](/pages/docs/commands/REGION.html) command is used to divide the enclosing volume into regions. The directional operators **lt**, **le**, **gt**, ** ** and **ge** are applied to previously defined surfaces according to the following rules. **lt --** if the surface following is a volume then **lt** means inside not including the surface of the volume. If the surface is a plane or a sheet **lt** means the space on the side of the plane or sheet opposite to the normal not including the plane or sheet itself. **le --** if the surface following is a volume then **le** means inside including the surface of the volume. If the surface is a plane or a sheet **le** means the space on the side of the plane or sheet opposite to the normal including the plane or sheet itself. **gt --** if the surface following is a volume then **gt** means outside not including the surface of the volume. If the surface is a plane or a sheet **gt** means the space on the same side of the plane or sheet as the normal not including the plane or sheet itself. **ge --** if the surface following is a volume then **ge** means outside including the surface of the volume. If the surface is a plane or a sheet **ge** means the space on the same side of the plane or sheet as the normal including the plane or sheet itself. In region comands, surface names must be preceeded by a directional operator. The logical operators **or**, **and**, and **not** mean union, intersection and complement respectively. Parentheses are operators and are used for nesting. Spaces are required as delimiters to separate operators and operands. To define the two regions created by the plane bisecting the unit cube: **region**/top/ **le** cube **and** **gt** cutplane **region**/bottom **/ le** cube **and le** cutplane The region *bottom* contains the interface *cutplane*; top contains none of the interface. Interior interfaces must be included in one and only one region. If a region touches an external boundary, include the surface that defines the enclosing volume in region and mregion commands. For example, the regions *top* and *bottom* are enclosed by the surface *cube*",
    "tags": "",
    "url": "/pages/docs/dividereg.html"
  },{
    "title": "Errors in Parsing or Executing Commands:",
    "text": "### Errors in Parsing or Executing Commands: These errors cause an error message to be written to the output batch file, called logx3dgen by default and to the standard output file.  The messages are self-explanatory and will alert the user to the required change. For example one of the errors related to the region command is \"*token* is an invalid operation or a non-defined surface or region.\" In this case the user must inspect the corresponding command in the vicinity of *token* which is the place in parsing the string that LaGriT could not proceed, to see if there might be a spelling error in specifying a operator, region name or surface name or perhaps the user left out an operator. If the correct commands should read: surface/s1/reflect/box/0,0,0/1,1,1 surface/s2/intrface/box/.2,.2,.2/.4,.4,.4/ region/r1/le s1 and ge s2 region/r2/ le s2 If the user had mistakenly typed: region/r1/le s1 and gg s2 the error REGION ERROR: gg is an invalid operation or a non-defined surface or region\" would appear followed by error in command: region/r1/le s1 and gg s2 **Out of Memory Errors:** If a user specifies a probelem that is too large, LaGriT will fail with and \"MALLOCF: Out of memory\" or \"REALLOCF: Reallocation error - aborting\" mesage. The user must decrease the size of the problem or move to a more powerful platform. **Fatal Memory Management Errors:** Fatal memory management errors are signaled by a message containing \":PANIC!.\" This type of error should be reported to the code manager, and the report should include all files and other information necessary to reproduce the error.",
    "tags": "",
    "url": "/pages/docs/errors.html"
  },{
    "title": "FORTRAN Interface",
    "text": "# FORTRAN Interface Mesh Objects and their attribute data are accessed through a set of subroutines. An example of accessing an existing Mesh Object and creating a new mesh object is given in [Fortran Mesh Object Access](/pages/docs/accessing.html); that example should be used as a template when operating with Mesh Objects. The subroutine set includes: [cmo_get_name](/pages/docs/meshob.html#cmo_get_name): retrieve active mesh object name [cmo_set_name](/pages/docs/meshob.html#cmo_set_name): set active mesh object name [cmo_get_info](/pages/docs/meshob.html#cmo_get_info):retrieve mesh object pointer [cmo_get_intinfo](/pages/docs/meshob.html#cmo_get_intinfo): retrieve mesh object integer data [cmo_get_attinfo](/pages/docs/meshob.html#cmo_get_attinfo): retrieve mesh real or character data [cmo_set_info](/pages/docs/meshob.html#cmo_set_info): set mesh object integer data [cmo_set_attinfo](/pages/docs/meshob.html#cmo_set_attinfo): set mesh real or character data [cmo_newlen](/pages/docs/meshob.html#cmo_newlen): adjust the lengths of mesh object data based on the values of number of nodes and number of elements which are stored as integer mesh object attributes (nnodes, nelements) Only data from the active Mesh Object may be retrieved; calling **cmo_set_name** will make the referenced Mesh Object active. Scalar quantities are retrieved and stored using **cmo_get_intinfo**, **cmo_get_attinfo**,  and **cmo_set_info**. Vector quantities are referred to by their pointers. The length of the vectors is calculated internal to LaGriT based on the values of the scalar mesh object attributes. Memory allocation for a new mesh object or for a mesh object which will grow in size is accommodated by first setting the appropriate scalars for the Mesh Object by using  **cmo_set_intinfo** with the new number of elements and/or nodes and then calling **cmo_newlen**. These two steps must be taken before adding to the size of a Mesh Object. Mesh object parameters are retrieved with the [cmo_get_attparam](/pages/docs/meshob.html#cmo_get_attparam) subroutine. See [Mesh Object Subroutines](/pages/docs/meshob.html) for a list of  mesh object subroutines .",
    "tags": "",
    "url": "/pages/docs/fortran.html"
  },{
    "title": "Geometries and Regions",
    "text": "# Geometries and Regions Geometric regions for LaGriT are defined as combinations of bounding surfaces, where the surfaces are described analytically or as tessellated surfaces (triangles and/or quadrilaterals). A variety of techniques for distributing points within these geometric regions are provided. Mesh connectivity uses a Delaunay tetrahedralization algorithm that respects material interfaces. The data structures created to implement this algorithm are compact and powerful and expandable to include hybrid meshes (tet, hex, prism, pyramid, quadrilateral, triangle, line) however the main algorithms are for triangle and tetrahedral Delaunay meshes. A geometry for a mesh object can be defined and saved for use by one or more mesh objects. It consists of a set of surfaces and regions that are defined in terms of existing surfaces.  A name is associated with the geometry data and the default name is  -defaultgeom-.  A geometry may be named using the **[geometry/create](/pages/docs/geom_create.html)** command which must precede the **surface**, **region**, and **mregion** commands that define this geometry.  A geometry may be associated with more than one mesh object.  **[cmo/geometry](/pages/docs/commands/cmo/cmo_geom.html)** and **[cmo/constraint](/pages/docs/commands/cmo/cmo_constraint.html)** command are used to associate geometries with mesh objects. The data for a geometry are contained in a set of memory managed arrays whose partition name is the geometry name and in common blocks geom and cgeom defined in the geom_lg.h file.  This file also contains the pointer statements that can be used to access the data arrays directly. At present access routines to the geometry information have not been written except for getregv which accepts as input the coordinates of a set of query points and which returns a list of region numbers into which each query point falls.",
    "tags": "",
    "url": "/pages/docs/geometries.html"
  },{
    "title": "LaGriT Mesh Object Connectivity",
    "text": "# LaGriT Mesh Object Connectivity The Mesh Object attributes **itettyp, itetoff, jtetoff, itet,** and **jtet** along with the variables contained in the include files *local_element.h* and *blockcom.h* completely describe the mesh connectivity. The following discussion is based on the concept of local facets and local edges for an element. The nodes comprising a given element are always specified in a well-defined order; hence when one references the 'second facet' of an element, one references a pre-defined set of points. For element ordering of nodes, faces, and edges see [LaGriT Supported Element Types](/pages/docs/supported.html)) The following describes a LaGriT tetrahedral element, with nodes I1-I4 labeled as in the diagram: The 3D face ordering is such that the right-hand-normals of all facets point outward. For this tetrahedral, the points are oriented so that the triple product  I1I2 x I2I3 x I2I4  is positive, and the volume of the tetrahedral is one-sixth of the triple product and the right-hand-normals of the facets point outward. The local facets for this tetrahedral are defined as follows: Facet | Point A | Point B | Point C ----- | -------- | -------- |-------- F1 | I2 | I3 | I4 F2  | I1 | I4 | I3 F3  |  I1 | I2 | I4 F4  | I1 | I3 | I2 The local edges for this tetrahedral are defined as follows: Edge | Point A | Point B ----- | ------ | ------- E1 | I1 | I2 E2  | I1 | I3 E3  | I1 | I4 E4  | I2 | I3 E5 | I2 | I4 E6 | I3 | I4 Similarly, local facets and local edges are defined for all element types.  (see [LaGriT Supported Element Types](/pages/docs/supported.html)) **itettyp(it)** gives the element type of element **it.** **itetoff(it)** gives the offset to the first node in element **it.** **itet(itetoff(it)+j)** gives the jth node of element **it.** **nelmnen(itettyp(it))** gives the number of nodes of element **it.** To loop through all the nodes of all elements in the mesh: do it=1,ntets do j=1,nelmnen(itettyp(it)) k=itet(itetoff(it)+j) enddo enddo **nelmnef(itettyp(it))** gives the number of facets of element **it**. **ielmface0(iface,itettyp(it))** gives the number of nodes on facet **iface** of element **it**. **ielmface1(local\\_node,iface,itettyp(it))** gives the increment to the node number **(local\\_node)** on facet **iface** of element **it.** To loop through all the nodes, **k,** of all elements in the mesh by facets: do it=1,ntets do i=1,nelmnef(itettyp(it)) do j=1,ielmface0(i,itettyp(it)) k=itet(itetoff(it)+ ielmface1(j,i,itettyp(it))) enddo enddo enddo **nelmnee(itettyp(it))** gives the number of edges of element **it. ielmface2(inode,iface,itettyp(it))** gives the edge number associated with **inode** on facet **iface** of element **it.** **ielmedge1(12,iedge,itettyp(it))** gives the node offset associated with edge **iedge** of element **it.** To loop through all pairs of edge nodes **(i1,i2)** of all elements in the mesh :      do it=1,ntets     do i=1,nelmnee(itettyp(it))          i1=itet(itetoff(it)+          ielmedge1(1,i,itettyp(it)))          i2=itet(itetoff(it)+          ielmedge1(2,i,itettyp(it))      enddo      enddo To loop through all pairs of edge nodes (**i1,i2**) of all elements in the mesh by facets:      do it=1,ntets        do i=1,nelmnef(itettyp(it))          do j=1,ielmface0(i,itettyp(it))            ie=ielmface2(j,i,itettype(it))            i1=itet(itetoff(it)+            ielmedge1(1,ie,itettyp(it)))            i2=itet(itetoff(it)+            ielmedge1(2,ie,itettyp(it)))          enddo        enddo      enddo jtet**jtet(jtetoff(it)+j)** gives the element number and local facet number of the neighbor to element **it**, facet **j**. To loop to find all face neighbors of elements ** ** ( **jt** is the neighbor element number**, jf** is the local facet of the neighboring element) if **jt** is a neighbor of element **it** and local face **if** of **it** is the shared face **jf** of **jt** then **jtet** (**jtetoff(it)** + **if**) = **nef\\_cmo*** (**jt-**1)+**jf,** where **nef\\_cmo i**s the number of faces per element. Similarily, **jtet** (**jtetoff(jt)** + **jf**) = **nef\\_cmo*** (**it** -1) ** ** + **if mbndry** is the value added to **jtet** if element **it** is on a boundary or interface; the **jtet** value of an element **it** with facet **j** on an exterior boundary will be exactly **mbndry;** the **jtet** value of an element it with facet **j** on an interior interface will be **mbndry** + the **jtet** value calculated from the neighboring element number and neighbor element local\\_facet number): c get number of faces per element for this mesh object call cmo_get_info(`faces_per_element',cmo_name, nef_cmo,ilen,ity,ics) do it=1,ntets do i=1,nelmnef(itettyp(it)) c check if element face is on an external boundry if(jtet(jtetoff(it)+i).eq.mbndry) then jt=0 jf=0 c check if element face is on an internal boundry elseif(jtet(jtetoff(it)+i).gt.mbndry)then jt=1+(jtet(jtetoff(it)+i)-mbndry-1)/nef_cmo jf=jtet(jtetoff(it)+i)-mbndry-nef_cmo*(jt-1) C Volume element else jt=1+(jtet(jtetoff(it)+i)-1)/nef_cmo jf=jtet(jtetoff(it)+i)-nef_cmo*(jt-1) endif enddo enddo",
    "tags": "",
    "url": "/pages/docs/meshobjcon.html"
  },{
    "title": "Mesh Object Definition",
    "text": "# Mesh Object Definition The data structure which contains the information necessary to define a mesh is called a Mesh Object. A Mesh Object consists of attributes that define the mesh identified by a mesh object name. Attributes are updated by LaGriT routines and can be modified by the user. Use the command **cmo/status** to see the attributes for all mesh objects, or use **cmo/status**/*cmo_name* for the attributes of the mesh object identified by that name. The default Mesh Object can be expanded by adding user defined attributes with **[cmo/addatt](/pages/docs/commands/cmo/cmo_addatt.html)**. User attributes can be removed with **[cmo/delatt](/pages/docs/commands/cmo/cmo_delatt.html)**. Default mesh object attributes can not be removed. Some of the LaGriT routines add attributes to the mesh object. The user should never try to add an attribute whose name is already listed as a mesh object as these are reserved as mesh object attribute names (See below). The value of many of the scalar attributes can be changed by the **[cmo/setatt/](/pages/docs/commands/cmo/cmo_setatt.html)** command. For instance, cmo/setatt/cmo_name/epsilonl/1.d-9 will set the attribute epsilonl to 1.d-9 for the mesh object named cmo_name. ## Mesh Object Attributes These are default attributes for a Mesh Object: * **name** (`character*32` -- mesh object name, this is the unique identifier for any particular mesh object) * **scalar** (`integer` -- defined to have value 1) * **vector** (`integer` -- defined to have value 3) * **nnodes** (`integer` -- number of nodes in the mesh) * **nelements** (`integer` -- number of elements in the mesh, e.g. triangles, tetrahedra) * **nfaces** (`integer` -- number of unique topological facets in the mesh, e.g. number of edges in 2D or number of element faces in 3D). This is not maintained but may be used by certain commands or by the user. * **nedges** (`integer` -- number of unique edges in mesh) This is not maintained but may be used by certain commands or by the user. * **mbndry** (`integer` -- value signifying that if the node number is greater than **mbndry** then the node is a boundary node; default 16000000) This value must be greater than 48 \\* nnodes and may be reset by **[connect](/pages/docs/commands/CONNECT1.html)** (for an example of usage see [Mesh Object Connectivity](/pages/docs/meshobjcon.html#mbndry)). * **ndimensions_topo** (`integer` -- topological dimensionality; 1, 2 or 3. i.e. a non-planar surface would have ndimensions_topo = 2 and ndimensions_geom = 3.) * **ndimensions_geom** (`integer` -- 1, 2 or 3 for dimension of geometry; default 3) * **nodes_per_element** (`integer` -- value dependent on type of mesh; e.g. for tetrahedral mesh the value will be 4) * **edges_per_element** (`integer` -- value dependent on type of mesh; e.g. for tetrahedral mesh the value will be 6) * **faces_per_element** (`integer` -- topological number of facets per element (i.e. in 1D this number is always 2, for 2D use the number of edges of the element, for 3D use the number of faces of the element; e.g. for tetrahedral mesh the value will be 4) * **isetwd** (`integer array` containing pset membership information, see **[pset](/pages/docs/commands/PSET.html)** command definition) * **ialias** (`integer array` of alternate node numbers, i.e. for merged points) * **imt1** (or **imt**) (`integer array` of node material values, must be values greater than zero ) * **itp1** (or **itp**) (`integer array` of node types if type &gt; 20 node will be invisible) These values can be updated anytime with the **resetpts/itp** command. Use **rmpoint/compress** to remove dudded nodes from the mesh object. | itp | name | description | :---- | :---- | :------------ |0 | int | Interior |2 | ini | Interface |3 | vrt | Virtual |4 | vin | Virtual + interface |8 | vif | Virtual + interface + free |9 | alb | Virtual + Interface + free + reflective |10 | rfl | Reflective boundary node  |11 | fre | Free boundary node  |12 | irb | Interface node on reflective boundary |13 | ifb | Interface node on free boundary |14 | rfb | Node on intersection of free boundary and reflective boundary |15 | irf | Interface node on intersection of free boundary and reflective boundary |16 | vrb | Virtual node on reflective boundary |17 | vfb | Virtual node on free boundary |18 | vrf | Virtual node on free + reflective boundary |19 | vir | Virtual + interface node on reflective boundary |20 | mrg | Merged node |21 | dud | Dudded node |41 | par | Parent node for doubly defined nodes **icr1** (or **icr**) (`integer array` of constraint numbers for nodes; the value of this array is an index into the **[icontab](#icontab)** table of node constraints described later in this section) **isn1** (or **isn**)(`integer array` of child, parent node correspondence) Points on material interfaces are given itp1 point type 41 (parent). One child point is spawned for each material meeting at the parent point. The isn1 field of the parent point will contain the point number of the first child point. The isn1 field of the first child will contain the point number of the next child. The isn1 field of the last child will contain the point number of the parent. The point types of the child points will be 2, 12, 13, 15 or 19 depending on whether the interface point is also on an exterior boundary. This parent, child relationship is established by the **settets** command and is undone by the **resetpts/parents** command. **xic**, **yic**, **zic** (`real arrays` of node x, y, z coordinates) **itetclr** (`integer array` of element material values, should be greater than zero) **itettyp** (`integer array` of element shape values. For an example of usage see **[Mesh Object Connectivity](/pages/docs/meshobjcon.html#itettyp))**. See element conventions at **[Supported element types](/pages/docs/supported.html)** | data_name | value | name | description | :--------- | :---- | :---- | :-------- |ifelmpnt | 1 | pnt | point (also known as node or vertex) |ifelmlin | 2 | lin | line |ifelmtri | 3 | tri | triangle  |ifelmqud | 4 | qud | quadrilateral  |ifelmtet | 5 | tet | tetrahedron  |ifelmpyr | 6 | pyr | pyramid |ifelmpri | 7 | pri | prism  |ifelmhex | 8 | hex | hexahedron  |ifelmhyb | 9 | hyb | hybrid |ifelmply | 10 | ply | polygon **xtetwd** (`integer array` containing eltset membership information, see eltset command definition ) **itetoff** (`integer array` index into itet array list for elements, for an example of usage see [Mesh Object Connectivity](/pages/docs/meshobjcon.html#itetoff)) **jtetoff** (`integer array` index into jtet array list for elements, for an example of usage see [Mesh Object Connectivity](/pages/docs/meshobjcon.html#jtetoff)) **itet** (`integer array` of node vertices for each element, for an example of usage see [Mesh Object Connectivity (meshobjcon.md#itet)) **jtet** (`integer array` of element connectivity, for an example of usage see [Mesh Object Connectivity](/pages/docs/meshobjcon.html#jtet)) **ipolydat**, **vor2d**, **vor3d** (`character yes or no`, default **yes**. These flags include data when writing GMV output files, these can decrease the file size but limits the information written.) **ipolydat** writes polygon data, **vor2d** writes voronoi and median cells for 2D, **vor3d** writes voronoi and median cells for 3D meshes. See **[dump/gmv](/pages/docs/commands/DUMP2.html)** **dumptype** (`character` with default set to binary, type of gmv file to write) **epsilon** (`real` value of machine epsilon which will be calculated by the code.) **epsilonl** (`real` value of smallest edge length that the code can distinguish and will be set internally by the code, see **[setsize](/pages/docs/commands/SETSIZE.html)** ) **epsilona** (`real` value of smallest area that the code can distinguish and will be set internally by the code ) **epsilonv** (`real` value of smallest volume that the code can distinguish and will be set internally by the code ) **ipointi**, **ipointj** (`integer` value with the node number of the first node and last node of the current set of nodes, used by the indexing syntax for point sets: / 0,0,0 / **[pset](/pages/docs/commands/PSET.html)**) **idebug** (`integer` value indicating level of debug output, flag values greater than 0 produce increasing levels of output with 5 or greater generating the most information ) **itypconv_sm**, **maxiter_sm** (`integer` values used by the smooth routines. maxiter_sm has default 25 and are the number of smoothing iterations in **[smooth](/pages/docs/commands/SMOOTH.html)** and **[radapt](/pages/docs/commands/RADAPT.html)** ) **tolconv_sm** (`real` value used by the smooth routines) **nnfreq** (`integer` value with default 1, flag to control reconnection after **[refine](/pages/docs/commands/REFINE.html)** This is set to zero to turn off reconnection.) **ivoronoi** (`integer` value with default 1, flag to control reconnection criterion. See **[recon)](/pages/docs/commands/RECON.html)** ) ``` +1 means restore delaunay -2 means improve geometric quality of the elements +2 means adaptive reconnection with user supplied routine +5 means disable all reconnection ``` **iopt2to2** (`integer` value with default 2, flag to contol boundary flips during reconnection. See **[recon)](/pages/docs/commands/RECON.html)** ) ``` 0 = exterior boundaries 1 = interfaces 2 = exterior boundaries and interfaces 3 = all ``` **velname**, **densname**, **presname**, **enername** (`character` specialized attribute names for velocity, density, pressure, and energy variables. Default names set to vels, ric, pic, and eic. ) **xmin**, **xmax** (`real` value with minimum and maximum x coordinate of nodes in the mesh. Values are set internally and by **[setsize](/pages/docs/commands/SETSIZE.html)** ) **ymin**, **ymax** (`real` value with minimum and maximum y coordinate of nodes in the mesh. Values are set internally and by **[setsize](/pages/docs/commands/SETSIZE.html)** ) **zmin**, **zmax** (`real` value with minimum and maximum z coordinate of nodes in the mesh. Values are set internally and by **[setsize](/pages/docs/commands/SETSIZE.html)** ) **kdtree_level** (`integer` with default value 0. This is the resolution level, number of octree refinements where 0 means terminal nodes contain 1 0 means terminal nodes contain 1 member.) **max_number_of_sets** (`integer` with default value of 32. This is the number of **[pset](/pages/docs/commands/PSET.html)** and **[eltset](/pages/docs/commands/ELTSET2.html)** allowed for a single mesh object.) **number_of_psets**, **number_of_eltsets** (`integer` value with the number of psets and eltsets in the mesh.) **psetnames**, **eltsetnames** (`character` are the set names for pset and eltset) **geom_name** (`character` with default set to -defaultgeom-. This is the name of geometry associated with this mesh.  See **[geom)](/pages/docs/commands/cmo/cmo_geom.html)**) **fset_names** (`integer` value with the number of face sets in the mesh.) **number_of_fsets** (`character` are the set names for fset.) The above are the default attributes for a mesh object. Multiple mesh objects can be defined, all with their own attributes and attribute values. Added attributes will be listed after this list of defaults if they have been added. The current state and list of attributes of a mesh object can be displayed by using the command **[cmo/status](/pages/docs/commands/cmo/cmo_status.html)**. ## Mesh Object Attribute Definition Each attribute (either default attribute or added attribute) in a mesh object has the following defined: * **name**  `character` Attribute name, case sensitive. * **type**  `character` with default VDOUBLE. Attribute type is one of the following, case ignored. ``` INT- Integer REAL - Real number CHARACTER - character string (length 32) VINT - Vector of integer VDOUBLE - Vector of real (this is the default) VCHAR - Vector of character strings ``` * **rank**  `character` with default [scalar](#scalar). This is the attribute rank set by an attribute for this Mesh object. * **length**  `character` with default [nnodes](#nnodes). This is the attribute length set by an attribute for this Mesh object. * **interpolation**   `character` with default linear. This is the interpolation option for routines to use: ``` linear   - Linear interpolation  (this is the default) constant - Constant value sequence - Set to the node number copy     - Copy values user     - User provides a subroutine named user_interpolate log      - Logarithmic interpolation asinh    - Asinh interpolation min      - Set to the minimum max      - Set to the maximum incmin   - Set to the minimum plus one (vint attribute only) incmax   - Set to the maximum plus one (vint attribute only) and      - 'and' the bits or       - 'or' the bits ``` * **persistence**    `character` with default temporary. Attribute persistence where **permanent** can not be deleted, **temporary** can be deleted. * **ioflag** `character` with default alg. These letters are IO flags to define what type of common output files this attribute can be written to. By default, the dump command will write all attributes, this flag can be used to limit which attributes are dumped. ``` a - write this attribute on avs dumps g - write this attribute on gmv dumps f - write this attribute on fehm dumps l - write this attribute on LaGriT dumps L - Do Not write this attribute on LaGriT dumps ``` * **default** `real` default is 0.0. This is the attribute value to initialize the data with.",
    "tags": "",
    "url": "/pages/docs/meshobject.html"
  },{
    "title": "",
    "text": "**Point Selection** **getptyp(**point\\_type\\_name,point\\_type,ierror) This routine converts point type names to point types. [See III.a](/pages/docs/meshobject.html)for a list of point types, names and meanings point\\_type\\_name            name of point type (character *32) point\\_type                       value of point type (integer) **unpackpc(**npoints,itp,isn,iparents) This routine returns in the array iparents the parent point corresponding to each child point i, if point i is a child point. Ordinary points are their own parents.  The first three arguments are usually mesh object attributes described in [Section III.a](meshobject.md) npoints                        input number of nodes (integer) itp1                             input array of point types (integer array) isn1                             input array of parent child links (integer array) iparents                       input/output array of parent node number for each point (integer array) **unpacktp**(ioptitp,iopt2,inum,ipitp1,ipitp2,ierror) This routine sets, or's in, or and's in (depending on iopt2) a 1 in the array pointed to by ipitp2 for each point that fits the criterion specified by ioptitp. ioptitp uses the point types as defined in [Section III.a ](/pages/docs/meshobject.html)  and ipitp1is the pointer to the integer array of point types. A zero is set, or'd or and'd otherwise. ioptitp criterion **  allreal             ** (0&lt;itp1(i)&lt;19) **  interior           ** (itp1(i)=0) **  inteintf**                (itp1(i)=2,3,4) **  matlintr           ** (itp1(i)=2,4,8,9,12,13,15,19) **  boundary         ** (8&lt;itp1(i)&lt;19) **  reflect             ** (itp1(i)=9,10, 12, 14, 15,16,18,19) **  free                ** (itp1(i)=8,9,11, 13, 14, 15,17,18) **  intrface           ** (itp1(i)=2,3,4,8,9,12, 13,15,16,17,18,19) **  virtual**                (itp(i)=3,4,8,9,16,17,18,19) **  removed          ** (20&lt;itp1(i)&lt;29) **  merged           ** (itp1(i)=20) **  dudded           ** (itp1(i)=21) opt2     operation **          set                    ** set itp2 to 1 or 0 **          or                     ** or in a 1 or 0 in itp2 **          and                  ** and in a 1 or 0 in itp2                     inum                         input number of nodes in the array pointed to by ipitp1                     ipitp1                        input pointer to integer array of point types (length inum)                     ipitp2                        input pointer to output integer array of 1's or 0's (length inum)                                                       on output array pointed to will have been filled.",
    "tags": "",
    "url": "/pages/docs/pointsel.html"
  },{
    "title": "read / avs",
    "text": "# read / avs read an AVS format file into a mesh object. This command requires either cmo-name to be given in the command or for a mesh object to have been created previously. This file format contains no geometry information.  ## SYNTAX **read**/ filename.[inp or .avs] / cmo_name **read** **/avs**/ filename /[cmoname]/[ node_flag / element_flag / attribute_flag] ## OPTIONS   | Argument | Default | Description | | :----------------- | :------ | :----------------------- | | node_flag | 1 | 0=skip node data 1=read node data | | element_flag | 1 | 0=skip element data 1=read element data | | attribute_flag | 1 | 0=skip attribute data 1=read attribute data | ## EXAMPLES ``` read/ file1.inp /cmo1 read/ avs / file1 /cmo1 ``` read into existing and current mesh object and skip, do not read the attribute data ``` read/ avs / file2.avs / /1/1/0 ``` ## AVS UCD ASCII FILE FORMAT AVS (avs.com) is a data visualization tool with ASCII mesh file formats used by LaGriT as they are easy to read and easy to convert from and to other mesh file formats. The Unstructured Cell Data (UCD) format is described here. A UCD data structure consists of an irregular coordinate structure made up of cells of various types. Each cell has a corresponding number of nodes and connectivity. Data can be associated with each node, cell, or the entire \"model\". The data is structured as a set of components. Each component can be either a scalar or a vector. The input file cannot contain blank lines or lines with leading blanks. Comments, if present, must precede all data in the file. The general order of the data is as follows. 1. Numbers defining the overall structure, including the number of nodes, the number of cells, and the length of the vector of data associated with the nodes, cells, and the model. 2. For each node, its node id and the coordinates of that node in space. Node ids must be integers, but any number including non sequential numbers can be used. Mid edge nodes are treated like any other node. 3. For each cell: its cell id, material, cell type, and the list of nodes for the cell connectivity. These are the valid AVS cell types with node order relative to LaGriT ordering conventions as shown at **[LaGriT Supported Element Types](/pages/docs/supported.html)** ``` pt (Point) avs order = lagrit order line (Line) avs order = lagrit order tri (Triangle) avs order = lagrit order quad (Quadrilateral) avs order = lagrit order tet (Tetrahedron) avs order = 1 2 4 3 pyr (Pyramid) avs order = 5 1 2 3 4 prism (Prism) avs order = 4 5 6 1 2 3 hex (Hexahedron) avs order = 5 6 7 8 1 2 3 4 ``` 4. Optional Node based data descriptions: data vector for nodes and number components that vector is divided into. 5. For each node data a label on seperate lines; label/unit label pair, separated by a comma. 6. For each node in a separate line, the vector of data values associated with it. 7. Cell based data descriptions, if present, then follow in the same order and format as items 4, 5, and 6. This is the format of the AVS ASCII UCD file: # comment num_nodes num_cells num_node_data num_cell_data num_model_data node_id_1 x y z . . . node_id_n x y z cell_id_1 mat_id cell_type cell_vert 1 ... cell_vert n . . . cell_id_n mat_id cell_type cell_vert 1 ... cell_vert n num_node_data node_data_1_size node_data_n_size node_data_1_label, units_data_1 . . . node_data_n_label, units_data_n node_id_1 node_data_1 ... node_data_n . . . node_id_n node_data_1 ... node_data_n num_cell_data cell_data_1_size cell_data_n_size cell_data_1_label, units_data_1 . . . cell_data_n_label, units_data_n cell_id_1 cell_data_1 ... cell_data_n . . . cell_id_n cell_data_1 ... cell_data_n This is an Example ASCII UCD File for a single hexahedral cell with 8 nodes. The first line header indicates 8 nodes, 1 element, 2 node attributes, 0 element attributes, 0 model attributes. In the section where attributes are defined, the first line indicates there are 2 attributes, both scalar. After the first attribute line is the list of attribute names along with their type. 8 1 2 0 0 1 0.000 0.000 1.000 2 1.000 0.000 1.000 3 1.000 1.000 1.000 4 0.000 1.000 1.000 5 0.000 0.000 0.000 6 1.000 0.000 0.000 7 1.000 1.000 0.000 8 0.000 1.000 0.000 1 1 hex 1 2 3 4 5 6 7 8 002 1 1 layer, integer stress, real 1 1 4999.9999 2 1 18749.9999 3 1 37500.0000 4 1 56250.0000 5 0 74999.9999 6 0 93750.0001 7 0 107500.0003 8 0 5000.0001 This is an Example ASCII UCD File for a point, this is handy for use with Paraview to render the point object instead of reading point values into a table. This example has 3 nodes, each as UCD object **pt**. The file has 0 attributes for nodes, elements, and model. 3 3 0 0 0 001 3.304250000000E+05 4.309168000000E+06 0.000000000000E+00 002 3.308220000000E+05 4.314749000000E+06 0.000000000000E+00 003 3.259190000000E+05 4.313480000000E+06 0.000000000000E+00 001 1 pt 1 002 1 pt 2 003 1 pt 3",
    "tags": "",
    "url": "/pages/docs/read_avs.html"
  },{
    "title": "",
    "text": "**read/datax** read a 'datax' file **FORMAT:** **read** **/datex**/file\\_name",
    "tags": "",
    "url": "/pages/docs/read_datex.html"
  },{
    "title": "",
    "text": "**read/ zone** **read/ zonn** **read/ zone_element** Read in a list of node numbers in FEHM zone or zonn file format (See  EXAMPLE COMMANDS USING ZONE FILES: * * LaGriT control file to test read / zonezonn * * cmo / create / cmo / / / tet createpts / xyz / 10 10 10 / 0. 0. 0. / 1. 1. 1. / 1 1 1 cmo / setatt / cmo / imt / 1 0 0 / 1 cmo / setatt / cmo / imt / 1 100 1 / 2 cmo / setatt / cmo / imt / 101 200 1 / 3 * * Output zone file test_material.zone * dump / zone_imt / test / cmo * cmo / addatt / cmo / itmp1 / vint / scalar / nnodes * * Test various command line options. c read / zone / test_material.zone read / zone / test_material.zone / cmo read / zone / test_material.zone / -def- / -def- read / zone / test_material.zone / cmo / -def- read / zone / test_material.zone / cmo / imt read / zone / test_material.zone / cmo / itmp1 read / zone / test_material.zone / cmo / itmp2 * * Create some zone and zonn files to read. * pset / pzone1 / seq / 1 100 1 pset / pzone1 / zone / pset_zone1.zone / ascii pset / pzonn1 / seq / 1 300 1 pset / pzonn1 / zonn / pset_zonn1.zonn / ascii pset / pzonn2 / seq / 101 300 1 pset / pzonn2 / zonn / pset_zonn2.zonn / ascii * * Read zone and zonn type files. * read / zone / pset_zone1.zone / cmo / itmp4 * * Since zonn files do not first initilize the array to zero * one can read in multiple zonn files and only the values of * the entries in the list are set. * read / zonn / pset_zonn1.zonn / cmo / itmp5 read / zonn / pset_zonn2.zonn / cmo / itmp5 * * Output GMV file. * dump / gmv / test_read_zone.gmv / cmo * * Test some error conditions. * read / zone read / zonn read / zone / nofile read / zone / test_material.zone / nocmo * finish",
    "tags": "",
    "url": "/pages/docs/read_fehm_zone.html"
  },{
    "title": "",
    "text": "**read/gmvfreeformat** Option **read/gmvfreeformat** for ascii gmv files to be read with read(*) type read statements. This command requires that the mesh object name be specified or that a mesh object has been created previously.  This file format contains no geometry information.  The file will be read using free format  read statement, i.e. read(unit, *) ## SYNTAX **read**/gmvfreeformat/filename/[cmo-name] ## EXAMPLES ``` read/ gmvfreeformat/file.gmv/cmo1 cmo/create/cmo1 read/ gmvfreeformat/file.gmv  ```  ",
    "tags": "",
    "url": "/pages/docs/read_freeformat.html"
  },{
    "title": "",
    "text": "**read/gmv** read an ascii or binary gmv file.  This command requires that the mesh object name be specified or that a mesh object has been created previously.  This file format contains no geometry information.  The file may be either ascii or binary;  The code will determine the format based on the file header. SHORT **FORMAT:** **read** / filename.gmv / cmo_name (Note that the filename is case-sensitive, though the extension itself is not.) LONG **FORMAT:** **read/gmv** / file_name / [cmo-name] **EXAMPLES:** **read/gmv** / file.gmv / cmo1 **read/gmv** / file.gmv (a mesh object must alread exist) For more about GMV and documentation: [GMV (General Mesh Viewer)](http://www.gmv-barracuda.com/index.html) The GMV Application is no longer supported but code is available from Github at: [CPFD Software GMV](https://github.com/CPFDSoftware/gmv)",
    "tags": "",
    "url": "/pages/docs/read_gmv.html"
  },{
    "title": "read/gocad",
    "text": "# read/gocad Read an ascii GOCAD TSurf triangle file (.ts) or a TSolid tet file (.so). GoCAD has a number of possible data types contained within files and may contain multiple data sets. LaGrit can read a limited set of these types that are commonly used by our applications. The data types contained in the GOCAD file are described in the HEADER area and KEYWORDS. Many KEWORDS are not needed for the mesh and are ignored. The following are supported: | KEYWORD | Description | | :----------------- | :----------------------- | | GOCAD | followed by mesh type TSolid or Tsurf | | ZPOSITIVE | indicates Z as Depth or Elevation (default) | | PROPERTIES | vertex property names for values listed after VRTX x y z, LaGriT will add as mesh node attributes | | TETRA_PROPERTIES | tet property names for values listed after TETRA id1 id2 id3 id4, LaGriT will add as mesh element attributes | | TRGL_PROPERTIES | tri property names for values listed after TRGL id1 id2 id3, LaGriT will add as mesh element attributes | | VRTX or PVRTX | vertex keyword followed by x y z and optional property values, node number is implied by order | | TETRA | tet element keyword followed by node numbers and optional property values, element number is implied by order | | TRGL | tri element keyword followed by node numbers and optional property values, element number is implied by order | | TFACE | triggers a new set of elements, attribute **iblock** will be incremented | | END | end of mesh set | Some applications such as JewelSuite use a left-hand coordinate system and the header will include keywords **ZPOSITIVE Depth**. LaGriT will convert this to a right-hand coordinate system with elevations Z positive. See *LaGriT/test/level03/read_gocad* for example GOCAD files. See http://paulbourke.net/dataformats/gocad/ for further details on GoCad. ## SYNTAX **read** / **gocad** / filename[.ts or .so] / cmoname ## EXAMPLES ``` read/gocad / JS_mesh.so /cmotet cmo/printatt/cmotet/ -all- minmax quality ``` read 3D TETRA into mesh object cmotet, check the min and max values of added attributes (created from GOCAD PROPERTY arrays). Check that read worked correctly by using **quality** command to report positive volumes. ``` read/gocad /input_3tri_all_props.ts / cmotri quality ``` read 2D triangulated surface (tsurf) file into mesh object cmotri. Check that read worked correctly by using **quality** command to report positive volumes. ## EXAMPLE GOCAD 3D TETRA FILE ex_2tet.so This example has 2 tet elements, 0 node properties, and 1 cell property named \"ZoneId\". This was written by JewelSuite which defines Z as Depth. ``` GOCAD TSolid 1 HEADER { name:3D Mesh Structural Model SMALL *solid*color:0.498039 0.498039 0.498039 0.5 } GOCAD_ORIGINAL_COORDINATE_SYSTEM NAME Default AXIS_NAME \"X\" \"Y\" \"Z\" AXIS_UNIT \"m\" \"m\" \"m\" ZPOSITIVE Depth END_ORIGINAL_COORDINATE_SYSTEM TETRA_PROPERTIES ZoneId TETRA_PROP_LEGAL_RANGES **none** **none** TETRA_NO_DATA_VALUES -999.25 TETRA_PROPERTY_CLASSES ZoneId TETRA_PROPERTY_KINDS unknown TETRA_PROPERTY_SUBCLASSES QUANTITY Float TETRA_ESIZES 1 TETRA_UNITS unitless TETRA_PROPERTY_CLASS_HEADER ZoneId{ low_clip:1 high_clip:2 } TVOLUME VRTX 1 241542.64788705 3569942.9650014676 -684.72122323805638 VRTX 2 241569.11887199868 3569823.3059474104 -701.15237792621951 VRTX 3 241601.07618168893 3569932.2043372113 -750.27786898670399 VRTX 4 241527.6427429766 3569878.153216748 -786.94401445577932 VRTX 5 241630.376379692 3569879.0671290001 -814.42141248757616 TETRA 1 2 3 4 1 TETRA 3 4 2 5 1 END ``` The screen output for reading this file will look like: read gocad ex_2tet.so mo1 cmo/create/mo1///tet ................................................... SET VRTX properties: There are no VRTX properties. READ VRTX data with word count: 5 READ VRTX property with index: 0 ................................................... SET CELL properties: cmo/addatt/mo1/ZoneId/VINT scalar/nelements/linear/permanent/gxaf/0.0/ READ CELL data with word count: 6 READ CELL property with index: 1 geniee --- READ GOCAD FINISHED -------- Mesh Type: TSolid ZPOSITIVE: Z Depth Nodes: 5 Tets: 2 Cells: 2 Cell properties: 1 LINES read: 32 The current-mesh-object(CMO) is: mo1 1 Mesh Object name: mo1 number of nodes = 5 number of elements = 2 dimensions geometry = 3 element type = tet dimensions topology = 3 4 nodes 4 faces 6 edges boundary flag = 16000000 status = active",
    "tags": "",
    "url": "/pages/docs/read_gocad.html"
  },{
    "title": "",
    "text": "**read/iges\\_grid** reads and processes an IGES file containing surfaces, curves and points in IGES nurbs format. **FORMAT:** **read** **/iges\\_grid**/file\\_name/[iopt\\_nurbs]/[iopt\\_nurbl]/[iopt\\_nurp]/[ksi]/[ksj]/[kli] Argument | Default | Description ------------ ----------- ----------------------------------- iopt-nurbs | default=1 | read quad nurb surface if =1 iopt-nurbl | default=0 | read triangle nurb surface if = 2 iopt-nurbp | default=0 | read triangle nurb curves if = 1 ksi, ksj | | dimensions of surface nurb kli | | dimension of line nurb",
    "tags": "",
    "url": "/pages/docs/read_iges_grid.html"
  },{
    "title": "read/lagrit #",
    "text": "# read/lagrit # Read a LaGriT restart file, the mesh object name and definitions are included in this file. ## SYNTAX ## read/ filename.lg or filename.lagrit [cmo_name (ignored)] [ascii or binary] read / lagrit/ filename.lg or filename.lagrit / [cmo_name (ignored)] / [ascii or binary] filename.**`lg`** or filename.**`lagrit`** - these extensions are recognized and indicate a LaGriT restart file. *`cmo_name`*  - This argument is ignored as all mesh objects in the restart file are named and defined. **`ascii`** or  **`binary`**  - The default is **`ascii`**, but the code will determine file type if this option is missing. ## EXAMPLES ## ``` read / lagrit / file1.lg ``` file1.lg will be read as an ascii restart file.  If the read fails to find the ascii check string, the file will be closed and reopened for a binary read. ``` read / lagrit / hex1_mohex.bin.lg / binary ``` hex1_mohex.bin.lg will be read as a binary restart file. This example has the mesh object named mohex defined.",
    "tags": "",
    "url": "/pages/docs/read_lagrit.html"
  },{
    "title": "",
    "text": "**read** **/ngp** read in data in ngp format FORMAT **read** **/ngp**/[tet hex quad tri]/file\\_name tet is default",
    "tags": "",
    "url": "/pages/docs/read_ngp.html"
  },{
    "title": "",
    "text": "**read/sheetij** creates a quad mesh from an elevation file using syntax similar to avs type .fld header file. Note the input file is assumed to contain elevation values and are read as Z(i,j) into the cmo attribute \"zic\". For node attribute values of f(i,j), use addatt and copyatt as shown in the examples below. **FORMAT:** **read** **/sheetij**/ file\\_name /nx,ny/minx,miny/dx,dy [options] **read** **/sheetij**/ file\\_name /nx,ny/minx,miny/dx,dy/ skip n / [options] **read** **/sheetij**/ file\\_name /nx,ny/minx,miny/dx,dy/istart,jstart,istop,jstop/[options] **read** **/sheetij**/ file\\_name/-header-/[options] Argument | Description --------------------------- | ------------------------------------------------------ nx | columns in x direction ny | rows in y direction min, miny | location of lower left corner xinc, yinc | cell size in x and y direction -header- | keyword meaning read nx, ny,miny,xinc,yinc,from file skip n | skip n number of header lines istart,istop,jstart,jstop | gives indices of ij subset   --------------------------- ------------------------------------------------------ Option | Description --------------------------- | --------------------------------------------------------------- **ascii** or **binary** | file-type (default-**ascii**) **center** | assume elevation at cell center (default = lower left corner) **connect** or **points** | **connect** causes quad grid to be formed and is default. **points** keeps data as points only. **float** or **double** | size of data (default = **float**) **xflip** or **yflip** | reflect along x or y axis (default = no reflection)  --------------------------- --------------------------------------------------------------- **EXAMPLES:**  for data file with header - test\\_hdr.dat, showing nx, ny, min x, min y, dx, dy          #  5              #  4              #         0.0000000            #         0.0000000            #         5.000000             #         5.000000             #        to read elevations using information in the file header        cmo create cmohdr        read sheetij test\\_hdr.dat / -header- / ascii        to subset read ascii file with header and subset from i=2,5 and j=3,4          read sheetij test\\_hdr.dat / -header- / 2,5, 3,4 / ascii        for binary files with no headers where nx=5, ny=4, minx=miny=0., xinc=yinc=5.          read sheetij test.bin /5,4 /0.0,0.0 / 5.0,5.0 / binary        to flip along the x-axis          read sheetij test.bin /5,4 /0.0,0.0 / 5.0,5.0 / xflip, binary        read temperature values from file instead of elevation         cmo create cmot         read sheetij temp.dat / 150,183 /1602850.,1727950. / &         500.0,500.0 / skip 6         cmo / addatt / cmot / tempval / VDOUBLE / scalar / nnodes         cmo / copyatt / cmot / cmot / tempval / zic         cmo / setatt / cmot / zic / 0. TEST **EXAMPLES:** Test file for sheetij: [LaGriT_input00](/pages/docs/demos/input/lagrit_input00.txt) Test data for sheetij: [test_data](/pages/docs/demos/input/test_data.txt) ![Quad sheet](image/zall_200w.GIF) * read ascii elevations into quad sheet cmo create cmo1 read sheetij test_data /5,4 /0.0,0.0 & / 5.0,5.0 / ascii ![Quad sheet with xflip](image/zall_xflip_200w.GIF) * read ascii elevations and flip x cmo create cmo1 read sheetij test_data /5,4 /0.0,0.0 & / 5.0,5.0 / xflip, ascii ![Quad sheet with xy flip](image/zall_xyflip_200w.GIF) * read binary elevations and subset along ij cmo create cmo1a read sheetij qbog50_l.float /31,21/ 0. 0./ 50.0,50.0 & /10,25 1,10/ binary / float * combine grids for viewing math/sub/cmo1a/zic/1,0,0/cmo1a/zic/500. addmesh merge cmov cmo1 cmo1a dump gmv view_binsurf_subset.gmv cmov",
    "tags": "",
    "url": "/pages/docs/read_sheetij.html"
  },{
    "title": "",
    "text": "**read** **/vrml** read a 'vrml' file **FORMAT:** **read** **/vrml**/file-name",
    "tags": "",
    "url": "/pages/docs/read_vrml.html"
  },{
    "title": "",
    "text": "**Retrieving Point Sets and Element Sets** **eltlimc** returns an array of element numbers where the elements belong to the **eltset** given in the argument list. ** ** Eltsets must be specified by name. On return the array pointed to by ipmpary will contain the mpno element numbers that belong to the eltset. **eltlimc**(ich1, ich2, ich3, ipmary, mpno, ntets, xtetwd) Argument | Description --- | --- ich1,ich2,ich3 | eset,get,eltset_name (character*32) ipmpary | pointer to array of elements of eltset_name that is filled on output mpno | integer number of elements in eltset_name (output) ntets | integer number of elements in mesh object (input) xtetwd | array of eltset membership information (input) see See III.a **pntlimc, pntlimn** return an array of node numbers where the nodes belong to the **pset** given in the argument list. On return the array pointed to by ipmpary will contain mpno node numbers. These numbers are the nodes that belong to the **pset**. **pntlimc**(ich1, ich2, ich3, ipmary, mpno, npoints, isetwd, itp1) Argument | Description --- | --- ich1,ich2,ich3 | pset,get,pset_name (character*32) ipmpary | pointer to array of node number of pset_name that is filled on output mpno | integer number of nodes in pset_name (output) npoints | integer number of nodes in mesh object (input) isetwd | array of pset membership information See III.a itp1 | array of point types See III.a32G **pntlimn**(ifirst, ilast, istride, ipmary, mpno, npoints, isetwd, itp1) Argument | Description --- | --- ifirst,ilast,istride | point range: first node, last node, stride between nodes (integers) ipmpary | pointer to array of node number of pset_name that is filled on output mpno | integer number of nodes in pset_name (output) npoints | integer number of nodes in mesh object (input) isetwd | array of pset membership information See III.a itp1 | array of point types See III.a",
    "tags": "",
    "url": "/pages/docs/retpts.html"
  },{
    "title": "LaGriT Supported Element Types",
    "text": "# LaGriT Supported Element Types The following element types are recognized by LaGriT. Though underlying code supports hybrid or polygon shaped elements, they are not supported by most the commands. The command pages indicate limitations on element types as they apply. Note other mesh formats or applications may have different ordering conventions. - point (pnt) (also known as node or vertex) - line (lin) - triangle (tri) - quadrilateral (qud) - tetrahedron (tet) - pyramid (pyr) - prism (pri) - hexahedron (hex) - hybrid (hyb) - polygon (ply) The following are the numbering conventions used by LaGriT for each element type. The 3D face ordering is such that the right-hand-normals of all facets point outward. * red is the face number (for 3D figures, number of front face is printed below the figure) * blue is the node number on the element vertices * green is the edge number (arrow gives edge direction) ## point | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 | 0 | 0 | ## line | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 | 12 | 0 | ## triangle | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 3 | 2, 33, 11, 2 | 321 | ## quadrilateral | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 3 4 | 1, 22, 33, 44, 1 | 134 2 | ## tetrahedron | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 3 4 | 2 ,3, 41, 4, 31, 2, 41, 3, 2 | 6, 5, 46, 2, 35, 3, 14, 1, 2 | ## pyramid | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 3 4 5 | 1, 4, 3, 21, 2, 52, 3, 53, 4, 54, 1, 5 | 2, 6, 4, 11, 5, 34, 7, 56, 8, 72, 3, 8 | ## prism | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 3 4 5 6 | 1, 3, 24, 5, 61, 2, 5, 42, 3, 6, 51, 4, 6, 3 | 2, 4, 17, 9, 81, 5, 7, 34, 6, 9, 53, 8, 6, 2 | ## hexahedron | Node Order | Nodes for faces | Edges for face | | :--------- | :-------------- | :------------- | | 1 2 3 45 6 7 8 | 1, 4, 3, 25, 6, 7, 81, 2, 6, 52, 3, 7, 63, 4, 8, 71, 5, 8, 4 | 2, 6, 4, 19, 11, 12, 101, 5, 9, 34, 7 , 11, 56, 8, 12, 73, 10, 8, 2 | These describe ordering conventions used by LaGriT. See documentation for other conventions such as the AVS format described in command [**`read/avs`**](/pages/docs/read_avs.html).",
    "tags": "",
    "url": "/pages/docs/supported.html"
  },{
    "title": "ABOUT THE TEST SUITE",
    "text": "## ABOUT THE TEST SUITE The LaGriT Test Suite is located on the github repo at LaGriT/test/level01. Each directory contains input files and input.lgi with commands to run. For each test directory there is a reference directory with expected output. Differences between the \"outx3dgen\" and \"reference/outx3dgen\" files will indicate why a test fails. The reference directory also contains all out* mesh files written during the run. ## TO RUN AND CHECK A SINGLE TEST: - Go into the individual directory (ie addmesh_add). - Run lagrit exectuable and compare to files in reference directory. ``` lagrit -out outx3dgen < input.lgi diff outx3dgen reference/outx3dgen ``` - Or use default output file names: ``` lagrit < input.lgi diff lagrit.out reference/outx3dgen ``` - [addmesh_add](https://github.com/lanl/LaGriT/tree/master/test/level01/addmesh_add) - [addmesh_append](https://github.com/lanl/LaGriT/tree/master/test/level01/addmesh_append) - [addmesh_doublemesh](https://github.com/lanl/LaGriT/tree/master/test/level01/addmesh_doublemesh) - [addmesh_merge](https://github.com/lanl/LaGriT/tree/master/test/level01/addmesh_merge) - [cmo_addatt_normals](https://github.com/lanl/LaGriT/tree/master/test/level01/cmo_addatt_normals) - [cmo_readatt](https://github.com/lanl/LaGriT/tree/master/test/level01/cmo_readatt) - [connect_cube](https://github.com/lanl/LaGriT/tree/master/test/level01/connect_cube) - [connect_errors](https://github.com/lanl/LaGriT/tree/master/test/level01/connect_errors) - [createpts](https://github.com/lanl/LaGriT/tree/master/test/level01/createpts) - [createpts_filter](https://github.com/lanl/LaGriT/tree/master/test/level01/createpts_filter) - [eltset](https://github.com/lanl/LaGriT/tree/master/test/level01/eltset) - [filter](https://github.com/lanl/LaGriT/tree/master/test/level01/filter) - [grid2grid](https://github.com/lanl/LaGriT/tree/master/test/level01/grid2grid) - [hextotet](https://github.com/lanl/LaGriT/tree/master/test/level01/hextotet) - [hybrid_volume](https://github.com/lanl/LaGriT/tree/master/test/level01/hybrid_volume) - [interp_continuous](https://github.com/lanl/LaGriT/tree/master/test/level01/interp_continuous) - [interp_map](https://github.com/lanl/LaGriT/tree/master/test/level01/interp_map) - [interp_voronoi](https://github.com/lanl/LaGriT/tree/master/test/level01/interp_voronoi) - [intersect](https://github.com/lanl/LaGriT/tree/master/test/level01/intersect) - [intrp_2D_sizes](https://github.com/lanl/LaGriT/tree/master/test/level01/intrp_2D_sizes) - [io_agf_simple](https://github.com/lanl/LaGriT/tree/master/test/level01/io_agf_simple) - [pflotran_stor](https://github.com/lanl/LaGriT/tree/master/test/level01/pflotran_stor) - [pset](https://github.com/lanl/LaGriT/tree/master/test/level01/pset) - [pset_readwrite](https://github.com/lanl/LaGriT/tree/master/test/level01/pset_readwrite) - [quad_quality](https://github.com/lanl/LaGriT/tree/master/test/level01/quad_quality) - [quality](https://github.com/lanl/LaGriT/tree/master/test/level01/quality) - [read_gocad](https://github.com/lanl/LaGriT/tree/master/test/level01/read_gocad) - [recon1](https://github.com/lanl/LaGriT/tree/master/test/level01/recon1) - [refine_octree](https://github.com/lanl/LaGriT/tree/master/test/level01/refine_octree) - [refine_octree_prd](https://github.com/lanl/LaGriT/tree/master/test/level01/refine_octree_prd) - [refine_recon_quality](https://github.com/lanl/LaGriT/tree/master/test/level01/refine_recon_quality) - [rmpoint](https://github.com/lanl/LaGriT/tree/master/test/level01/rmpoint) - [rotateln](https://github.com/lanl/LaGriT/tree/master/test/level01/rotateln) - [setpts](https://github.com/lanl/LaGriT/tree/master/test/level01/setpts) - [single_triangle](https://github.com/lanl/LaGriT/tree/master/test/level01/single_triangle) - [smooth](https://github.com/lanl/LaGriT/tree/master/test/level01/smooth) - [smooth_massage](https://github.com/lanl/LaGriT/tree/master/test/level01/smooth_massage) - [sort](https://github.com/lanl/LaGriT/tree/master/test/level01/sort) - [stack_layers](https://github.com/lanl/LaGriT/tree/master/test/level01/stack_layers) - [surface](https://github.com/lanl/LaGriT/tree/master/test/level01/surface) - [triangulate_polygon](https://github.com/lanl/LaGriT/tree/master/test/level01/triangulate_polygon) - [zone_outside](https://github.com/lanl/LaGriT/tree/master/test/level01/zone_outside) - [zone_outside_minmax](https://github.com/lanl/LaGriT/tree/master/test/level01/zone_outside_minmax)",
    "tags": "",
    "url": "/pages/docs/test_list.html"
  },{
    "title": "",
    "text": "**Writing user commands** The access to user written subroutines is through the LaGriT subroutine, user\\_sub. It is passed the parsed command input line. The parser breaks up the input line into tokens and returns to LaGriT a count of number of tokens, an array containing the token types, and the tokens themselves. The parameters returned by the parser are: Name | Description ---- | ----- nwds | number of tokens msgtyp | integer array of token types : 1 for integer, 2 for real, 3 for character, msgtyp( nwds+1) = -1 imsgin | array of integer tokens, e.g. if msgtyp(i)=1 then the ith tokenis type integer and imsgin(i) contains its value xmsgin | array of real tokens, e.g. if msgtyp(i)=2 then the ith token is type real and xmsgins(i) contains its value cmsgin | array of character tokens, e.g. if msgtyp(i)=3 then the ith token is type character and cmsgin(i) contains its value). Null fields are given the integer value 0, real value 0, and character value '-def-'. If the user has written a subroutine, my\\_routine,that responds to the command, my\\_comnd, the call from user\\_sub should look like: elseif ( cmsgin( 1).eq. 'my\\_comnd') call my\\_routine( nwds,imsgin,xmsgin,cmsgin,msgtyp,ierr1). The subroutine my\\_routine should set ierr1 to zero if the command is processed successfully and should use the cmo interface routines to access the components of the Mesh Object that it needs, for example: subroutine my_routine(nwds,imsgin,xmsgin,cmsgin,msgtyp,ierr1) integer nwds, imsgin(*),msgtyp(*),ierr1 real xmsgin(*) character*32 cmsgin(*) ....character*32 cmo pointer (ipimt1, imt1(*)) integer ierror,ilen,ityp,nnodes .... c get the name of the current mesh object call cmo_get_name(cmo_name,ierror) c get the number of nodes and the material ids cmo_get_intinfo('nnodes',cmo_name,nnodes,ilen,ityp,ierror) call cmo_get_info('imt1',cmo_name,ipimt1,ilen,ityp,ierror) LaGriT will check it's internal command list and if the input command is not found it will call user\\_sub. If user\\_sub does not find the command, LaGriT will issue the error message: 'Illegal command' and continue with the next command. An empty user\\_sub is distributed with the sample driver program contained in the file adrivgen.",
    "tags": "",
    "url": "/pages/docs/writing.html"
  },{
    "title": "3D Grid Generation LaGriT",
    "text": "3D Grid Generation LaGriT ------------------------- ### Los Alamos Grid Toolbox **Geometry** - Multiple Materials - Arbitrary Moving Interfaces / Fronts - Arbitrary Point Distribution - Unstructured tet/hex hybrid **Adaption** - Refinement/De-refinement - Smoothing/geometric/ field/function - Reconnection/Delaunay/geometric **Interface** - Toolbox Architecture - User Commands - User extensible grid Data Structures - Dynamic or Static Application **Applications** - Science Based Stockpile Stewardship - 3D Grain Growth - Material Deposition/Etch - Oxidation - Diffusion - Electrostatics - Geologic Flow and Transport",
    "tags": "",
    "url": "/pages/features.html"
  },{
    "title": "GRAIN GROWTH EXAMPLES",
    "text": "GRAIN GROWTH EXAMPLES --------------------- 8 Time steps in 5 grain evolution 5 grain evolution showing grid",
    "tags": "",
    "url": "/pages/grain.html"
  },{
    "title": "Hex Examples",
    "text": "Hex Examples ============ Click on picture to expand Cartesian coordinates --------------------- [View input desk](/pages/hex1.html) Cylindrical coordinates ------------------------ [View input desk](/pages/hex2.html) Spherical coordinates ---------------------- [View input desk](/pages/hex2.html)",
    "tags": "",
    "url": "/pages/hex.html"
  },{
    "title": "Hybrid Examples",
    "text": "Hybrid Examples --------------- [View input desk](/pages/hybrid1.html) [View input desk](/pages/hybrid2.html)",
    "tags": "",
    "url": "/pages/hybrid.html"
  },{
    "title": "",
    "text": "*input.hybrid * this deck will create a hybrid grid using addmesh * create tet grid first * remove region where hex grid will be inserted * create hext grid * use addmesh to create hybrid grid * repeat geometry specifications for hybrid grid * create a 3-D tetrahedral mesh object and name it 3dmesh cmo/create/3dmesh/ * unit cube surface/cube/reflect/box/0.0,0.0,0.0/1.0,1.0,1.0/ * define z=.4,.6 plane as interface surface/cutpl1/intrface/plane/0.,0.,.4/1.,0.,.4/1.,1.,.4/ surface/cutpl2/intrface/plane/0.,0.,.6/1.,0.,.6/1.,1.,.6/ *define geometric regions region/top/ le cube and ge cutpl2 / region/bottom/ le cube and le cutpl1 / region/middle/ le cube and gt cutpl1 and lt cutpl2 / * define material regions mregion/top/ le cube and gt cutpl2 / mregion/bottom/ le cube and lt cutpl1 / mregion/middle/ le cube and gt cutpl1 and lt cutpl2 / * create 25 points (5x5x1) in a plane above the unit cube * place points on the boundaries in the x and y directions (1,1,0) rz/xyz/5,5,11/0.,0.,0./1.,1.,1.0/1,1,1/ * give the points defined by the rz command the name, rayend * assign material colors to the points * identify points that are on material interfaces * identify constrained points filter/1,0,0/ setpts * connect the points into a Delaunay tetrahedral mesh * do not connect across material interfaces - * add points if necessary to resolve material interfaces search * remove middle region rmregion/middle rmpoint/compress * grid hex part cmo/create/hexgrid///hex * unit cube surface/cube/reflect/box/0.0,0.0,0.0/1.0,1.0,1.0/ * define z=.4,.6 plane as interface surface/cutpl1/intrface/plane/0.,0.,.4/1.,0.,.4/1.,1.,.4/ surface/cutpl2/intrface/plane/0.,0.,.6/1.,0.,.6/1.,1.,.6/ *define geometric regions region/top/ le cube and ge cutpl2 / region/bottom/ le cube and le cutpl1 / region/middle/ le cube and gt cutpl1 and lt cutpl2 / * define material regions mregion/top/ le cube and gt cutpl2 / mregion/bottom/ le cube and lt cutpl1 / mregion/middle/ le cube and gt cutpl1 and lt cutpl2 / rz/xyz/5,5,3/0.,0.,.4/1.,1.,.6/1,1,1/ rzbrick/xyz/5,5,3/1,0,0/connect/ * add meshes addmesh/glue/hybrid/3dmesh/hexgrid/ * unit cube surface/cube/reflect/box/0.0,0.0,0.0/1.0,1.0,1.0/ * define z=.4,.6 plane as interface surface/cutpl1/intrface/plane/0.,0.,.4/1.,0.,.4/1.,1.,.4/ surface/cutpl2/intrface/plane/0.,0.,.6/1.,0.,.6/1.,1.,.6/ *define geometric regions region/top/ le cube and ge cutpl2 / region/bottom/ le cube and le cutpl1 / region/middle/ le cube and gt cutpl1 and lt cutpl2 / * define material regions mregion/top/ le cube and gt cutpl2 / mregion/bottom/ le cube and lt cutpl1 / mregion/middle/ le cube and gt cutpl1 and lt cutpl2 / * set element (tetrahedral) type filter/1,0,0/ geniee zq/imt/1,0,0/0/ zq/itp/1,0,0/0/ setpts settets/geometry * dump mesh to some output form dump/gmv/gmv.hybrid/hybrid * terminate processing finish [Return to LaGriT Home Page](index.md)",
    "tags": "",
    "url": "/pages/hybrid1.html"
  },{
    "title": "",
    "text": "* create a 3-D hexahedral mesh object and name it 3dmesh cmo/create/3dmesh///hex/ * create a cylinder inside a cylinder * inner cylinder will be replaced by tet grid surface/cyl1/reflect/cylinder/0.0,0.0,0.0/0.0,0.0,10.0/5.0/ surface/top/reflect/plane/0.,0.,10./1.,0.,10./1.,1.,10. / surface/bot/reflect/plane/0.,0.,0./1.,0.,0./1.,1.,0. / surface/cyl2/intrface/cylinder/0.0,0.0,1.0/0.0,0.0,9.0/4.0/ surface/cutpl1/intrface/plane/0.,0.,1./1.,0.,1./1.,1.,1./ surface/cutpl2/intrface/plane/0.,0.,9./1.,0.,9./1.,1.,9./ *define geometric regions region/inner/ lt cyl2 and lt cutpl2 and gt cutpl1 / region/outer/ le cyl1 and le top and ge bot and & ( ge cyl2 or ge cutpl2 or le cutpl1 ) * define material regions mregion/inner/ lt cyl2 and lt cutpl2 and gt cutpl1 / mregion/outer/ le cyl1 and le top and ge bot and & ( gt cyl2 or gt cutpl2 or lt cutpl1 ) * distribute points in cylindrical arrangement rz/rtz/11,61,21/0.,0.,0./5.,360.,10./1,1,1/ * assign material colors to the points * identify points that are on material interfaces * identify constrained points * connect hex mesh rzbrick/xyz/61,11,21/1,0,0/connect/ zq/itp/1,0,0/0 zq/imt/1,0,0/0 zq/icr/1,0,0/0 setpts dump/x3d/x3d1 settets zq/itp/100,130,1 dump/gmv/gmv1 * remove inner region rmmat/inner rmpoint/compress geniee *zq/xic/1,0,0 *zq/itp/1,0,0 dump/gmv/gmv2 * grid tet part cmo/create/tetgrid///tet rz/rtz/9,61,17/0.,0.,1./1.,360.,9./1,1,1/ filter/1,0,0/ search zq/imt/1,0,0/1 zq/xic/1,0,0 zq/itp/1,0,0 * add meshes dump/x3d/x3d1 addmesh/pyramid/hybrid/tetgrid/3dmesh/ surface/cyl1/reflect/cylinder/0.0,0.0,0.0/0.0,0.0,6.0/2.0/ surface/top/reflect/plane/0.,0.,6./1.,0.,6./1.,1.,6. / surface/bot/reflect/plane/0.,0.,0./1.,0.,0./1.,1.,0. / surface/cyl2/intrface/cylinder/0.0,0.0,2.0/0.0,0.0,4.0/1.0/ surface/cutpl1/intrface/plane/0.,0.,2./1.,0.,2./1.,1.,2./ surface/cutpl2/intrface/plane/0.,0.,4./1.,0.,4./1.,1.,4./ *define geometric regions region/inner/ le cyl2 and le cutpl2 and ge cutpl1 / region/outer/ le cyl1 and le top and ge bot and & ( gt cyl2 or gt cutpl2 or lt cutpl1 ) * define material regions mregion/inner/ lt cyl2 and lt cutpl2 and gt cutpl1 / mregion/outer/ le cyl1 and le top and ge bot and & ( gt cyl2 or gt cutpl2 or lt cutpl1 ) filter/1,0,0/ dump/x3d/x3d2 geniee zq/imt/1,0,0/0/ zq/itp/1,0,0/0/ zq/icr/1,0,0/0/ setpts settets * dump mesh to some output form dump/gmv/gmv.hybrid/hybrid * terminate processing finish [Return to LaGriT Home Page](index.md)",
    "tags": "",
    "url": "/pages/hybrid2.html"
  },{
    "title": "X3dsetup Requirements",
    "text": "X3dsetup Requirements --------------------- To run lasetup, you will need: - the proper version of lasetup. Irix5.3, Irix6.x, Sunultracreator, and IBM versions are available. - a Unix workstation. You should have no problem with Silicon Graphics (SGI) machines. Sun Ultra Creator systems also work. IBM workstations have been problematical in the past. You must have the 3D option. It may or may not work, depending on things that I don't understand. I haven't made a DEC version, but it should be possible. HP should work someday when HP starts providing OpenGL. - the OpenGL libraries and associated include files, to wit: - libGL.a, libGLU.a, libGLw.a -or- libGL.so, libGLU.so, libGLw.so - the Motif library libXm.a - the X Window System libraries, libX11.a and libXt.a You will also need a 24-bit TrueColor visual, preferably double buffered, available on your machine. You can find out what is available by running xdpyinfo. Also the X server must be running the GLX extension. Extensions are listed near the top of the output of xdpyinfo. On some systems, you may need to modify your environmental variable LD\\_LIBRARY\\_PATH so that all of the libraries can be found at runtime. To *compile * the code, you will need the above stuff plus lasetup source. You may have to change the paths in the makefile, depending on where your libraries are located. Similarly, you may have to change the makefiles in each of the lasetup subdirectories. You will also need the include files: - gl.h, glu.h, glx,h, in /usr/include/GL - GLwMDrawA.h, in /usr/include/X11/GLw (On Suns these may be in /usr/openwin/include/....). * * *Or * * * If you don't have OpenGL and are the adventurous type, you can get and compile [Brian Paul's Mesa library](http://www.ssec.wisc.edu/~billh/bp/Mesa30.html), to which you can link rather than to OpenGL. Since Mesa doesn't support hardware even if it's on your machine, the code will run slowly. But this does eliminate the OpenGL requirement. There is a macro MESALIBS in the makefile that you will have to modify, but it might help you get started. I have compiled lasetup with Mesa, so I know it can be done. :)",
    "tags": "",
    "url": "/pages/lasetup_require.html"
  },{
    "title": "MSTKLA - Mesh ToolKit interface to LaGriT",
    "text": "# MSTKLA - Mesh ToolKit interface to LaGriT Note these pages have not been updated to newer versions of MSTKLA (LA-UR-99-6711) ------------------------------------------------------------------------ Questions, Comments, Suggestions? Contact: Rao V Garimella, Email: rao@lanl.gov ------------------------------------------------------------------------ **MSTKLA** is a C interface to the **LaGriT** code which is designed to make it easier to use the LaGriT functionality. It tries to hide some of the internals of LaGriT and provides an API that works in a somewhat object oriented way. It does not attempt to provide or enhance interactive commands that exist in LaGriT. Rather, it is designed more with writing automated mesh generation procedures and complex meshing algorithms within LaGriT in mind. MSTKLA has one or more *mesh objects*, which have mesh **regions**, mesh **faces,** mesh **edges** and mesh **vertices** (nodes). *Mesh faces and mesh edges are objects defined on the fly in terms of their vertices.* One can ask these objects various questions or modify their info through operators. In addition there is a **geometric model** and **geometric model objects** (In the spirit of consistent naming, I am labeling this set of functions **GMTKLA**). Since LaGriT does not really store curves or points in the database, these are also faked on the fly. The mesh and model entities are related through the concept of **CLASSIFICATION**. \"A mesh entity is classified on a model entity if it forms all or part of that model entity's discretization (grid) but not its boundary's\". So mesh regions can be classified only on a model region.  Mesh faces can be classified on a model face or a model region. Mesh vertices can be classified on a model vertex, model edge, model face or model region. Classification information can be queried from MSTKLA if it is available. In particular, in LaGriT, only **external faces** (what LaGriT calls **\"reflective\" boundaries**) and **internal faces or interfaces** created with the option **\"intrcons\"** in the **surface** command have the information required to retrieve full classification information. Full classification information includes the **type** of geometric model entity the mesh entity is classified on, the **ID of that geometric model entity** and **a pointer to the geometric model object** (which can be further queried). Interface surfaces created with the surface command option \"**intrface**\" **do not** have the necessary information to relate the mesh and the model fully. (In the future, I may put in code to take the \"intrface\" type surfaces and add the info needed to find out the classification information). Note that the current interface works for querying an existing mesh but not **yet** for modifying it. The operators for this are on the way. Operators for calling the actual meshing operators (connect, refine, smooth, etc) will also be added in the near future. Finally, the basic interface (low level query and modification operators) are expected to retain the same format regardless of what the underlying database is (LaGriT or something else). So, for example, I am hoping that an operator to retrieve the nodes of an element will retain the same form shown below regardless of how it functions internally: void MR_Vertices(PMeshObj mesh, PMeshRegn reg, int nv, PMeshVert rverts); I will try hard to maintain this API constant but cannot absolutely guarantee it. parent-child Also see [Parent-Child Node](/pages/mstkla/parent-child.html) typedefs[TYPEDEFS](/pages/mstkla/prelim.html) ## MSTKLA_Init MSTKLA Interface Operators **MESH INITIALIZATION:** void MSTKLA_Init(void); Initialize the mesh toolkit. **MESH OPERATORS:** MESH OBJECT: [MESH OBJECT](/pages/mstkla/Mesh.html) MESH REGION:[MESH REGION](/pages/mstkla/MeshRegion.html) MESH FACE:[MESH FACE](/pages/mstkla/MeshFace.html) MESH EDGE:[MESH EDGE](/pages/mstkla/MeshEdge.html) MESH VERTEX:[MESH VERTEX](/pages/mstkla/MeshVertex.html) GENERIC MESH REGION QUERIES:[GENERIC MESH REGION QUERIES](/pages/mstkla/GenRegion.html) **GMTKLA_Init GEOMETRIC MODEL INITIALIZATION:** void GMTKLA_Init(void); Initialize the geometric model interface. **MODEL OPERATORS:** GEOMETRIC MODEL:[GEOMETRIC MODEL](/pages/mstkla/Geom.html) MODEL ENTITY:[MODEL ENTITY](/pages/mstkla/GeomEntity.html) MODEL REGION:[MODEL REGION](/pages/mstkla/GeomRegion.html) MODEL FACE:[MODEL FACE](/pages/mstkla/GeomFace.html) MODEL EDGE:[MODEL EDGE](/pages/mstkla/GeomEdge.html) MODEL VERTEX: [MODEL VERTEX](/pages/mstkla/GeomVertex.html) *Not implemented fully* UTILITIES: [UTILITIES:](/pages/mstkla/utilities.html) EXAMPLE: [EXAMPLE OF PROGRAMMING WITH MSTKLA](/pages/mstkla/example.html)** EXECUTABLE: [LIBRARIES, INCLUDE FILES AND CREATING AN EXECUTABLE](/pages/mstkla/linking.html)",
    "tags": "",
    "url": "/pages/mstkla/mstkla.html"
  },{
    "title": "",
    "text": "--- title: picture index tags: review, images, unlinked --- # Still Images ------------ - [Mesh for scanning microscopy simulation](/pages/denise.html) - [Tetrahedral LaGriT mesh for Microstructure Evolution](/pages/tinkas.html) - [Finite Element Calculation](/pages/finite.html) - [Laplacian smoothing](/pages/tee.html) - [Biological Structures]( Gif Animations -------------- - [Grain growth in large cube (5MB)](movies/99.gif\"> - [Grain growth with temperature-dependent mobility (5MB)](tmap-a.gif\"> - [Grain growth in line to bamboo (1.5MB)](tmap.gif\"> #### GMMFE (Graph Massage w/ Moving Finite Elements) - Shallow Water Equations - [Evolving Adaptive Grid (4MB)](vertgridshort_swe_10-3.gif\"> - [Perspective view of water height with grid (2MB)](sidegridshort_swe_10-3.gif\"> - [Alternate view of water height (3MB)](backsideshort_swe_10-3.gif\"> - Rotating Hump - Evolving Adaptive Grid ([6MB](vertgrid_rotation_10-4.gif\"> [0.6 MB](vertgridshort_rotation_10-4.gif\">) - Perspective view ( [3MB](side_rotation_10-4.gif\"> [0.3 MB](sideshort_rotation_10-4.gif\"> ) #### Graph Massage for the shear flow (x,y)'=(-xy,0) - Evolving Triangular Grid with Graph Massage ( [6MB](gmtri_shear.gif\"> [0.6 MB](gmtrishort_shear.gif\"> ) - Evolving Quadrilateral Grid with Graph Massage ( [3MB](gmquad_shear.gif\"> [0.3 MB](gmquadshort_shear.gif\"> ) - Evolving Quadrilateral Grid without Graph Massage ( [3MB](nogmquad_shear.gif\"> [0.3 MB](nogmquadshort_shear.gif\"> ) #### Dendrite formation - Dendrite surface - with grid [adaptive refine used to maintain grid (10MB)](dendrite.gif\"> - without grid [temperature field displayed (10MB)](dendriteng.gif\">",
    "tags": "",
    "url": "/pages/pictures.html"
  },{
    "title": "LaGriT Related Publications",
    "text": "# LaGriT Related Publications ### Year 2017: Sentis, M.L., Gable, C.W., [Coupling LaGrit unstructured mesh generation and model setup with TOUGH2 flow and transport: A case study](doi.org/10.1016/j.cageo.2017.06.012), Computers & Geosciences, 2017, DOI:10.1016/j.cageo.2017.06.012. ### Year 2014: Hyman, J.D., Gable, C.W., Painter, S.L Makedonska, N., [Conforming Delaunay Triangulation of Stochastically Generated Three Dimensional Discrete Fracture Networks : A Feature Rejection Algorithm for Meshing Strategy](http://epubs.siam.org/doi/abs/10.1137/130942541), SIAM J of Sci Computing, V 36, No. 4, pp. A1871-A14, DOI:10.1137/130942541, 2014. Pepin, J, Person, M, Phillips, F, Kelley, S, Timmons, S, Owens, L, Witcher, J, Gable, C, [Deep fluid circulation within crystalline basement rocks andthe role of hydrologic windows in the formation of the Truth or Con- sequences, New Mexico low-temperature geothermal system](http://onlinelibrary.wiley.com/doi/10.1111/gfl.12111/abstract), Geofluids, Oct. 2014, DOI:10.1111/gfl.12111 Harp, DH, Pawar, R, Gable, CW, Numerical modeling of cemented wellbore leakage from storage reservoirs with secondary capture due to thief zones, Greenhouse Gas Technology 12, Energy Procedia, Elsevier, 2014. Siegel, J, Person, M, Dugan, B, Cohen, D, Lizarralde, D, Gable, C,[Influence of Late Pleistocene Glaciations on the Hydrogeology of the Continental Shelf Offshore Massachusetts](http://onlinelibrary.wiley.com/doi/10.1002/2014GC005569/abstract), USA, Geochemistry, Geophysics, Geosystems, 2014, DOI:10.1002/2014GC005569. ### Year 2013: Zhang,Y, Person, M, Rupp, J, Ellett, K, Celia, MA, Gable, CW, Bowen, B, Evans, J, Bandilla, K, Mozley, P, Dewers, T, Elliot, T, Hydrogeologic Controls on Induced Seismicity in Crystalline Basement Rocks Due to Fluid Injection into Basal Reservoirs, Groundwater, Vol 51, Iss. 4, 525538, July/August 2013, DOI: 10.1111/gwat.71. ### Year 2012: Painter, S.L., Gable, C.W., Kelkar, S, [Pathline Tracing on Fully Unstructured Control Volume Grids](http://link.springer.com/article/10.1007/s10596-012-9307-1), Computational Geosciences, Vol 16, iss. 4, 1125-1134, 2012, DOI:10.1007/s10596-012-9307-1. Person, M, Hofstra, A, Sweetkind, D, Stone, W, Cohen, D, Gable, C, Banerjee, A, Analytical and numerical models of hydrothermal fluid flow at fault intersections, Geofluids, Vol 12, iss. 4, 312-326, 2012, DOI:10.1111/gfl.02. Person, M, Butler, D, Gable, CW, Villamil, T, Wavrek, D, Schelling, D, Hydrodynamic stagnation zones: A new play concept for the Llanos Basin, Colombia, AAPG BULLETIN Vol.96, iss.1, 23-41, 2012. ### Year 2011: Blessent, D, Therrien, R, Gable, C.W.,[Large-scale numerical simulation of groundwater flow and solute transport in discretely-fractured crystalline bedrock](http://www.sciencedirect.com/science/article/pii/S03091708110018), Advances in Water Resources, 34, 1539-1552, 2011. Banerjee, A, Person, M, Hofstra, A, Sweetkind, D, Cohen, D, Sabin, A, Unruh, J, Zyvoloski, G, Gable C.W., Crossey, L, Karlstrom, K, [Deep permeable fault-controlled helium transport and limited mantle flux in two extensional geothermal systems in the Great Basin, United States](http://geology.gsapubs.org/content/39/3/195) GEOLOGY (MAR 2011) Vol.39, iss.3, p.195-198. Zhang, Y, Liu, B, Gable, C.W., [Homogenization of Hydraulic Conductivity for Hierarchical Sedimentary Deposits at Multiple Scales Transport in Porous Media,](http://link.springer.com/article/10.1007/s11242-010-11-8) (2011) Vol.87, iss.3, p.717-737. ### Year 2010: Zhang, Y., Gable, C.W., Sheets, B., [Equivalent hydraulic conductivity of three-dimensional heterogeneous porous media: An upscaling study based on an experimental stratigraphy Journal of Hydrology](http://www.sciencedirect.com/science/article/pii/S0022169410002726) (2010) Vol.388, iss.3-4, p.304-320. Person, M, Banerjee, A, Rupp, J, Medina, C, Lichtner, P, Gable, C, Pawar, R, Celia, M, McIntosh, J, Bense, V, [Assessment of basin-scale hydrologic impacts of CO2 sequestration, Illinois basin](http://www.sciencedirect.com/science/article/pii/S10583610000605), INTERNATIONAL JOURNAL OF GREENHOUSE GAS CONTROL (SEP 2010) Vol.4, iss.5, p.840-854. [Stepwise inversion of a groundwater flow model with multi-scale observation data.](http://link.springer.com/article/10.1007/s10040-009-0543-y) Dai, ZX; Keating, E; Gable, C, Levitt, D, Heikoop, J, Simmons, A, HYDROGEOLOGY JOURNAL Volume: 18 Issue: 3 Pages: 607-624 Published: 2010 ([PDF](http://www.ees.lanl.gov/staff/gable/pdf_files/2010_HJ_Dai_Keating_Gable_Levitt_Heikoop_Simmons.pdf\")) [Origin and Extent of Fresh Paleowaters on the Atlantic Continental Shelf, USA](http://onlinelibrary.wiley.com/doi/10.1111/j.17-6584.2009.00627.x/full). Cohen, D; Person, M; Wang, P, et al. GROUND WATER Volume: 48 Issue: 1 Pages: 143-158 Published: 2010 ([PDF](http://www.ees.lanl.gov/staff/gable/pdf_files/2010_groundwater_cohen_reprint.pdf\")) ### Year 2009: Pawar, R.J., Watson, T.L., Gable, C.W., [Numerical Simulation of CO2 Leakage through Abandoned Wells: Model for an Abandoned Site with Observed Gas Migration in Alberta, Canada,](http://www.sciencedirect.com/science/article/pii/S1876610209008017) Energy Procedia (2009) Vol.1, iss.1, p.3625-3632. ([PDF](http://www.ees.lanl.gov/staff/gable/pdf_files/2009_GGCT_CO2_jun26b.pdf\")) Zhang, Y , Gable, CW, Zyvoloski, GA, Walter, LM, Hydrogeochemistry and gas compositions of the Uinta Basin: A regional-scale overview, AAPG BULLETIN (AUG 2009) Vol.93, iss.8, p.1087-1118. Blessent, D; Therrien, R; MacQuarrie, K, [Coupling geological and numerical models to simulate groundwater flow and contaminant transport in fractured media](assets/images/2009_computers_and_geosciences_v35_iss9_blessent.pdf\"). COMPUTERS & GEOSCIENCES 35:9, 18-1906, 2009 Stauffer, PH ; Vrugt, JA ; Turin, HJ ; Gable, CW ; Soll, WE, [Untangling Diffusion from Advection in Unsaturated Porous Media: Experimental Data, Modeling, and Parameter Uncertainty](/assets/images/2009_VZJ_stauffer_vrugt_turin_gable_soll.pdf\"). VADOSE ZONE JOURNAL (MAY 2009) Vol.8, iss.2, p.510-522 Kuprat, AP; Einstein, DR [An anisotropic scale-invariant unstructured mesh generator suitable for volumetric imaging data](https://lanl.github.io/LaGriT/assets/images/0906017--journals--00219991--v228i0003--619_aasumgsfvid.pdf). JOURNAL OF COMPUTATIONAL PHYSICS (FEB 20 2009) Vol.228, iss.3, p.619-640 ### Year 2008: Plumes anchored by a high viscosity lower mantle in a 3D mantle convection model featuring dynamically evolving plates Lowman, J.P.; Gait, A.D.; Gable, C.W., Kukreja, H, Geophysical Research Letters Pages: L19309 (5 pp.) Published: 10 2008 9 Oct. 2008 ([PDF](http://www.ees.lanl.gov/staff/gable/pdf_files/2008_grl_lowman_gait_gable_kukreja.pdf\")). Time dependence in 3-D mantle convection models featuring evolving plates: effect of lower mantle viscosity Gait, A.D.; Lowman, J.P.; Gable, C.W. Journal of Geophysical Research - Part B - Solid Earth Pages: B08409 (16 pp.) Published: 08 2008 Aug. 2008 ([PDF](http://www.ees.lanl.gov/staff/gable/pdf_files/2008_jgr_gait_lowman_gable_2007JB005538.pdf\")) Zhang, Y ; Gable, CW [Two-scale modeling of solute transport in an experimental stratigraphy](/assets/images/2008_j_hydrology_zhang_gable.pdf), JOURNAL OF HYDROLOGY (JAN 15 2008) Vol.348, iss.3-4, p.395-411 ### Year 2007: Zhang, Y ; Person, M ; Gable, CW, [Representative hydraulic conductivity of hydrogeologic units: Insights from an experimental stratigraphy](https://oppie.lanl.gov/oppie/service?url_ver=Z39.88-2004&rft_id=info:lanl-repo/oppie&svc_val_fmt=http://oppie.lanl.gov/openurl/oppie.html&svc_id=info:lanl-repo/svc/oppie/full-rec&svc.oparam1=info:lanl-repo/isi/000247151900006&svc.oparam2=info:lanl-repo/svc/getDIDL&svc.oparam3=%28%22gable%20cw%22%29%20AND%20pubDate:2007&svc.oparam4=0&svc.oparam5=1&svc.oparam6=score%20desc&svc.oparam7=LANL&svc.oparam8=&svc.oparam9=), JOURNAL OF HYDROLOGY (JUN 10 2007) Vol.339, iss.1-2, p.65-78 ### Year 2006: Zyvoloski, G.A., Vesselinov, V.V., [An investigation of numerical grid effects in automated calibration](https://www.lanl.gov/orgs/ees/staff/monty/papers/Zyvoloski%20&%20Vesselinov%202006%20grid%20GW.pdf), Ground Water, (Special issue: Modflow and More 2003: Understanding through Modeling), v.44, no.6, p.814-825, 2006. ### Year 2005: Bower, KM; Gable, CW; Zyvoloski, GA \"[Grid resolution study of ground water flow and transport](assets/images/2005_groundwater_bower_gable_zyvoloski.pdf)\". Ground Water; 2005; v.43, no.1, p.122-132 Robinson, BA; Cole, G; Carey, JW; Witkowski, M; Gable, CW; Lu, ZM; Gray, R \"[A vadose zone flow and transport model for Los Alamos Canyon, Los Alamos, New Mexico](assets/images/2005_vadose_zone_j_robinson_cole_carey_witkowski_gable_lu_gray.pdf)\". VADOSE ZONE JOURNAL; AUG 2005; v.4, no.3, p.729-743 Gruber, J; George, DC; Kuprat, AP; Rohrer, GS; Rollett, AD \"[Effect of anisotropic grain boundary properties on grain boundary plane distributions during grain growth](assets/images/2005_scripta_materialia_gruber_george_kuprat_rohrer_rollett.pdf)\". Scripta Materialia; Aug. 2005; vol.53, no.3, p.351-5 Zhang, Ye; Person, Mark; Paola, Chris; Gable, Carl W.; Wen, Xian-Huan; Davis, J. Matthew \"[Geostatistical analysis of an experimental stratigraphy](assets/images/2005_wrr_zhang_person_paola_gable_wen_davis.pdf)\". Water Resources Research; November 2005; v.41, no.11, p.1-20 ### Year 2003: Demirel, Melik; Kuprat, Andrew; George, Denise; Rollett, Anthony, \"[Bridging Simulations and Experiments in Microstructure Evolution](assets/images/PRL.pdf)\", PRL, vol90, 016106. Kuprat, George, Straub, Demirel,\"[Modeling Microstructure Evolution in Three Dimensions with Grain3D and LaGriT](assets/images/2003_computational_materials_sci_kuprat_george_straub_demirel.pdf)\", Computational Materials Science, 28 (2003) 199-208. Viswanathan, HS; Robinson, BA; Gable, CW; Carey, JW \"[A geostatistical modeling study of the effect of heterogeneity on radionuclide transport in the unsaturated zone, Yucca Mountain](assets/images/2003_jch_viswanathan_robinson_gable_carey.pdf)\", Journal of Contaminant Hydrology; April/May 2003; v.62-63, p.319-336 Tseng, PH; Soll, WE; Gable, CW; Turin, HJ; Bussod, GY \"[Modeling unsaturated flow and transport processes at the Busted Butte Field Test Site, Nevada](lagrit.lanl.gov/assets/images/2003_jch_tseng_soll_gable_turin_bussod.pdf)\", Journal of Contaminant Hydrology; April/May 2003; v.62-63, p.303-318 ### Year 2002: Demirel, Melik; Kuprat, Andrew; George, Denise; Straub, Galen; Rollett, Anthony, \"[Linking Experimental Characteriztion and Computational Modeling of Grain Growh in Al-Foil](assets/images/463433.pdf)\", Interface Science, Vol10, No2-3, pp 137-142, July 2002. ### Year 2001: Fisher, AT; Giambalvo, E; Sclater, J; Kastner, M; Ransom, B; Weinstein, Y; Lonsdale, P \"[Heat flow, sediment and pore fluid chemistry, and hydrothermal circulation on the east flank of Alarcon Ridge, Gulf of California](assets/images/2001_epsl_fisher_giambalvo_sclater_kastner_ransom_weinstein_lonsdale.pdf)\", EARTH AND PLANETARY SCIENCE LETTERS; JUN 15 2001; v.188, no.3-4, p.521-534 Murphy, M; Mount, DM; Gable, CW \"[A point-placement strategy for conforming Delaunay tetrahedralization](assets/images/2000_ijcga_murphy_mount_gable.pdf)\", International Journal of Computational Geometry & Applications; Dec. 2001; vol.11, no.6, p.669-82 Kuprat, Andrew; Khamayseh, Ahmed; George, Denise; Larkey, Levi, \"[Volume Conserving Smoothing for Piecewise Linear Curves, Surfaces, and Triple Lines](assets/images/volume_conserving_smoothing.pdf)\", Journal of comptational Physics, Vol 172, pp99-118 (2001). ### Year 2000: Kuprat, Andrew, \"[Inspecting and Repairing Physical Topology in a Moving Grid Grain Growth Simulation](assets/images/correctedlaur2000.pdf)\", LA-UR-00-34, July 2000. Kuprat, Andrew, \"[Modeling Microstructure Evolution using Gradient-Weighted Moving Finite Elements](assets/images/siam222.pdf)\", SIAM J. Sci. Comput., Vol22, No. 2,pp. 535-560, July 2000. Kuprat, Andrew; Khamayseh, Ahmed, George Denise; Larkey, Levi \"[Volume Conserving Smoothing for Piecewise Linear Curves, Surfaces and Triple Lines](assets/images/volume_kuprat.pdf)\", LA-UR-00-5004, October 2000. Michael Murphy, David M. Mount, Carl Gable  \"[A Point-Placement Strategy for Conforming Delaunay Tetahedralization](assets/images/conformingDT.pdf)\", LA-UR 99-3868. 11th Annual SIAM-ACM Symposium on Discrete Algorithms (SODA 2000) January, 2000 San Francisco. Galen K. Straub, Denise C. George, Andrew P. Kuprat \"[Materials Microstructural Evolution in 2D Surface Front-Tracking Computer Simulations](assets/images/strgeorkup.pdf)\", LA-UR-00-1. Theoretical Division  Self Assesment Special Feature, April 2000. Denise C. George, Andrew P. Kuprat \"[Optimizing 3D Tetrahedral Grids](assets/images/2pager-massage-20000.pdf)\", LA-UR-00-1.  Theoretical Division  Self Assesment Special Feature, April 2000. Gable, C.W., \"Integrated Geological Interpretation for Computational Modeling, Vadose Zone Science and Technology Solutions\", Brian B. Looney, Ronald W. Falta, Battelle Press, 2000. (PDF not available) **Year 1999:** Denise George, Neil Carlson, J. Tinka Gammel, Andrew Kuprat \"[3D Modelling of Metallic Grain Growth](assets/images/puertorico99.pdf)\", Conference on Modeling and Simulation of Microsystems, San Juan, Puerto Rico, April 1999. Gammel, J. Tinka; Kuprat, A; Carlson, N.N.; George D.C, \"Modeling Metallic Microstructure: OrientationDependence\",to be presented at the APS meeting, March 1999. **Year 1998:** Kuprat, Andrew and George, Denise, \"[Maintaining Tetrahedral Mesh Quality in Response to Time-dependent Topological and Geometrical Deformation](assets/images/london98_pn.pdf), LA-UR--5187, Proceedings of the 6th International Conference on  Numerical Grid Generation in Computational Field Simulations, M. Cross  (ed.), International Society of Grid Generation  (ISBN 0-9651627), pp. 5-598, May 1998. Michael Murphy, Carl W. Gable, \"[Strategies for Nonobtuse Boundary Delaunay Triangulations](http://citeseer.ist.psu.edu/321240.html)\", Transactions, 7th International Meshing Roundtable '98, Dearborn Michigan, 309-320, 1998, LAUR-98-3949. Kuprat, Andrew and Khamayseh, Ahmed, \"[Non-Parametric Volume Conserving Smoothin](../assets/images/volsmooth.pdf)\", LA-UR-98-3381 (1998). Khamayseh, A., and Kuprat, A., \"Surface Grid Generation Systems,\" LA-UR--87, CRC Handbook of Grid Generation, ed. Joe Thompson, CRC Press, (ISBN 0849326877), (1998). Khamayseh, A., Kuprat, A., and W. Mastin, \"Boundary Orthogonality in Elliptic Grid Generation\", LA-UR--3827,CRC Handbook of Grid Generation, ed. Gammel, J. Tinka and Kuprat, Andrew, \"Modeling Metallic Microstructure Using Moving Finite Elements\", presented at the Computational and Theory Symposium Pacific Coast Meeting of the American Ceramic Society, IRvine, CA, Oct. 21-24, 1998. ### Year 1997: Kuprat, Andrew, Denise George, Eldon Linnebur, Harold Trease , R. Kent Smith,  \"[Moving Adaptive Unstructured 3-D Meshes in Semiconductor Process Modelling Applications](assets/images/BORON.pdf)\", LA-UR-95-4128, VLSI Design, Vol. 6(1-4), (1998), pp373-378. George, Denise, \"[Unstructured Toolbox for Modeling and Simulation\"](../assets/images/nasa.pdf)\", LA-UR--3052, presented at the 19 Workshop on Computational Electronics and Nanoelectronics, Urbana, Illinois, October 20-22, 19. George, Denise \"[Unstructured 3D Grid Toolbox for Modeling and Simulation](assets/images/nasa.pdf)\", LA-UR--3052, presented at the 19  Workshop on Computational Electronics and Nanoelectronics, Urbana, Illinois, October 20-22, 19 ### Year 1996: Carl W. Gable, Harold Trease and Terry Cherry, \"Automated Grid Generation From Models of Complex Geologic Structure and Stratigraphy,\" Santa Barbara: National Center for Geographic Information and Analysis, proceedings paper LA-UR-96-1083, 1996. Carl W. Gable, Harold Trease and Terry Cherry, \"[Geological Applications of Automatic Grid Generation Tools for Finite Elements Applied to Porous Flow Modeling](assets/images/num_grid.pdf),\" in Numerical Grid Generation in Computational Fluid Dynamics and Related Fields, edited by B. K. Soni, J. F. Thompson, H. Hausser and P. R. Eiseman, Engineering Research Center, Mississippi State Univ. Press, 1996. Khamayseh, Ahmed and Kuprat, A, \"[Anisotropic Smoothing and Solution Adaption for Unstructured Grids](assets/images/ahmandrew1.pdf)\", LA-UR-95-2205, International Journal for Numerical Methods in Engineering, Vol. 39, pp. 3163-3174 (1996). Garimella, R.V, C.W. Gable, \"Interfacing Mesh Generators and Geometric Modelers in Geological Modeling\" - Progress Report for LANL/ER Program, LA-UR-00-2956. Kuprat, Andrew; Cartwright David; Gammel J. Tinka; George Denise; Kendrick Brian; Kilcrease David; Trease Harold; Walker, Robert, \"[X3D Moving Grid Methods for Semiconductor Applications](assets/images/notred.pdf)\", LA-UR--21. Kuprat, Andrew,  \"[Adaptive Smoothing Techniques for 3D Unstructured Meshes](assets/images/MSU96.pdf)\",  LA-UR-96-1 (1996). Terry Cherry, C. W. Gable and Harold Trease, \"[3-Dimensional Wells and Tunnels for Finite Element Grids](assets/images/NGG96.pdf)\" in Numerical Grid Generation in Computational Fluid Dynamics and Related Fields, edited by B. K. Soni, J. F. Thompson, H. Hausser and P. R. Eiseman, Engineering Research Center, Mississippi State Univ. Press, 1996. ### Year 1995: C. W. Gable, Terry Cherry, Harold Trease, George A. Zyvoloski, \"[Geomesh Grid Generation](https://hwbdocuments.env.nm.gov/Los%20Alamos%20National%20Labs/References/9672.PDF)\", Yucca Mountain Site Characterization Project Milestone 4075: Letter Report, LA-UR-95-4143 (1995) Khamayseh, Ahmed; Ortega, Frank; Trease, Harold, \"Ray Tracing for Point Distribution in Unstructured Grid Generation\", LA-UR-95-4470 (1995). Khamayseh, Ahmed; Ortega, Frank; Kuprat, Andrew, \"A Robust Point Location Algorithm for General Polyhedra\", LA-UR-95-4465 (1995) ### Year 1994: Zyvoloski, G. and C. W. Gable, \"Site Scale Modeling of Radionuclide Transport At Yucca Mountain, NV: Grid Generation and Reactive Tracers,\" Los Alamos National Laboratory, LA-UR-94-1041, 1994. (PDF is not available)",
    "tags": "",
    "url": "/pages/publications.html"
  },{
    "title": "LaGriT Release Notes V3.001 August 2011",
    "text": "# LaGriT Release Notes V3.001 August 2011 Major changes incoporating work from Andrew Kuprat (64bit work) and summer student Adam Cozzette to add more capability. Changes to make 64bit code more consistent and easier to modify for various platforms. The code for stack routines are combined into stack\\_options.f from temptam.f and read_trilayers.f. The beads algorithm and routines are now all in their own file beads_ona_ring.f LaGriT assumes that the size of an integer is the same size as a pointer. Use the preprocessor and configure settings to select the integer type so that it matches the size of a pointer. ``` #if SIZEOF_INT == SIZEOF_VOIDP #define int_ptrsize int #elif SIZEOF_LONG == SIZEOF_VOIDP #define int_ptrsize long Makefile changes for 64 bit compile: -fcray-pointer Enables the Cray pointer extension, which provides a C-like pointer -falign-commons (will try to reorder commons so this is not needed) ``` By default, gfortran enforces proper alignment of all variables in a COMMON block by padding them as needed. On certain platforms this is mandatory, on others it increases performance. If a COMMON block is not declared with consistent data types everywhere, this padding can cause trouble, and -fno-align-commons can be used to disable automatic alignment. The same form of this option should be used for all files that share a COMMON block. To avoid potential alignment issues in COMMON blocks, it is recommended to order objects from largests to smallest. This includes Work from Andrew Kuprat and summer student Adam Cozzette. ### Enhancements: - **filterkd** - new filter command uses kd-tree for filter. Uses reverseform.f - *anothermatbld3d.c* added several functions for computing the hybrid point of a control volume: tetisOnBoundary, intersectSegmentWithFace, getHybridPoint - added helper functions for computing dot products and distances. - changed the areaOf3dTriangle function to compute a vector area rather than a scalar. - a change computes a unit vector in the direction of an edge between two points in the tetrahedral mesh. We dot this with the facet of the Voronoi cell in order to consider just the component of the area that is in the direction of the edge. - changed the parameter list for initialize3ddiffusionmat_ so that the function also takes arrays for jtet, pmbndry, ifhybrid, and hybridfactor. ifhybrid indicates whether to use hybrid volumes and hybrid_factor is an attribute that the function will fill in order to indicate the extent to which each cell is hybridized - added function prototypes so that gcc can perform type checking - added #ifdef to match format string to size of integers being used - *anothermatbld3d_wrapper.f* changed subroutine call to add hybrid_factor ``` subroutine anothermatbld3d_wrapper - x (ifile,io_type,num_area_coef,ifcompress) + x (ifile,io_type,num_area_coef,ifcompress, ifhybrid) ``` - Added support for quad metrics in quality / quad - Added support for writing element sets out to a file based on pset logic so that eltset will write each element set to a separate file if it is given the -all- option filenames now end with .cellset - intersect added sort line_graph after performing the intersection - **pset** changed pset to verify a point before writing to file. Added the -all- option that writes each pset to seperate files with the new file extension .vertexset - **sort/ line_graph** in file line_graph_sort.cpp. Create the sort keys correctly based on whether it is actually sorting nodes or elements. - *writedump.f* changes to facilitate the *hybrid* option and Rao's new **dump / exo** code. ## These issues were fixed: - fix bug in 2D delaunay connect connect2d_lg.f where the code doubled the coordinates of the first Voronoi point. - fixed a bug where attempting to redefine an element set, the set is now zeroed out and written afresh - *cr_copy.f* fixed an off-by-one error by making an array one element longer in a call to mmgetblk with length + 1 that was causing segfault errors - *geniee.f* changed loop to check condition before starting, this avoids writing to memory is invalid - *pcc_test.f* fixed Warning so it is given once instead of once for every element - **reorder** fixed so that it doesn't rely on the numerical values to determine whether to sort nodes or elements and added messages to indicate possible WARNINGS for reorder - *rotatelo.f* Fixed a bug whereby rotateln would rotate some points in one direction and some points in the opposite direction. - *sparseMatrix.c* removed unused variables in order to get rid of compiler warnings. Added #if for printf to use string according to integer size - *readgmv_binary.f* Changed gmv routines readgmv_binary.f and dumpgmv_hybrid.f so read/write gmv works on 64-bit ------------------------------------------------------------------------ *Changesets tracked in Mercurial/Trac on ancho.lanl.gov/lagrit*",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V3.00.html"
  },{
    "title": "LaGriT Release Notes",
    "text": "LaGriT Release Notes ==================== This page describes version updates for V3.2 and newer. See other pages for older versions. ## LaGriT V3.3 October 2017 - Major changes to comply with ExodusII 7, changed arrays to 8 byte integers instead of 4 - dump/exo no longer writes empty attrib arrays to the ExodusII file - all test directories with ExodusII files updated to new output - all test directories using rmpoint and filter commands updated to new output - lagrit.lanl.gov removed from this repo, use docs/pages instead ------------------------- ## LaGriT V3.203 July 2017 - Major upgrade to LaGriT build and test scripts. - Added install.h and improved documentation for building LaGriT on Linux and Mac machines. - Update ExodusII to 7.01 using git clone ```https://github.com/gsjaardema/seacas.git``` - Removed exodus include files from src directory and use install.sh instead - Convert lagrit.lanl.gov to github Markdown pages at ```https://lanl.github.io/LaGriT``` ### These issues were fixed: - segmentation fault during triangulate - massage command failing to de-refine and no error is reported - ExodusII output for 2D Planar incorrectly written as 3 Dimensions - second call to addmesh/excavate command causing memory error or segmentation fault - output adjusted to make room for large numbers when reporting dudded nodes from filter command ### Added to Test Suite: - *level01/createpts_filter* illustrates the difference between filter and the more accurate filterkd commands - *level01/smooth_massage* use massage with smooth to refine and de-refine a triangulation - *level01/write_exo* write 3D and 2D Exodus files with psets, eltsets, and facesets - *level01/pflotran_stor* write pflotran style Voronoi geometric coefficient (volume, face area) files ### PyLaGriT new features: - **read_sheetij** creates a quad mesh from an elevation file reading Z(i,j) into mesh zic attribute - **read_modflow** creates a modflow rectilinear mesh using modflow files using elev\\_top.mod and init_bnds.inf - **read_fehm** read FEHM format mesh file with geometry and connectivity (LaGriT does not have this option) - *examples/arctic_w_ice_wedges* example Mesh for 2D polygon with ice wedges by Chuck Abolt - *examples/julia* Example of using PyLaGriT within a Julia script. Requires that the Julia package PyCall is installed. ### Known Issues: - Builds with compiler gfortran v5 or greater can generate run-time signal exceptions such as IEEE_DNORMAL. Most exceptions have been tracked down and fixed according to picky compiler suggestions. These exceptions have not changed the behavior of the code. Exceptions will continue to be fixed as they show up. - During testing it was found that the filter command may find and remove fewer nodes than the command filterkd. The command filterkd is recommended where precision might be an issue. Documentation will be changed to reflect this. It is expected that the filter command and algorithm will be deprecated and replaced by filterkd. See *test/level01/createpts_filter* - Paraview has trouble displaying ExodusII facesets for 2D grids in 3 Dimensions, but is fine with 2D planar where Z values are ignored. When viewing these same ExodusII files with GMV, the facesets look correct. Checking files by converting to ASCII with ncdump, the files look correct. We do not know if this is a LaGriT, ExodusII, or Paraview issue. See *test/level01/write_exo* for ExodusII example files. --------------------------- ## LaGriT V3.200 September 2016 LaGriT V3 LACC-15-069 is now distributed as open-source software under a BSD 3-Clause License. This version moves the entire LaGriT repo from a local mercurial version control to public github and now includes the python driven version PyLaGriT. For most current versions of source and documentation use the open-source repository at ``` https://github.com/lanl/LaGriT``` Compiled executable versions of LaGriT will continue to available through https://lagrit.lanl.gov/licensing.md *See code and issues at https://github.com/lanl/LaGriT*",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V3.200.html"
  },{
    "title": "LaGriT V3.3.3 Release Notes",
    "text": "LaGriT V3.3.3 Release Notes ==================== This page describes version updates for V3.3.3 release. This release updates code to prepare for major capability developments using new C++ routines. CMake tools are used to enable the cross platform compile and linking of C/C++ to LaGriT Fortran code. Previous release LaGriT v3.3.2 Apr 16, 2019 ### Enhancements: - 2D Poisson Disc Sampling for point generation. See command createpts/poisson_disk - Modified triangulate so that it will try clockwise and counterclockwise polygon orientation. - read/gocad for 3D .so and 2D .ts files. - AVS UCD pnt format added to make it easy for Paraview to read and view points. - GMV option ipolydat = no is now the default, files will have smaller size without voronoi polygons included - Improvements to PyLaGriT commands and usage, test cases added to the directory - The manual and command pages were heavily edited to add examples and remove unused large files - Test scripts and organization improved to include level01 (always), level02 (exodus libs), level03 (dev only) ### Major Change in Build This release includes new build scripts and associated files that use cmake to compile, build, and test LaGriT with and without optional Exodus libs. The build process with and without Exodus has been tested on Linux (Ubuntu 18 and 20) and MacOS (Ventura Intel and M2). Further work, including for Windows, will continue in future releases. Our cmake scripts do not always use the latest features, instead favoring readability and straightforward statements to help with debugging and troubleshooting. The cmake and install scripts are commented with suggestions and the build documentation has details for all steps. See README.md and links on main page. - Cmake is controlled by CMakeLists.txt and settings found in /cmake files. - Cmake creates lagrit.h using PROJECT_VERSION_* in template lagrit.h.in - Cmake creates fc_mangle.h for c-fortran routines to handle symbol mangling, CMakeLists.txt names should match declarations in src/lg_f_interface.h - The LaGriT build is fairly simple without ExodusII and is recommended if you do not need to write exodus files. - For Exodus install, configure, and build for LaGrit, use scripts install-exodus.sh or Mac_install-exodus.sh ### Major Codes Added The new poisson-disk routines are written in C++ and depend on new codes in support of c-fortran interfaces. See src/poi_* for the new poisson-disk codes. The file src/lg_example.cpp explains how the c-fortran codes are handled. ``` lg_fc_wrappers.f90 - used to assign mesh object cray pointer to c pointer lg_c_wrappers.cpp - cpp wrappers for dotask and cmo_get_info routines lg_f_interface.h - fortran declarations for routines in public_interface.cpp lg_c_interface.h - constants and c declarations fc_mangle.h - created by cmake and CMakeLists.txt to mangle fortran declarations lg_routines are C++ wrappers calling fortran using C arguments fc_routines are f90 wrappers calling fortran using c-fortran arguments In all cases types passed must match types in fortran where integer=8bytes, real*8=8bytes, pointer=8bytes ``` ### Known Issues - New Mac compilers are showing a precision differences for very small numbers near zero. This does not appear to affect performance but might be noticed when comparing new mac output files with old versions. For instance in \"degenerate\" cases with 4 vertices on circumscribed circle, you can put the diagonal edge of the rectangle on either diagonal and round off may be the deciding factor. The different connection of this degenerate case is still correct/Delaunay. See issue #252 - If compiled with gfortran V5 or greater, LaGriT may exit on exceptions not caught in old portions of code. Avoid this by using the flag -ffpe-trap=invalid,zero,overflow,underflow,denormal - Though Window machines have been supported in the past, this release has not been compiled and tested on Windows. ### Log Summary ``` git log --pretty=format:\"%h - %an, %ar : %s\" --since=3.years 35f2fc81 - Terry Miller, 24 hours ago : Update lagrit_release_notes_V3.330.md f77526bb - Terry Miller, 3 days ago : Update README.md 80509d5b - Erica Hinrichs, 3 days ago : Adding an Exodus install script for MAC 9d9da4a6 - Erica Hinrichs, 3 days ago : Updates to runtest.py and README files ab02ec31 - Terry Miller, 3 days ago : level03 with precision diffs for mac and linux 945f7523 - Terry Miller, 2 weeks ago : Examples for poisson development 05664065 - Erica Hinrichs, 2 weeks ago : Modified and improved test suite for usability and to fix arguments not working issue. a4889204 - Terry Miller, 2 weeks ago : Added new tests for stack and mac precision test 77fd45c2 - Terry Miller, 2 weeks ago : Moved hex_3x4 to level03 test for mac precision issue a6cc9fdc - Terry Miller, 2 weeks ago : Updates to reference files with added screen output 8020b578 - Terry Miller, 2 weeks ago : Update createpts_poisson.md 901b7e6e - Terry Miller, 2 weeks ago : exodus build d2a29f79 - Jeffrey Hyman, 2 weeks ago : Merge branch 'master' into poisson_disk 80401237 - Carl Walter Gable, 2 weeks ago : Merge branch 'poisson_disk' of github.com:lanl/LaGriT into poisson_disk dd5db696 - Erica Hinrichs, 2 weeks ago : Small edits to fix implicit declaration errors. b72fe9d1 - Terry Miller, 3 weeks ago : poisson_disk documentation 54bd7a12 - Terry Miller, 3 weeks ago : Merge branch 'master' of github.com:lanl/LaGriT 7109fa05 - Terry Miller, 3 weeks ago : Running the script will FIX Exodus cmake files for a successful linux build 9729129e - Terry Miller, 3 weeks ago : Add instructions to use SSH clone for git push/pull 896c4432 - Carl Walter Gable, 3 weeks ago : Working version of 2D Poisson disk code, added advanced options for seed, sweeps, samples, and a few typos corrected in *.cpp files. 08d4d081 - Terry Miller, 3 weeks ago : Update lagrit_release_notes_V3.330.md d0c973dd - Terry Miller, 4 weeks ago : Update README.md 810be706 - Jeffrey Hyman, 4 months ago : grid memory allocation d0307191 - Jeffrey Hyman, 4 months ago : preallocated vectors in poisson disk bc1ba76c - Terry Miller, 6 months ago : Added README.md and modified files in this documentation directory to clarify these files are pre-2019 from mercurial and web page documentation. Current documentation is in the docs directory. e3345ad7 - Terry Miller, 6 months ago : Update build.md WINDOWS under dev affb3420 - Terry Miller, 6 months ago : Update build.md regarding cmake 94da5982 - Terry Miller, 6 months ago : Update development.md contacts 0724f698 - Terry Miller, 6 months ago : Update index.md broken link b9972b9e - Terry Miller, 6 months ago : Update index.md with quick links at top 7d0779e0 - Jeffrey Hyman, 6 months ago : Merge branch 'master' into poisson_disk 822059b7 - Jeffrey Hyman, 6 months ago : Merge branch 'master' into poisson_disk 1ad05506 - Terry Miller, 6 months ago : Small edits to build lagrit on Linux for V3.3.3 d54129db - Terry Miller, 6 months ago : CMakeLists.txt working on linux and mac with exodus and no exodus aa6b03cf - Terry Miller, 6 months ago : Removed original_pylagrit_website fd1c851b - Terry Miller, 6 months ago : remove unused m64 flag, add error reporting d249f6a9 - Jeffrey Hyman, 10 months ago : added z value to polygon sampling f03ba1c7 - Jeffrey Hyman, 10 months ago : more formatting bb1e52fa - Jeffrey Hyman, 10 months ago : cleaing up Poisson Disk screen output b89018e6 - Jeffrey Hyman, 10 months ago : advanced user options for Poisson Disck Sampling 6d1b4140 - Jeffrey Hyman, 10 months ago : adding seed option to C++ code. needs to be added to LaGrit high-level command 7223f104 - Jeffrey Hyman, 1 year, 1 month ago : AStyle formatting of c++ files edd7740c - Jeffrey Hyman, 1 year, 1 month ago : mo_poi_h_field added to C++ poisson input arguments fcc1ab8f - Terry Miller, 1 year, 3 months ago : update instructions 3893346e - Terry Miller, 1 year, 3 months ago : cmake options 3d83906a - Terry Miller, 1 year, 3 months ago : exodus install 965ccdb5 - Terry Miller, 1 year, 3 months ago : update instructions d7ea4a51 - Terry Miller, 1 year, 3 months ago : Fixes to cmake files to build with Exodus on Linux and macOSX 5dd59c84 - Terry Miller, 1 year, 5 months ago : make in build dir 8878d2d2 - Terry Miller, 1 year, 5 months ago : stack 733efb9f - Terry Miller, 1 year, 5 months ago : add 4 octree examples ee71c25d - Terry Miller, 1 year, 6 months ago : add instructions for build and test 402fd797 - Carl Walter Gable, 1 year, 1 month ago : Modifid arguments to poisson_2d. Cleaned up some screen output. Get rid of unused variables. Refined steps taken for nonconvex polygons. fd256570 - Carl Walter Gable, 1 year, 2 months ago : Added code to poi_driver.f to handle nonconvex polygon input. Modified triangulate_lg.f so that it will try clockwise and counterclockwise polygon orientation. 69f4008a - Carl Walter Gable, 1 year, 2 months ago : First working version of Poisson disk driver subroutine 2f34a017 - Carl Walter Gable, 1 year, 2 months ago : Change default name of node attribute to id_node. It was ialias ecdb22c2 - Jeffrey Hyman, 1 year, 3 months ago : linux gnu 7.5 doesn't like vector.reserve a1d466f8 - Jeffrey Hyman, 1 year, 3 months ago : commiting to vectors 9678020f - Jeffrey Hyman, 1 year, 3 months ago : working again 535a664e - Jeffrey Hyman, 1 year, 3 months ago : revert back from vector: 6da61e7a - Jeffrey Hyman, 1 year, 3 months ago : convert to linear index vectors dbb25433 - Jeffrey Hyman, 1 year, 3 months ago : revert 9a5d4db4 - Jeffrey Hyman, 1 year, 3 months ago : cleaning up lagrit calls b5dc9738 - Jeffrey Hyman, 1 year, 3 months ago : switch to linear indexing 72bedc53 - Jeffrey Hyman, 1 year, 3 months ago : changing grid to linear indexing 9028310d - Jeffrey Hyman, 1 year, 3 months ago : debugging neighbor grid a80b78b2 - Jeffrey Hyman, 1 year, 3 months ago : debugging neighbor grid dd9625b0 - Jeffrey Hyman, 1 year, 3 months ago : Cleaned out dumps 9d0122d0 - Jeffrey Hyman, 1 year, 3 months ago : I tihnk it's working? aea1dea3 - Jeffrey Hyman, 1 year, 3 months ago : names are cleaned up and working fe3cdb7a - Jeffrey Hyman, 1 year, 3 months ago : cleaned up a bunch of names 148058a1 - Jeffrey Hyman, 1 year, 3 months ago : adding checks de3bf69c - Jeffrey Hyman, 1 year, 3 months ago : working on reading in the vertices db203abd - Jeffrey Hyman, 1 year, 3 months ago : fixed line length dbf1477b - Jeffrey Hyman, 1 year, 3 months ago : set up for merge 1a0b624d - Jeffrey Hyman, 1 year, 3 months ago : set up for merge 8f7bfda8 - Jeffrey Hyman, 1 year, 3 months ago : distance field load seems to be working npw fc7a6eae - Jeffrey Hyman, 1 year, 3 months ago : distance field indexing is wrong. radius assigned to h. Seems to work as a hack for now e002cbb0 - Terry Miller, 1 year, 3 months ago : verbose 747e51d4 - Terry Miller, 1 year, 3 months ago : verbose options dc77a616 - Terry Miller, 1 year, 3 months ago : update instructions 65c61a71 - Terry Miller, 1 year, 3 months ago : cmake options fb25fdf9 - Terry Miller, 1 year, 3 months ago : exodus install 5dd67dce - Terry Miller, 1 year, 3 months ago : update instructions 3fcd4572 - Terry Miller, 1 year, 3 months ago : Fixes to cmake files to build with Exodus on Linux and macOSX 49c5bcd2 - Jeffrey Hyman, 1 year, 5 months ago : PD-2D seems to be working aa8d96ab - Jeffrey Hyman, 1 year, 5 months ago : poisson disk 2d uniform working 425a2f18 - Jeffrey Hyman, 1 year, 5 months ago : trying to pass doubles / Reals to C++ a042018f - Jeffrey Hyman, 1 year, 5 months ago : loaded points onto polygon from cmo 08be2c18 - Jeffrey Hyman, 1 year, 5 months ago : fixed up conflict 5f98c47f - Jeffrey Hyman, 1 year, 5 months ago : setup for merge aed1dba6 - Carl Walter Gable, 1 year, 5 months ago : fortran driver for PD 00435baa - Terry Miller, 1 year, 5 months ago : dev a174b0d5 - Terry Miller, 1 year, 5 months ago : make in build dir ae8ae294 - Terry Miller, 1 year, 5 months ago : stack 1b15c844 - Terry Miller, 1 year, 5 months ago : img 1c1be6e7 - Terry Miller, 1 year, 5 months ago : add image 1e98921e - Terry Miller, 1 year, 5 months ago : GDSA 4 Tests image 40642680 - Terry Miller, 1 year, 5 months ago : add 4 octree examples 82e6c86f - Terry Miller, 1 year, 6 months ago : add instructions for build and test 53fd3bbd - Terry Miller, 1 year, 7 months ago : These files contain routines to interface C++ codes to lagrit fortran routines. fc_mangle.h included but will be overwritten with cmake Note lg_ files are similar to Daniel's C++ interface on windows branch 8eedca21 - Terry Miller, 1 year, 7 months ago : add command poisson and Jeffrey's files for 2D version these are under development to add syntax and methods 409c05f2 - Terry Miller, 1 year, 7 months ago : Corrected to return REAL value for REAL option instead of int Added checks for 8 byte sizes passed by argument c6180cfe - Terry Miller, 1 year, 7 months ago : Added portion to create src/fc_mangle.h to bind C-Fortran subroutine names 87986f8c - Terry Miller, 1 year, 8 months ago : examples 8b696073 - Terry Miller, 1 year, 8 months ago : Update for compile with cmake, add test using cmo_get calls make sure user_sub not called if command not recognized added test command 65ebad45 - Terry Miller, 1 year, 9 months ago : new files c5fa0a2b - Terry Miller, 1 year, 9 months ago : make 4464fc3d - Terry Miller, 1 year, 9 months ago : no exodus c33a9288 - Terry Miller, 1 year, 9 months ago : links 439579dd - Terry Miller, 1 year, 9 months ago : add workflow 17406ca8 - Terry Miller, 1 year, 9 months ago : -99 42e6826a - Terry Miller, 1 year, 10 months ago : put back with new img a5c0d7f2 - Terry Miller, 1 year, 10 months ago : remove tutorial section d5d62f36 - Terry Miller, 1 year, 10 months ago : img ab311ff0 - Terry Miller, 1 year, 10 months ago : img fbae5abb - Terry Miller, 2 years ago : update instructions 3be8a088 - Terry Miller, 2 years ago : clarify instructions e546cb99 - Terry Miller, 2 years ago : tested and working examples moved to level01 remaining files need more work and testing 901423ba - Terry Miller, 2 years ago : clarification on level03 test directories 3561e088 - Terry Miller, 2 years ago : test removed from level03 and replaced with new test in level01 31cffeac - Terry Miller, 2 years ago : test removed from level03 and replaced with new test in level01 59ff12d1 - Terry Miller, 2 years ago : for V3.32 and older 18ac81d6 - Terry Miller, 2 years ago : Update lagrit_release_notes_V3.330.md cceb3d16 - Daniel Livingston, 2 years ago : Merge pull request #237 from lanl/RC-v3.3.3 869ff333 - Daniel Livingston, 2 years ago : Fixed test suite for quadquality test 3d39f905 - Daniel Reece Livingston, 2 years ago : Update test readme 1d800023 - Daniel Reece Livingston, 2 years ago : Remove extra file b4378726 - Daniel Reece Livingston, 2 years ago : Release cleanup 6ab71b89 - Daniel Livingston, 2 years ago : Added test info to readme 7dc091da - Daniel Livingston, 2 years ago : Merge branch 'master' of github.com:lanl/LaGriT into RC-v3.3.3 a720479d - Daniel Livingston, 2 years ago : Clean up test cases 7a9e341c - Daniel Livingston, 2 years ago : More modernized test suite 164b7bfc - Daniel Reece Livingston, 2 years, 1 month ago : Added unittest testing 8d51b78b - Daniel Reece Livingston, 2 years, 1 month ago : Attempt to update GitHub Actions again dccc97e5 - Daniel Reece Livingston, 2 years, 1 month ago : Update GitHub CI with compilers f8928477 - Terry Miller, 2 years, 1 month ago : update 4f112c7d - Daniel Reece Livingston, 2 years, 1 month ago : Updated CMake significantly bb3964c1 - Daniel Reece Livingston, 2 years, 1 month ago : Beginning CMake writeup b869bbc2 - Daniel Reece Livingston, 2 years, 1 month ago : CMake now writes mm2000.h 44db2213 - Daniel Reece Livingston, 2 years, 1 month ago : Testing LaGriT 0d461985 - Daniel Reece Livingston, 2 years, 1 month ago : Fixed missing gfortran in macOS 234235c7 - Daniel Reece Livingston, 2 years, 1 month ago : Fixed CI Python issue 6b7d86f5 - Daniel Reece Livingston, 2 years, 1 month ago : Improvements to Exodus build cd71aeb4 - Daniel Reece Livingston, 2 years, 1 month ago : Some bug fixes fe3b42ee - Daniel Reece Livingston, 2 years, 1 month ago : Update Python version for CI 11fbc6d3 - Daniel Reece Livingston, 2 years, 1 month ago : Update GitHub CI 900cdc47 - Daniel Livingston, 2 years, 1 month ago : Update test-lagrit.yml cefb5d97 - Daniel Livingston, 2 years, 1 month ago : Exous scripts 08405dae - Daniel Livingston, 2 years, 1 month ago : Added auto-push compiled to CI 51c94207 - Daniel Livingston, 2 years, 1 month ago : Updated CI ab55fc97 - Daniel Livingston, 2 years, 1 month ago : Updated build 93e52c45 - Daniel Livingston, 2 years, 1 month ago : Updated LaGriT CMake 01dd9c2a - Daniel Livingston, 2 years, 1 month ago : Much improved CMake installation and some automatic Exodus lib handling 35bdf6ca - Daniel Livingston, 2 years, 1 month ago : Working static and dynamic linkage 2db46e78 - Daniel Livingston, 2 years, 1 month ago : Changed Fortran preproc settings for CMake 3.11 c8bd8bc3 - Daniel Livingston, 2 years, 1 month ago : Modularizing CMake 47290b68 - Daniel Livingston, 2 years, 1 month ago : Updates to build 8bd255df - Daniel Livingston, 2 years, 1 month ago : Working build - Clang C/GNU Fortran d0342330 - Daniel Reece Livingston, 2 years, 1 month ago : Compilation working with CMakeLists d3938f14 - Daniel Reece Livingston, 2 years, 1 month ago : Changing build to CMake 5943e3ea - Daniel Livingston, 2 years, 1 month ago : Removed filename conflicts 92f32c15 - Terry Miller, 2 years, 1 month ago : Add test of gocad files used by dfnWorks and SFWD Jewelsuite projects Includes fixes to attribute names and result reporting 56dc0b2d - Terry Miller, 2 years, 1 month ago : remove gmv files, comment dump commands, update to V3.33 5c22b429 - Terry Miller, 2 years, 1 month ago : remove lagrit output files 0a0bd306 - Terry Miller, 2 years, 1 month ago : move from level03 to level01 to ensure testing for this common command removed binary files and update to V3.33 0584bb21 - Terry Miller, 2 years, 1 month ago : Merge branch 'master' of https://github.com/lanl/LaGriT 1ee072a7 - Terry Miller, 2 years, 1 month ago : fix table fa279afd - Terry Miller, 2 years, 1 month ago : link refine 60a4b4a0 - Terry Miller, 2 years, 1 month ago : tree_to_fe explained 6c2ae8c9 - Terry Miller, 2 years, 1 month ago : Update reference to V3.33 0a1e57ae - Terry Miller, 2 years, 2 months ago : removed extra directories and files, update README f75d25d3 - Terry Miller, 2 years, 2 months ago : move write_exo from level01 to level02 because it depends on exo libs. update reference to V3.33 65a9a078 - Terry Miller, 2 years, 2 months ago : heavily modified input.lgi with improved syntax and added comments update reference to V3.33 release and newer exodus 7 versions 90847269 - Terry Miller, 2 years, 2 months ago : replace gmv with avs files, update reference to V3.33 update reference exo from api_version = 5.22f to 7 block ids no longer have 0000 so 1 is 1 instead of 10000 99894ca2 - Terry Miller, 2 years, 2 months ago : final clean-up for V3.33 release c31c20c1 - Terry Miller, 2 years, 2 months ago : remove old text for old versions of test suite 896124f0 - Terry Miller, 2 years, 2 months ago : remove extra files and update reference to V3.33 5f6d63be - Terry Miller, 2 years, 2 months ago : remove extra files and update reference to V3.33 4a0a49ec - Terry Miller, 2 years, 2 months ago : update reference to V3.33 c9b77654 - Terry Miller, 2 years, 2 months ago : update reference to V3.33 54b8ad9b - Terry Miller, 2 years, 2 months ago : removed unused portion of test and moved to level03/sort as it depends on platform and seed value and checks are visual this test should now be independent of platform update reference to V3.33 97eff5ed - Terry Miller, 2 years, 2 months ago : remove extra files, replace gmv with avs files update reference to V3.33 865b5576 - Terry Miller, 2 years, 2 months ago : replace gmv files with avs and updae to V3.33 b7581990 - Terry Miller, 2 years, 2 months ago : rename files with input and output prefix, update reference to V3.33 4e71e29d - Terry Miller, 2 years, 2 months ago : replace gmv with avs and update reference to V3.33 763ad594 - Terry Miller, 2 years, 2 months ago : remove extra files and update reference to V3.33 accf1367 - Terry Miller, 2 years, 2 months ago : replace gmv with avs and update reference to V3.33 fc452558 - Terry Miller, 2 years, 2 months ago : update reference to V3.33 4c635660 - Terry Miller, 2 years, 2 months ago : replace gmv with avs and update reference to V3.33 4cd843fa - Terry Miller, 2 years, 2 months ago : replace gmv with avs, update reference to V3.33 c431e1c4 - Terry Miller, 2 years, 2 months ago : update reference to V3.33 bd0a0994 - Terry Miller, 2 years, 2 months ago : replace gmv with avs, rename test with input_ update reference V3.33 a083d123 - Terry Miller, 2 years, 2 months ago : Merge branch 'master' of https://github.com/lanl/LaGriT 4e971f86 - Terry Miller, 2 years, 2 months ago : update reference to V3.33 c32ca5e8 - Terry Miller, 2 years, 2 months ago : rename written files to start with \"out_\" so they can be cleaned update reference to V3.33 f5b65bcb - Terry Miller, 2 years, 2 months ago : update reference to V3.33 018e7031 - Daniel Livingston, 2 years, 2 months ago : Added some debugging params 52bed9ee - Terry Miller, 2 years, 2 months ago : Merge branch 'master' of https://github.com/lanl/LaGriT a506c819 - Daniel Livingston, 2 years, 2 months ago : Added macOS to GitHub Actions 9b03dd87 - Terry Miller, 2 years, 2 months ago : remove gmv and update reference to V3.33 fc287904 - Daniel Livingston, 2 years, 2 months ago : Fixing GitHub Actions CI 919de121 - Terry Miller, 2 years, 2 months ago : remove extra files, add intersect_elements, fix warnings update reference to V3.33 8beadf5d - Terry Miller, 2 years, 2 months ago : minor adjustment to input.lgi and outx3dgen in reference 887ce884 - Terry Miller, 2 years, 2 months ago : remove many extra files unneeded for this test update to V3.33 38342309 - Terry Miller, 2 years, 2 months ago : replace binary gmv with ascii avs, update reference to V3.33 dd0d090b - Terry Miller, 2 years, 2 months ago : replace all gmv output with single avs files update reference to V3.33 7e266c38 - Terry Miller, 2 years, 2 months ago : remove output files from test directory b7a1bbda - Terry Miller, 2 years, 2 months ago : remove gmv, update reference to V3.33 93072d4a - Terry Miller, 2 years, 2 months ago : remove gmv files, rename output files, update to V3.33 edf2989f - Terry Miller, 2 years, 2 months ago : remove gmv files, rename written files to \"output\", remove extra files update reference to V3.33 e467ec90 - Terry Miller, 2 years, 2 months ago : remove extra files, avs vector no longer writes (invalid) file modified input.lgi to remove before writing avs file removed gmv files 3f6ae594 - Terry Miller, 2 years, 2 months ago : change output files to start with name \"output\" 3287f0f8 - Terry Miller, 2 years, 2 months ago : remove gmv and extra files, update reference to V3.33 47b0c428 - Terry Miller, 2 years, 2 months ago : remove gmv files and update reference to V3.33 test e127dcda - Terry Miller, 2 years, 2 months ago : remove hard-wired dump/gmv/polygon.gmv and leave polygon.inp ebdc9315 - Daniel Livingston, 2 years, 2 months ago : Update Makefile c0c31d25 - Terry Miller, 2 years, 3 months ago : GOCAD keywords 26c829f9 - Terry Miller, 2 years, 3 months ago : update gocad examples e10c7641 - Terry Miller, 2 years, 3 months ago : edit 647f735d - Terry Miller, 2 years, 3 months ago : release notes for V3.3.3 a872714f - Terry Miller, 2 years, 3 months ago : renamed read gocad test files to have input_ for file names 6dae464f - Terry Miller, 2 years, 3 months ago : test directory for read/gocad 2D and 3D files a1792928 - Terry Miller, 2 years, 3 months ago : Merge branch 'master' of https://github.com/lanl/LaGriT af1509f1 - Terry Miller, 2 years, 3 months ago : added missing input*inp for level01/quality fdcda231 - Terry Miller, 2 years, 3 months ago : Update reference to include new warning for mo with 0 elements b5c61765 - Daniel Livingston, 2 years, 3 months ago : Delete .travis.yml f4864bb8 - Terry Miller, 2 years, 3 months ago : Changed ipolydat default to no for writing gmv files 1f9c813c - Terry Miller, 2 years, 3 months ago : Fixed over reporting, buffer issues, better file handling for GOCAD files #222 and #204 1e8f8468 - Terry Miller, 2 years, 3 months ago : Added check to avoie 0 element errors from recon #228 4373c8d7 - Terry Miller, 2 years, 3 months ago : Update lagrit.h to release V3.3.3 October 8 2021 e2c20f9a - Terry Miller, 2 years, 3 months ago : add ZVD ref 6decf3e6 - Terry Miller, 2 years, 4 months ago : fix center 952c7375 - Daniel Reece Livingston, 2 years, 8 months ago : Fixed PyLaGriT warnings 3542b8c2 - Daniel Reece Livingston, 2 years, 8 months ago : Fixed failing test cases for CI bf7fd833 - Daniel Reece Livingston, 2 years, 8 months ago : Used Black formatting on PyLaGriT files a4fc5ee5 - Daniel Reece Livingston, 2 years, 8 months ago : Used Black formatting on test Python files 61d1d101 - Daniel Reece Livingston, 2 years, 8 months ago : Changed makefile flag to work with gcc > 10 and < 10 af72ab1e - Daniel Livingston, 2 years, 8 months ago : Update GH Action to remove update-defaults 0e9ed448 - Daniel Livingston, 2 years, 8 months ago : Update test-lagrit.yml 9277a257 - Daniel Livingston, 2 years, 8 months ago : Added new GitHub Actions status badge to repo b039a67b - Daniel Livingston, 2 years, 8 months ago : Added GitHub Actions for testing LaGriT 3ca8d468 - Daniel Livingston, 2 years, 8 months ago : Changed PyLaGriT setup to setuptools from distutil 03666b6c - Terry Miller, 2 years, 8 months ago : links a59d2a6d - Terry Miller, 2 years, 8 months ago : fix gmv link 8b6ebcb7 - Terry Miller, 2 years, 8 months ago : add links 50584497 - Daniel Reece Livingston, 2 years, 9 months ago : Added std=legacy flag to remove errors on newer gfortran compilers ```",
    "tags": "",
    "url": "/pages/release_notes/lagrit_release_notes_V3.330.html"
  },{
    "title": "",
    "text": "* Read avs files cmo/create/exterior/60//3/2/3/3/3/read/avs/exterior.avs/exterior/1/1/0/ cmo/create/sigas/500/500/3/2/3/3/3/read/avs/cont.0.avs/sigas/1/1/0/ cmo/create/oxgas/1000/2000/3/2/3/3/3/read/avs/cont.12.avs/oxgas/1/1/0/ cmo/create/vp/1000/2000/3/2/3/3/3/read/avs/cont.3.avs/vp/1/1/0/ * Define surfaces regions materials. cmo/create/mesh/3000/3000/surface/bb/reflect/sheet/exterior/surface/sg/intrface/sheet/sigas/surface/og/intrface/ sheet/ oxgas/region/sub/le bb and lt sg /region/ox /le bb and ge sg and le og /region/gas/le bb and gt og /mregion/matsub/ le bb and lt sg /mregion/matox / le bb and gt sg and lt og /mregion/matgas/ le bb and gt og /cmo/verify/-all- * Copy points from the sheets. copypts/mesh/exterior/copypts/mesh/sigas/zq/itp/0, 0, 0/0copypts/mesh/oxgas/zq/itp/0, 0, 0/0copypts/mesh/vp/zq/itp/0, 0, 0/0rz/xyz/21 29 33/1 0 0/2.25 1. 4/1 1 1 rz/xyz/11 15/1 1 0/5. 2.25 1. 5./1 1 1 pset/rays/seq/0 0 0/ regnpts/ox/1/pset/get/rays/xyz/ 0. 0. -5./ 1. 0. -5./ 1. 1. -5./ zq/itp/pset/get/rays/dud/ * Generate the mesh. filter/1 0 0 /setptsdump/x3d/x3d1searchsettets/geometrydump/gmv/TL.gmv/meshfinish [Return to LaGriT Home Page](/)",
    "tags": "",
    "url": "/pages/semi.html"
  },{
    "title": "",
    "text": "cmo/create/3dmesh surface/brt/reflect /plane/1.0,0.0,0.0/1.0,1.0,0.0/1.0,0.0,1.0/ surface/blt/reflect /plane/0.0,0.0,0.0/0.0,0.0,1.0/0.0,1.0,0.0/ surface/btp/reflect /plane/0.0,0.0,2.0/1.0,0.0,2.0/0.0,1.0,2.0/ surface/bbt/reflect /plane/0.0,0.0,0.0/0.0,1.0,0.0/1.0,0.0,0.0/ surface/bfr/reflect /plane/0.0,-0.2,0.0/1.0,-0.2,0.0/0.0,-0.2,1.0/ surface/bbk/intrface/plane/0.0, 1.0,0.0/0.0, 1.0,1.0/1.0, 1.0,0.0/ surface/b1 /intrface/plane/0.4,0.0,0.0/0.4,1.0,0.0/0.4,0.0,1.0/ surface/b2 /intrface/plane/0.6,0.0,0.0/0.6,1.0,0.0/0.6,0.0,1.0/ surface/b3 /intrface/plane/0.7,0.0,0.0/0.7,1.0,0.0/0.7,0.0,1.0/ surface/pl1/intrface/plane/0.0,0.0,2.0/0.4,0.0,2.0/0.4,0.0,0.0/ surface/pl2/intrface/plane/0.4,0.0,2.0/0.6,0.05,2.0/0.6,0.05,0.0/ surface/pl3/intrface/plane/0.6,0.05,2.0/0.7,0.2,2.0/0.7,0.2,0.0/ surface/pl4/intrface/plane/0.7,0.2,2.0/1.0,0.2,2.0/1.0,0.2,0.0/ surface/pl5/intrface/plane/0.0,-0.01,2.0/0.4,-0.01,2.0/0.4,-0.01,0.0/ surface/pl6/intrface/plane/0.4,-0.01,2.0/0.6,0.04,2.0/0.6,0.04,0.0/ surface/pl7/intrface/plane/0.6,0.04,2.0/0.7,-0.1,2.0/0.7,-0.1,0.0/ surface/pl8/intrface/plane/0.7,-0.1,2.0/1.0,-0.1,2.0/1.0,-0.1,0.0/ surface/pl9/intrface/plane/0.0,0.0,0.5/1.0,0.0,0.5/0.0,1.0,0.5/ surface/pla/intrface/plane/0.0,1.0,1.5/1.0,0.0,1.5/0.0,0.0,1.5/ surface/plb/intrface/plane/0.0,0.0,0.1/1.0,0.0,0.1/0.0,1.0,0.1/ surface/plc/intrface/plane/0.0,1.0,0.4/1.0,0.0,0.4/0.0,0.0,0.4/ surface/pld/intrface/plane/0.0,0.0,1.6/1.0,0.0,1.6/0.0,1.0,1.6/ surface/ple/intrface/plane/0.0,1.0,1.9/1.0,0.0,1.9/0.0,0.0,1.9/ surface/plf/intrface/plane/0.0,-0.15,2.0/0.4,-0.15,2.0/0.4,-0.15,0.0/ surface/plg/reflect /plane/0.0,1.2,0.0/0.0,1.2,2.0/1.0,1.2,0.0/ mregion/reg1/ ( le blt and lt b1 and le btp and le bbt and lt bbk & and gt pl1 ) or & ( ge b1 and lt b2 and le btp and le bbt and lt bbk & and gt pl2 ) or & ( ge b2 and lt b3 and le btp and le bbt and lt bbk & and gt pl3 ) or & ( ge b3 and le brt and le btp and le bbt and lt bbk & and gt pl4 ) mregion/reg2/ ( le blt and lt b1 & and lt pl1 and gt pl5 and gt pl9 and gt pla ) or & ( ge b1 and le b2 & and lt pl2 and gt pl6 and gt pl9 and gt pla ) or & ( gt b2 and lt b3 and le btp and le bbt & and lt pl3 and gt pl7 ) or & ( ge b3 and le brt and le btp and le bbt & and lt pl4 and gt pl8 ) mregion/reg3/ ( le blt and le b1 and le bbt and le bfr & and lt pl1 and lt plb ) or & ( le blt and le b1 and le bfr & and lt plf and ge plb and ge plc ) or & ( le blt and le b1 and le bfr & and lt pl1 and lt plc and lt pl9 ) or & ( le blt and le b1 and le bfr & and lt plf and ge pl9 and ge pla ) or & ( le blt and le b1 and le bfr & and lt pl1 and lt pla and lt pld ) or & ( le blt and le b1 and le bfr & and lt plf and ge pld and ge ple ) or & ( le blt and le b1 and le btp and le bfr & and lt pl1 and lt ple ) or & ( gt b1 and lt b2 and le bfr & and lt plf and ge pl9 and ge pla ) or & ( gt b1 and lt b2 and le bfr and le btp and le bbt & and lt pl2 and ( lt pl9 or lt pla ) ) or & ( ge b2 and le b3 and le bfr & and lt plf and ge pl9 and ge pla ) or & ( ge b2 and le b3 and le bfr and le btp and le bbt & and lt pl7 and ( lt pl9 or lt pla ) ) or & ( gt b3 and le brt and le btp and le bfr & and lt pl8 and le bbt ) mregion/reg4/ ( le blt and lt b1 & and lt pl1 and gt plf and gt plb and gt plc ) mregion/reg5/ ( le blt and lt b1 & and lt pl1 and gt plf and gt pld and gt ple ) mregion/reg6/ ( le blt and lt b1 & and lt pl5 and gt plf and gt pl9 and gt pla ) or & ( ge b1 and lt b2 & and lt pl6 and gt plf and gt pl9 and gt pla ) or & ( ge b2 and lt b3 & and lt pl7 and gt plf and gt pl9 and gt pla ) mregion/reg7/ le plg and le brt and le blt and le btp and le bbt & and gt bbk region/reg1a/( le blt and lt b1 and le btp and le bbt and lt bbk & and gt pl1 ) region/reg1b/( ge b1 and lt b2 and le btp and le bbt and lt bbk & and ge pl2 ) region/reg1c/( ge b2 and lt b3 and le btp and le bbt and lt bbk & and ge pl3 ) region/reg1d/( ge b3 and le brt and le btp and le bbt and lt bbk & and ge pl4 ) region/reg2a/( le blt and lt b1 & and le pl1 and ge pl5 and ge pl9 and ge pla ) region/reg2b/( ge b1 and lt b2 & and lt pl2 and ge pl6 and ge pl9 and ge pla ) region/reg2c/( ge b2 and lt b3 and le btp and le bbt & and lt pl3 and ge pl7 ) region/reg2d/( ge b3 and le brt and le btp and le bbt & and lt pl4 and ge pl8 ) region/reg3a/ ( le blt and le b1 and le bbt and le bfr & and le pl1 and lt plb ) region/reg3b/( le blt and le b1 and le bfr & and lt plf and ge plb and ge plc ) region/reg3c/( le blt and le b1 and le bfr & and le pl1 and lt plc and lt pl9 ) region/reg3d/( le blt and le b1 and le bfr & and lt plf and ge pl9 and ge pla ) region/reg3e/( le blt and le b1 and le bfr & and le pl1 and lt pla and lt pld ) region/reg3f/( le blt and le b1 and le bfr & and lt plf and ge pld and ge ple ) region/reg3g/( le blt and le b1 and le btp and le bfr & and le pl1 and lt ple ) region/reg3h/( gt b1 and lt b2 and le bfr & and lt plf and ge pl9 and ge pla ) region/reg3i/( gt b1 and lt b2 and le btp and le bbt and le bfr & and lt pl2 and ( lt pl9 or lt pla ) ) region/reg3j/( ge b2 and le b3 and le bfr & and lt plf and ge pl9 and ge pla ) region/reg3k/( ge b2 and le b3 and le btp and le bbt and le bfr & and lt pl7 and ( lt pl9 or lt pla ) ) region/reg3l/( gt b3 and le brt and le btp and le bfr and le bbt & and lt pl8 ) region/reg4/ ( le blt and le b1 & and le pl1 and ge plf and ge plb and ge plc ) region/reg5/ ( le blt and le b1 & and le pl1 and ge plf and ge pld and ge ple ) region/reg6a/( le blt and lt b1 & and lt pl5 and ge plf and ge pl9 and ge pla ) region/reg6b/( ge b1 and lt b2 & and lt pl6 and ge plf and ge pl9 and ge pla ) region/reg6c/( ge b2 and le b3 & and lt pl7 and ge plf and ge pl9 and ge pla ) region/reg7/ ( le plg and le brt and le blt and le btp and le bbt & and ge bbk ) rz/xyz/ 5,1, 4/0.0,3.0,0.0/0.4,3.0,0.1/1,0,1/ rz/xyz/9,1,7/0.0,3.0,0.1/0.4,3.0,0.4/1,0,1/ rz/xyz/ 5,1, 4/0.0,3.0,0.4/0.4,3.0,0.5/1,0,1/ rz/xyz/ 5,1,13/0.0,3.0,0.5/0.4,3.0,1.5/1,0,1/ rz/xyz/ 5,1, 4/0.0,3.0,1.5/0.4,3.0,1.6/1,0,1/ rz/xyz/9,1,7/0.0,3.0,1.6/0.4,3.0,1.9/1,0,1/ rz/xyz/ 5,1, 4/0.0,3.0,1.9/0.4,3.0,2.0/1,0,1/ rz/xyz/ 5,1, 7/0.4,3.0,0.0/0.6,3.0,0.5/1,0,1/ rz/xyz/ 9,1,13/0.4,3.0,0.5/0.6,3.0,1.5/1,0,1/ rz/xyz/ 5,1, 7/0.4,3.0,1.5/0.6,3.0,2.0/1,0,1/ rz/xyz/ 5,1, 7/0.6,3.0,0.0/0.7,3.0,0.5/1,0,1/ rz/xyz/ 5,1,13/0.6,3.0,0.5/0.7,3.0,1.5/1,0,1/ rz/xyz/ 5,1, 7/0.6,3.0,1.5/0.7,3.0,2.0/1,0,1/ rz/xyz/ 5,1,13/0.7,3.0,0.0/1.0,3.0,2.0/1,0,1/ pset/rays/seq/1,0,0/ regnpts/reg1a/ 7/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/1,2./ regnpts/reg1b/ 7/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/1,2./ regnpts/reg1c/ 7/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/1,2./ regnpts/reg1d/ 7/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/1,2./ regnpts/reg2a/ 2/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg2b/ 2/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg2c/ 4/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg2d/ 4/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3a/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3b/ 3/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3c/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3d/ 3/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3e/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3f/ 3/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3g/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3h/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3i/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3j/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3k/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg3l/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg6a/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg6b/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg6c/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg7/ 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg4 / 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ regnpts/reg5 / 5/pset,get,rays/xyz/0.0,-1.0,2.0/1.0,-1.0,2.0/1.0,-1.0,0.0/ zq/itp/pset,get/rays/21 filter/1,0,0/ setpts dump/x3d/x3d.mos3d.1 search dump/x3d/x3d.mos3d.2 settets dump/x3d/x3d.mos3d.3 dump/gmv/gmv.mos3d finish   [Return to LaGriT Home Page](/)",
    "tags": "",
    "url": "/pages/semi2.html"
  },{
    "title": "Semiconductor Examples",
    "text": "Semiconductor Examples ---------------------- Click on picture to expand [View input desk](/pages/semi.html) [View input desk](/pages/semi2.html)",
    "tags": "",
    "url": "/pages/semiexamples.html"
  },{
    "title": "",
    "text": "**Grain Evolution in a T-Junction** **by Tinka Gammel** Grain structure of a T-junction obtained via Monte Carlo evolution of a discrete effective classical spin (Potts) model on the nodes of the unstructured tetrahedral grid generated by the LANL LaGriT code for the bounding geometry (taking advantage of LaGriT's ability to efficiently create and manipulate grids for complex multimaterial geometries, and for compatibility with our finite element calculations). The time unit is Monte Carlo sweeps through the lattice. The node-based Potts model needs fewer neighbors to avoid stagnation and also avoids grain boundaries at topology-defining nodes, which is numerically convenient for using this result as an initial condition for a finite element continuum calculation. The Potts model is known to be the discrete analog of curvature driven grain boundary motion: the irregularities in the grain boundaries reflect the discreteness. Note the T-junction pins a grain boundary, preventing annealing into a single grain. However, the result of the Potts evolution on the unstructured grid is artificially rough, even at fairly high node density, as seen in this close-up of the t=200 microstructure. Fewer nodes results in a rougher structure, and more nodes becomes computationally expensive. Laplacian smoothing can reduce the artificial roughness which is an artifact of the Potts model evolution. Here I show the same t=200 snapshot after Laplacian smoothing, using the \"smooth\" command I recently contributed to the LaGriT toolbox. This new command will be included in the next release (scheduled for October, 1998) of LaGriT, and is currently the only smooth capability in LaGriT which works on both the 2d surface meshes and the 3d volume mesh while preserving constrained interfaces, like the outer geometry of the \"T\" shown here. Laplacian smoothing does not however preserve volumes, but acts in some sense similar to mean-curvature motion in that it will shrink spheres if used iteratively. The version implemented is under-relaxed, and constrained not to invert the volumes of the tetrahedra of the mesh. LaGriT's \"graphmassage\" capability can then be used to reduce the node density and produce a good grid for further finite element computation. Here I show the same t=200 snapshot after massaging the smoothed grid, removing in this case 6 out of 7 nodes. The grid lines are also shown. Using LaGriT's \"graphmassage\" without first smoothing the structure does not yield as nice a grid, as \"graphmassage\" is not designed to smooth interfaces, but rather to preserve their character, as seen in the in the picture below resulting from \"graphmassage\" with the same parameters, but without the Laplacian smooth step. Smoothing after graphmassage also compares unfavorably to smoothing first, and then using graphmassage, as graphmassage with a small damage tolerance will not remove surface nodes on a rough interface, and with a large tolerance can introduce large-scale roughness.",
    "tags": "",
    "url": "/pages/tee.html"
  },{
    "title": "",
    "text": "**Pictures created by Tinka Gammel** Initial (t=0) microstructure for a short metallic line used in the gradient-weighted finite element calculations (b) and (c), generated by discrete Potts evolution of random effective spins on the elements of the tetrahedral LaGriT mesh followed by a few timesteps of evolution under mean curvature to remove discrete artifacts. Microstructure at t=4 when an orientation dependent grain boundary energy is used. Note that while the gross features of (b) and (c) are the same, the mean curvature evolution in (b) accurately reproduces the well-known predictions for mean curvature motion (grains meeting at triple lines with 120 degree angles, etc), whereasthe orientation dependent grainboundary energy used in (c) gives rise to the steps and facets expected for crytalline metals such as Copper. Orientation-dependence of the grain boundary energy between grains 3 and 4 of Figure 1. The figure has the same orientation as Figure 1. The direction to the surface from the center is the direction of the grain boundary normal, and the length of the vector (and color of the surface) gives the magnitude. This surface is different for each grain pair since it is a function of their relative orientations as well as the grain boundary normal dependence shown here. The interactionwith the boundary for this simulation was chosen to be grain and orientation independent. The grains have fcc symmetry and the parameters were chosen to approximate Copper. We are currently investigating ways to more accurately model the orientation dependence within the scope of the finite element calculation.",
    "tags": "",
    "url": "/pages/tinkas.html"
  },{
    "title": "",
    "text": "Mesh Design, why does it matter? Mesh Design, why does it matter? The mesh design is chosen with consideration of the physics to be modeled, mesh size restrictions (number of degrees of freedom) versus mesh resolution needed for model features, and the mesh and model information needed by the model application. For modeling applications with complex stratigraphy, depending on the mesh, you can get a stable but inaccurate solution to the physics (Zyvoloski and Vesselinov, 2006). Choose a mesh design and meshing method that gives the best performance from the modeling application possible, with respect to the difficulty in generating the mesh. LaGriT is used to generate meshes with control volume discretization such that the underlying control volumes are Voronoi tessellations. Developed by Los Alamos National Laboratory as open source software, LaGriT provides a variety of meshing tools with capabilities specific to geologic applications and Voronoi control volume solvers. Examples of methods used for geologic applications include unstructured and structured, both with adaptive refinement to geological features. The unstructured approach allows the creation of meshes that exactly conform to the geometric model, but requires some expertise in building the mesh such that it will also meet the Delaunay criteria. The easier method is to use a structured mesh with fine resolution, or a coarser mesh that uses octree refinement to increase resolution in user specified regions of interest. These result in stair-stepped geometries instead of smooth, but can be acceptable for where the geometry spacing is small relative to the full model domain. (Sentis and Gable, 2017). Tutorials Stratigraphic Hex Mesh Tutorial Complex stratigraphic mesh creation with faults, wells, and subsurface layering Advanced Examples The following are grouped according to the level of complexity. For specific command examples, see the [command index](/pages/commands.md). Select All, or by one of the categories: - Commands are command examples showing a few lines for syntax and usage. - Utility is a set of commands for a particular task. - Demo is a set of commands from start to finish demonstrating a particular method. - Tutorial is a full set of files and commands involving many steps to achieve a final mesh. All Commands Utility Demo Tutorial Create Hex Sphere into Stacked Hex Cylinder Brick Tet Mesh Truncated by Surface Octree 4 Cube Examples Octree Refine Hex using Intersect Object Stacked mesh with Conforming Surfaces Stacked mesh hex-to-tet instead of connect Rotate Cylinder in Box Stacked Mesh with Facesets from Boundary Lines Extract Surfmesh Tet Mesh using Regions and Ray Shooting Tet Mesh using Stratigraphic Surfaces Merge Intersecting Surfaces Extract Face and Node Sets with extract/surfmesh Convert Meters and Feet Reset imt values for truncated mesh Voronoi node attribute addmesh connect 2D connect 3D createpts dump grid2grid hextotet5 negative_aij pset quality recon 2D regnpts rmmat rotatept sort trans triangulate",
    "tags": "",
    "url": "/pages/tutorial/"
  },{
    "title": "Image Gallery",
    "text": "# Image Gallery Gallery written: Fri Aug 9 16:26:43 2019 Image Directory: /project/meshing/demos/Tutorial\\_Hex\\_Mesh/images | | | | | :---: | :---: | :---: | | | | | | **01\\_hex\\_01** | **02\\_hex\\_01\\_top\\_region** | **03\\_hex\\_01\\_2surfs** | | ![](/pages/tutorial/stratigraphy/images/gallery/01_hex_01.png)| ![](/pages/tutorial/stratigraphy/images/gallery/02_hex_01_top_region.png)| ![](/pages/tutorial/stratigraphy/images/gallery/03_hex_01_2surfs.png) | | **03\\_hex\\_01\\_2surfs\\_b** | **03\\_hex\\_01\\_set\\_imt\\_itetclr** | **03\\_hex\\_01\\_set\\_imt\\_itetclr\\_threshold\\_remove\\_material3** | | ![](/pages/tutorial/stratigraphy/images/gallery/03_hex_01_2surfs_b.png)| ![](/pages/tutorial/stratigraphy/images/gallery/03_hex_01_set_imt_itetclr.png)| ![](/pages/tutorial/stratigraphy/images/gallery/03_hex_01_set_imt_itetclr_threshold_remove_material3.png) | | **05\\_hex\\_01\\_fault\\_imt\\_itetclr** | **06\\_boundary\\_truncate** | **07\\_boundary\\_truncate\\_fence** | | ![](/pages/tutorial/stratigraphy/images/gallery/05_hex_01_fault_imt_itetclr.png)| ![](/pages/tutorial/stratigraphy/images/gallery/06_boundary_truncate.png)| ![](/pages/tutorial/stratigraphy/images/gallery/07_boundary_truncate_fence.png) | | **08\\_truncate\\_set\\_id** | **09\\_truncate\\_set\\_id\\_close\\_up** | **10\\_hex\\_01\\_truncate\\_close\\_up** | | ![](/pages/tutorial/stratigraphy/images/gallery/08_truncate_set_id.png)| ![](/pages/tutorial/stratigraphy/images/gallery/09_truncate_set_id_close_up.png)| ![](/pages/tutorial/stratigraphy/images/gallery/10_hex_01_truncate_close_up.png) | | **11\\_hex\\_01\\_truncate** | **12\\_hex\\_01\\_truncate\\_w\\_grid** | **13\\_hex\\_01\\_fault\\_refine** | | ![](/pages/tutorial/stratigraphy/images/gallery/11_hex_01_truncate.png)| ![](/pages/tutorial/stratigraphy/images/gallery/12_hex_01_truncate_w_grid.png)| ![](/pages/tutorial/stratigraphy/images/gallery/13_hex_01_fault_refine.png) | | **14\\_hex\\_01\\_fault\\_refine\\_close\\_up** | **15\\_hex\\_01\\_insert\\_wells** | **16\\_hex\\_01\\_insert\\_wells\\_close\\_up** | | ![](/pages/tutorial/stratigraphy/images/gallery/14_hex_01_fault_refine_close_up.png)| ![](/pages/tutorial/stratigraphy/images/gallery/15_hex_01_insert_wells.png)| ![](/pages/tutorial/stratigraphy/images/gallery/16_hex_01_insert_wells_close_up.png) | | **17\\_hex\\_01\\_insert\\_wells\\_outline** | **18\\_hex\\_01\\_insert\\_wells\\_dfield\\_wells** | **19\\_hex\\_01\\_to\\_tet** | | ![](/pages/tutorial/stratigraphy/images/gallery/17_hex_01_insert_wells_outline.png)| ![](/pages/tutorial/stratigraphy/images/gallery/18_hex_01_insert_wells_dfield_wells.png)| ![](/pages/tutorial/stratigraphy/images/gallery/19_hex_01_to_tet.png) | | **21\\_tet\\_01\\_exo\\_blocks** | **21\\_tet\\_01\\_exo\\_blocks\\_ex** | **21\\_tet\\_01\\_exo\\_bndry\\_faces** | | ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_exo_blocks.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_exo_blocks_ex.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_exo_bndry_faces.png) | | **21\\_tet\\_01\\_fehm\\_node\\_zone\\_rad16** | **21\\_tet\\_01\\_fehm\\_node\\_zone\\_top** | **21\\_tet\\_01\\_fehm\\_nodes** | | ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_node_zone_rad16.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_node_zone_top.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_nodes.png) | | **21\\_tet\\_01\\_fehm\\_tet\\_a** | **21\\_tet\\_01\\_fehm\\_vor\\_a** | **21\\_tet\\_01\\_fehm\\_vor\\_tet\\_a** | | ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_tet_a.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_vor_a.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_vor_tet_a.png) | | **21\\_tet\\_01\\_fehm\\_voronoi** | **21\\_tet\\_01\\_fehm\\_voronoi\\_a** | | ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_voronoi.png)| ![](/pages/tutorial/stratigraphy/images/gallery/21_tet_01_fehm_voronoi_a.png) | End Gallery",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/images/gallery.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial Stratigraphic Hex Mesh Tutorial Download Resources (7.5 MB) In this tutorial, we will be constructing a complex geostratigraphic mesh with a fault, distinct subsurface layering and multiple wells. The goal of this tutorial is to introduce the reader to intermediate and advanced LaGriT topics, including refinement, truncation, point-sets, element-sets and more. Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Well 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 1. Building a Hex Mesh First, we are going to construct a structured hex mesh. The hex mesh will span from 0 meters to 4000 m, 4000 m, and 3000 m, for the x/y/z coordinates respectively. For both consistency and rapid parameter manipulation, these can be stored in variables. In LaGriT, variables are assigned using the `define` keyword. ``` define / X0 / 0. define / X1 / 4000. define / Y0 / 0. define / Y1 / 4000. define / Z0 / 0. define / Z1 / 3000. define / NX / 51 define / NY / 51 define / NZ / 26 define / MONAME / mohex ``` Above, the spatial domain (`X0,X1,Y0,...`), element density (`NX/NY/NZ`), and mesh name (`MONAME`) have been defined. Next, we will create an empty mesh object, with element type `hex`, using the [`cmo / create`](/pages/docs/commands/cmo/cmo_create.html) command: ``` cmo / create / MONAME / / / hex ``` Due to the variable assignment of `MONAME X1`, along with `NY` elements in the Y domain and `NZ` elements in the Z domain. Optionally, [save the mesh object](/pages/docs/commands/DUMP2.html): ``` dump / avs / tmp_hex_01.inp / MONAME ``` This file can be rendered in certain scientific 3D visualization applications, such as [ParaView](https://www.paraview.org). Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_01.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 2. Define Boundaries Using Point Sets In LaGriT, a pset (or *point-set*) is a collection of points (nodes) within a mesh object. Similarly, an eltset (*element-set*) is a collection of mesh elements. By capturing points and elements, discrete manipulations can be performed on them, such as translation, removal, or attribute functions. In this example, point sets are used to create a boundary on the top surface of the created hex mesh. The boundary will be the intersection of three circles on the top layer of the mesh. ``` # Set vertices (imt) and cells (itetlcr) to 1 cmo / setatt / mohex / imt / 1 0 0 / 1 cmo / setatt / mohex / itetclr / 1 0 0 / 1 resetpts / itp ``` Capturing a `pset` is done through the command ``` pset / pset_name / select_type / select_type_options ``` where `pset_name` is an arbitrary variable name to store the pset into, `select_type` is the method of pset selection, and `select_type_options` are parameters specific to the chosen `select_type` for configuring the subset selection (see the [documentation](/pages/docs/commands/PSET.html) for more information). ### 2.1 PSet Definitions As the boundary will live only in the top layer, nodes belonging to the top layer will be identified first. ``` pset / p_top / attribute / zic / 1 0 0 / ge / Z1 ``` Here, a pset named `p_top` is created. This pset contains all nodes (stride = `1 0 0`) where the node's Z value (`zic`) is greater than or equal to (`ge`) the top of the mesh (`Z1`). Remember that we defined `Z1` above for the initial creation of the mesh - and that by simply changing `Z1` and re-running the script, this pset capture will still be valid for any value of `Z1` (where `Z1 > Z0`). Now that the top is defined, we will move to defining three cylindrical objects. This is done through the command ``` pset / pset_name / geom / rtz / ifirst,ilast,istride / r1,t1,z1 / r2,t2,z2 / xcen,ycen,zcen ``` which forms a pset of nodes within the cylinder or cylindrical shell given by radius r1 to r2, angle theta t1 to t2 and height z1 to z2. ``` pset / p_circle1 / geom / rtz / 1 0 0 / 0. 0. -1.0 / & 1100. 360. 1.e4 / 1500. 1500. 0. pset / p_circle2 / geom / rtz / 1 0 0 / 0. 0. -1.0 / & 1100. 360. 1.e4 / 2500. 2500. 0. pset / p_circle3 / geom / rtz / 1 0 0 / 0. 0. -1.0 / & 1100. 360. 1.e4 / 2500. 1500. 0. ``` Above, any points within a full circle (theta = `360`) of radius `1100.` and within `Z={-1.0,1.e4}` are captured. Three different cylinders are created, where only the centroids change. Finally, all four psets are intersected such that all points belonging to the union of all given sets are preserved into the point seet `p_region`: ``` pset / p_region / inter / p_top p_circle1 p_circle2 p_circle3 ``` This creates a point-set where all points (i) live on the top layer, and (ii) live within the intersection of the three cylinders. ### 2.2 Map PSets to an Attribute As a simple sanity check during meshing, it can be helpful to map mesh operations to an attribute. These can be visualized at intermediate steps in the meshing process to provide a form of verification or debugging. First, create an attribute using the `cmo / addatt` command: ``` cmo / addatt / MONAME / id_top_region / vint / scalar / nnodes ``` Here, an attribute named `id_top_region` is created within the mesh `MONAME`, and has type integer (`vint`), is of scalar dimensions, and is a node-based attribute (`nnodes`). The attribute can be progressively filled in with different values based on the psets: ``` # Fill the entire attribute with 1 cmo / setatt / MONAME / id_top_region / 1 0 0 / 1 # Color all nodes in the pset p_circle1 with the value 2 cmo / setatt / MONAME / id_top_region / pset get p_circle1 / 2 # Color all nodes in the pset p_circle2 with the value 2 cmo / setatt / MONAME / id_top_region / pset get p_circle2 / 3 # And so on... cmo / setatt / MONAME / id_top_region / pset get p_circle3 / 4 cmo / setatt / MONAME / id_top_region / pset get p_region / 5 ``` Finally, release the psets from memory: ``` pset / p_top / release pset / p_circle1 / release pset / p_circle2 / release pset / p_circle3 / release pset / p_region / release ``` Cutting through the mesh in ParaView, we can visualize `id_top_region` and validate that the mesh is being constructed as expected: Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_02.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 3. Constructing Stratigraphy In the next step of this tutorial, we will build some surfaces to define stratigraphy. In a real model, the surfaces would come from some geologic framework model and would define geologic or hydro-geologic horizons and topography. These surfaces will be planar quad meshes that cut through a defined section of the hex mesh. Later, we will map the intersections of the surfaces to the hex mesh. #### Create the top surface: ``` cmo / create / mosurf1 cmo / select / mosurf1 define / X0S / -20.0 define / X1S / 4020.0 define / Y0S / -20.0 define / Y1S / 4020.0 define / Z1 / 1000. define / Z2 / 1500. define / Z3 / 2500. define / Z4 / 500. quadxy / NX NY /X0S Y0S Z1/X1S Y0S Z2/X1S Y1S Z3/X0S Y1S Z4 createpts/brick/xyz/ NX NY 1 /1,0,0/connect ``` Note that the X and Y domains of the quad mesh exceed that of the hex mesh. This serves two purposes. First, it serves as a helpful visualization aid, allowing one to easily see how the surfaces cut the hex mesh without adjusting opacity. Second, and more importantly, it ensures that all elements cut by the surfaces will be properly recognized as such. Rounding errors may affect elements at the perimeter of the cutting planes from being properly labeled. #### Create the bottom surface: ``` cmo / create / mosurf2 cmo / select / mosurf2 define / Z1 / 1800. define / Z2 / 2100. define / Z3 / 2800. define / Z4 / 800. quadxy / NX NY /X0S Y0S Z1/X1S Y0S Z2/X1S Y1S Z3/X0S Y1S Z4 createpts/brick/xyz/ NX NY 1 /1,0,0/connect ``` Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_03.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 4. Map Surfaces to Mesh Now that the straitipgrahy has been modeled and we are comfortable with our results, we will map their spanning domain to the parent mesh. As done with the psets above, this process will be driven via attributes. We now have two planes spanning the X,Y domain of the mesh. These planes can be leveraged to create different material IDs at different regions of the subsurface. For example, * For all nodes/cells above plane 1, set their material ID to 1 * For all nodes/cells between plane 1 and plane 2, set their material ID to 2 * For all nodes/cells below plane 2, set their material ID to 3 This process can be accomplished by: 1. Defining the above regions using the `region` keyword 2. Capturing the relevant nodes and elements that fall within the defined regions 3. Setting the node and element material IDs based on the `psets` and `eltsets` ### 4.1 Defining Regions The syntax for `region` is: region / region_name / region_definition where `region_definition` is a string composed of boolean operators and instantiated `surface` objects. Recall that we have defined two planes, `mosurf1` and `mosurf2`. We would like to generate the `region` objects from these planes, but the arguments for `region` require `surface` objects. Fortunately, we can map the planes to a `surface` very easily. The syntax for generating a `surface` object from a quad or triangle mesh is: surface / surface_name / reflect / sheet / input_mesh The two planes can then be mapped to surface objects: ``` surface / s_1 / reflect / sheet / mosurf1 surface / s_2 / reflect / sheet / mosurf2 ``` And finally, we can remove the plane meshes and define regions: ``` cmo / delete / mosurf1 cmo / delete / mosurf2 cmo / select / MONAME region / r_1 / le s_1 region / r_2 / gt s_1 and le s_2 region / r_3 / gt s_2 ``` ### 4.2 Creating Eltsets and PSets from Regions Point sets and element sets can easily be created through region objects. The syntax is: pset / pset_name / region / region_object / 1,0,0 eltset / eltset_name / region / region_object Applying this to our `region` objects yields: ``` pset / p_r_1 / region / r_1 / 1 0 0 pset / p_r_2 / region / r_2 / 1 0 0 pset / p_r_3 / region / r_3 / 1 0 0 eltset / e_r_1 / region / r_1 eltset / e_r_2 / region / r_2 eltset / e_r_3 / region / r_3 ``` ### 4.3 Setting Attributes from Eltsets and PSets Recall that the node attribute `imt` holds the 'node colors' of the mesh, and cell attribute `itetclr` stores the 'cell colors' (or material ID). Let's use the defined `pset`s and `eltset`s to change these: ``` cmo / setatt / MONAME / imt / pset get p_r_1 / 1 cmo / setatt / MONAME / imt / pset get p_r_2 / 2 cmo / setatt / MONAME / imt / pset get p_r_3 / 3 cmo / setatt / MONAME / itetclr / eltset get e_r_1 / 1 cmo / setatt / MONAME / itetclr / eltset get e_r_2 / 2 cmo / setatt / MONAME / itetclr / eltset get e_r_3 / 3 ``` Our mesh's cells and nodes now store information about their intersections with the cut-planes. Visualizing `itetclr`, we can see that this has behaved as expected: Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_04.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 5. Constructing a Fault and Layers ### 5.1 Creating a Fault and Subsurface Layers Next, we are going to map a fault and surfaces to our mesh. The objects created will be: For all five of these surfaces, we will: 1. Define the X,Y,Z extent 2. Use `quadxy` to generate the point distribution 3. Connect the points into a quad mesh using `createpts/brick`. For the main fault mesh, this process looks like: ``` cmo / create / mosurf_fault cmo / select / mosurf_fault define / X0S / -20.0 define / X1S / 4020.0 define / Y0S / -20.0 define / Y1S / 4020.0 define / Z1 / -1.e4 define / Z2 / -1.e4 define / Z3 / 1.e4 define / Z4 / 1.e4 quadxy / NX NY /X0S Y0S Z1/X1S Y0S Z2/X1S Y1S Z3/X0S Y1S Z4 createpts/brick/xyz/ NX NY 1 /1,0,0/connect cmo / printatt / mosurf / -xyz- / minmax ``` For the remaining four surfaces this process is repeated, with `Z1,Z2,Z3,Z4` altered independently. The created surfaces have the names `mosurf1_fminus`, `mosurf2_fminus`, `mosurf1_fplus`, `mosurf2_fplus`, and `mosurf_fault`. ### 5.2 Define Geometry of Hydrostratigraphic Model Recall in step 4 how we used two surface meshes to alter `imt` and `itetclr` values: first, by defining `surfaces` from the planar meshes; second, using the `surface` objects to define `region` objects; third, creating `psets` and `eltsets` from the `regions`; and finally, by modifying `itetclr` and `imt` through the defined `psets` and `eltsets`. This process is replicated here. First, by creating the `surfaces`: ``` surface / s_1_fm / reflect / sheet / mosurf1_fminus surface / s_2_fm / reflect / sheet / mosurf2_fminus surface / s_1_fp / reflect / sheet / mosurf1_fplus surface / s_2_fp / reflect / sheet / mosurf2_fplus surface / s_f / reflect / sheet / mosurf_fault ``` Then, by mapping the surfaces to regions (and deleting the planar meshes to free up memory): ``` region / r_1_fm / le s_1_fm and le s_f region / r_2_fm / gt s_1_fm and le s_2_fm and le s_f region / r_3_fm / gt s_2_fm and le s_f region / r_1_fp / le s_1_fp and gt s_f region / r_2_fp / gt s_1_fp and le s_2_fp and gt s_f region / r_3_fp / gt s_2_fp and gt s_f cmo / delete / mosurf1_fminus cmo / delete / mosurf2_fminus cmo / delete / mosurf1_fplus cmo / delete / mosurf2_fplus cmo / delete / mosurf_fault ``` And finally, by creating `psets` and `eltsets` and using them to modify material attributes of the parent mesh: ``` pset / p_r_1_fm / region / r_1_fm / 1 0 0 pset / p_r_2_fm / region / r_2_fm / 1 0 0 pset / p_r_3_fm / region / r_3_fm / 1 0 0 pset / p_r_1_fp / region / r_1_fp / 1 0 0 pset / p_r_2_fp / region / r_2_fp / 1 0 0 pset / p_r_3_fp / region / r_3_fp / 1 0 0 eltset / e_r_1_fm / region / r_1_fm eltset / e_r_2_fm / region / r_2_fm eltset / e_r_3_fm / region / r_3_fm eltset / e_r_1_fp / region / r_1_fp eltset / e_r_2_fp / region / r_2_fp eltset / e_r_3_fp / region / r_3_fp cmo / setatt / MONAME / imt / 1 0 0 / 7 cmo / setatt / MONAME / itetclr / 1 0 0 / 7 cmo / setatt / MONAME / imt / pset get p_r_1_fm / 1 cmo / setatt / MONAME / imt / pset get p_r_2_fm / 2 cmo / setatt / MONAME / imt / pset get p_r_3_fm / 3 cmo / setatt / MONAME / imt / pset get p_r_1_fp / 4 cmo / setatt / MONAME / imt / pset get p_r_2_fp / 5 cmo / setatt / MONAME / imt / pset get p_r_3_fp / 6 cmo / setatt / MONAME / itetclr / eltset get e_r_1_fm / 1 cmo / setatt / MONAME / itetclr / eltset get e_r_2_fm / 2 cmo / setatt / MONAME / itetclr / eltset get e_r_3_fm / 3 cmo / setatt / MONAME / itetclr / eltset get e_r_1_fp / 4 cmo / setatt / MONAME / itetclr / eltset get e_r_2_fp / 5 cmo / setatt / MONAME / itetclr / eltset get e_r_3_fp / 6 ``` The six distinct regions can now be seen by viewing `itetclr` on the parent mesh: Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_05.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 6. Truncate with Polyline ### 6.1 Create boundary surface We now have a mesh with complex stratigraphy encoded in its material ID. However, the domain of this mesh is a rather boring cuboid and doesn't accurately reflect the geospatial domain that we are trying to model. By importing a polyline, the exterior boundary of the mesh can be truncated. As in previous steps, we will use a mesh to define a `region` that will be used for element-wise operations. However, the boundary is a line object. In order to use it as a surface/region, it must be a surface. A polyline can be turned into a vertical surface by 'extruding' it in the vertical (0,0,1) direction: ``` read / avs / basin_bnd_ply_rescale.inp / mo_bndry extrude / mo_fence / mo_bndry / const / 3200. / volume / 0. 0. -1. ``` We will also translate the extrusion so that it covers the vertical extent of the hex mesh: ``` trans / 1 0 0 / 0. 0. -3200. / 0. 0. 0. ``` ### 6.2 Truncate mesh Next, we use the boundary to truncate (remove) cells outside the boundary. There are three ways to define 'outside': 1. Only remove a cell if ALL vertices are outside 2. Remove a cell if the centroid (average of all vertices) is outside 3. Remove a cell if one or more vertices are outside ``` cmo / select / MONAME surface / s_bndry / reflect / sheet / mo_fence cmo / select / MONAME region / r_bndry / ge s_bndry pset / p_bndry / region r_bndry ``` **Method 1:** eltset / e_delete1 / exclusive / pset get p_bndry **Method 2:** eltset / e_delete2 / region r_bndry **Method 3:** eltset / e_delete3 / inclusive / pset get p_bndry Next, add the integer cell attribute `id_in_out_bndry`: cmo / addatt / MONAME / id_in_out_bndry / vint / scalar / nelements and 'color' it based on the three element sets created above: ``` cmo / setatt / MONAME / id_in_out_bndry / 1 0 0 / 4 cmo / setatt / MONAME / id_in_out_bndry / eltset get e_delete3 / 3 cmo / setatt / MONAME / id_in_out_bndry / eltset get e_delete2 / 2 cmo / setatt / MONAME / id_in_out_bndry / eltset get e_delete1 / 1 ``` All elements colored 4 (the default value for `id_in_out_bndry`) are elements who evaluate false for all of the above `eltsets`. Create an element set for all `id_in_out_bndry(cell_i) == 4`: ``` eltset / e_delete4 / id_in_out_bndry / eq / 4 eltset / e_delete3 / id_in_out_bndry / eq / 3 eltset / e_delete2 / id_in_out_bndry / eq / 2 eltset / e_delete1 / id_in_out_bndry / eq / 1 ``` Finally, remove all elements 'colored' by method 3 and all elements *not* colored by any of methods 1, 2, or 3: ``` rmpoint / element / eltset get e_delete4 rmpoint / element / eltset get e_delete3 rmpoint / compress resetpts / itp ``` Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_06.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 7. Refine Fault In step 5, we defined a fault surface (named `s_f`) intersecting the mesh. In this section, we are going to refine the mesh where the fault intersects it. The LaGriT command `intersect_elements` takes two meshes and creates an element-based attribute in mesh1 that contains the number of elements in mesh2 that intersected the respective element in mesh1. Performing the intersection between the mesh `MONAME` and fault `s_f`, storing the intersection count in attribute `if_inter`: ``` cmo / select / MONAME intersect_elements / MONAME / s_f / if_inter ``` The attribute `if_inter` will be non-zero everywhere there is an intersection, and zero where there was not intersection. Taking advantage of this fact, we can create an eltset to refine: ``` eltset / e_refine / if_inter / gt / 0 refine / eltset / eltset get e_refine cmo / DELATT / MONAME / if_inter ``` The element density has now increased where the mesh intersects `s_f`. We can then run this step *again*, further refining elements along that intersection: ``` intersect_elements / MONAME / s_f / if_inter eltset / e_refine / if_inter / gt / 0 refine/ eltset / eltset get e_refine cmo / setatt / MONAME / if_inter / 1 0 0 / 0 ``` And finally, remove the attribute `if_inter`, as it is no longer needed: ``` cmo / DELATT / MONAME / if_inter ``` At this point, many different mesh objects and surfaces still exist in memory from previous steps. Let's deallocate them and verify with the `memory` command: ``` cmo / status / brief cmo / status / MONAME memory / verify memory / print cmo / delete / s_bndry cmo / delete / mo_fence cmo / delete / mo_bndry cmo / delete / s_f cmo / delete / s_2_fp cmo / delete / s_1_fp cmo / delete / s_2_fm cmo / delete / s_1_fm cmo / delete / s_2 cmo / delete / s_1 memory / verify memory / print ``` Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_07.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 8. Insert Wells In this step, we will generate two cylindrical 'wells', refine the mesh `MONAME` around them, and identify a line of nodes that will be the well source/sink for boundary conditions (ultimately writing these nodes to `zone` files). ### 8.1 Generating Cylindrical Tetrahedral Wells First, we define variables for the well's position (`XWELL`,`YWELL`), radius (`RADIUS_WELL`), and number of nodes across the cylindrical radius (`NRADIUS`): ``` define / XWELL1 / 1234.56 define / YWELL1 / 1987.65 define / XWELL2 / 2243.21 define / YWELL2 / 1212.34 define / RADIUS_WELL / 25.0 define / NRADIUS / 2 ``` Now, we create a cylindrical point cloud defining the first well using `createpts / rtz`: ``` cmo / create / mo_well1 / / / tet createpts / rtz / NRADIUS 9 NZ / 0. 0. 3100. / RADIUS_WELL 360. 1500. / 1 1 1 ``` This creates a point cloud centered around (0,0,0) with a radius of `RADIUS_WELL`, an angular component spanning a full 360 degrees (`φ = {0., 360.}`), and a Z range of `{3100.,1500.}`. Run `filter`, `rmpoint / compress`, and set `imt` to 1 for the well: ``` filter / 1 0 0 rmpoint / compress cmo / setatt / mo_well1 / imt / 1 0 0 / 1 ``` Next, connect the point cloud into a tetrahedral mesh and translate the X and Y origin to `{XWELL1,YWELL1}`: ``` connect resetpts / itp cmo / printatt / mo_well1 / -xyz- / minmax trans / 1 0 0 / 0. 0. 0. / XWELL1 YWELL1 0.0 cmo / printatt / mo_well1 / -xyz- / minmax ``` The first 'well' mesh object has been generated. Repeat this process with different parameters to create the second well: ``` cmo / create / mo_well2 / / / tet createpts / rtz / NRADIUS 9 NZ / 0. 0. 3100. / RADIUS_WELL 360. 2200. / 1 1 1 filter / 1 0 0 rmpoint / compress cmo / setatt / mo_well1 / imt / 1 0 0 / 1 connect resetpts / itp cmo / printatt / mo_well2 / -xyz- / minmax trans / 1 0 0 / 0. 0. 0. / XWELL2 YWELL2 0.0 cmo / printatt / mo_well2 / -xyz- / minmax ``` Finally, join the two distinct wells into a single mesh object with `addmesh / merge`: ``` addmesh / merge / mo_wells / mo_well1 mo_well2 ``` ### 8.2 Refining `MONAME` around the wells As we did for the fault in step 7, we refine the main mesh `MONAME` around the wells: ``` # First pass refinement cmo / select / MONAME intersect_elements / MONAME / mo_wells / if_inter eltset / e_refine / if_inter / gt / 0 refine/ eltset / eltset get e_refine cmo / setatt / MONAME / if_inter / 1 0 0 / 0 eltset / e_refine / delete # Second pass refinement cmo / select / MONAME intersect_elements / MONAME / mo_wells / if_inter eltset / e_refine / if_inter / gt / 0 refine/ eltset / eltset get e_refine cmo / setatt / MONAME / if_inter / 1 0 0 / 0 eltset / e_refine / delete # Third pass refinement cmo / select / MONAME intersect_elements / MONAME / mo_wells / if_inter eltset / e_refine / if_inter / gt / 0 refine/ eltset / eltset get e_refine cmo / setatt / MONAME / if_inter / 1 0 0 / 0 eltset / e_refine / delete ``` The refinement process returns a octree grid object, which stores information about parent-children relationships, among other properties. It's important, as the prepare to finalize the mesh for exporting, to strip this information and convert the octree grid object to a standard mesh object. This conversion is done through the `grid2grid / tree_to_fe` command: ``` grid2grid / tree_to_fe / mohex_octree / mohex define / MONAME / mohex_octree ``` ### 8.3 Writing `zone` files based on well distances The `zone` files are lists of node numbers in [FEHM](https://fehm.lanl.gov) file format and used to identify materials, well source/sinks, and boundary conditions. In this subsection, we will generate `zone` files describing all nodes within 32, 16, 8, 4, 2 and 1 meters of the wells. To begin, we will compute the well point cloud again, as we did above. First, for well 1: ``` cmo / create / mo_pts1 createpts / rtz / 2 2 1000 / 0. 0. 3100. / 0.0 360. 2200. / 1 1 1 trans / 1 0 0 / 0. 0. 0. / XWELL1 YWELL1 0.0 ``` Then for well 2: ``` cmo / create / mo_pts2 createpts / rtz / 2 2 1000 / 0. 0. 3100. / 0.0 360. 2200. / 1 1 1 trans / 1 0 0 / 0. 0. 0. / XWELL2 YWELL2 0.0 ``` and joining them into a single mesh object, `mo_pts`: ``` addmesh / merge / mo_pts / mo_pts1 / mo_pts2 cmo / select / mo_pts filter / 1 0 0 rmpoint / compress ``` Next, we will compute a distance field attribute, `dfield_well`, which is a node-based attribute storing the Euclidean distance from `node_i` in one mesh to the closest node in another mesh. In other words, all nodes in `MONAME` store their distance to the closest well (`mo_pts`) node. ``` compute / distance_field / MONAME / mo_pts / dfield_well ``` Clean up unneeded mesh objects: ``` cmo / delete / mo_pts1 cmo / delete / mo_pts2 cmo / delete / mo_pts cmo / delete / mo_wells cmo / delete / mo_well1 cmo / delete / mo_well2 ``` And finally, for each mesh-to-well distance in {32,16,8,4,2,1} (which is stored in `dfield_well`), (i) create a pset object containing all nodes within that distance, and (ii) write those nodes to a `zone` file: ``` cmo / select / MONAME pset / pwell / attribute / dfield_well / 1 0 0 / le / 1.0 pset / pwell / zone / zone_radius_01.0.zone pset / pwell / attribute / dfield_well / 1 0 0 / le / 2.0 pset / pwell / zone / zone_radius_02.0.zone pset / pwell / attribute / dfield_well / 1 0 0 / le / 4.0 pset / pwell / zone / zone_radius_04.0.zone pset / pwell / attribute / dfield_well / 1 0 0 / le / 8.0 pset / pwell / zone / zone_radius_08.0.zone pset / pwell / attribute / dfield_well / 1 0 0 / le / 16.0 pset / pwell / zone / zone_radius_16.0.zone pset / pwell / attribute / dfield_well / 1 0 0 / le / 32.0 pset / pwell / zone / zone_radius_32.0.zone ``` Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_08.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 9. Convert Hex Mesh to Tet In this final step, we will convert our mesh from hexahedral to tetrahedral elements. Create an empty mesh object, `motet`, and copy all nodes from `MONAME` (or, `mohex_octree`) to `motet`: ``` cmo / create / motet copypts / motet / mohex_octree ``` Next, reset the `imt` and `itp` variables and connect the nodes into tetrahedral elements: ``` cmo / setatt / motet / imt / 1 0 0 / 1 cmo / setatt / motet / itp / 1 0 0 / 0 connect resetpts / itp ``` Interpolate the node and cell 'colors' over the tetrahedral mesh, using `interpolate / voronoi` for node-to-node interpolations, and `interpolate / map` for cell-to-cell interpolations: ``` interpolate / voronoi / motet / imt / 1 0 0 / mohex_octree / imt interpolate / map / motet / itetclr / 1 0 0 / mohex_octree / itetclr ``` Recall in step 5 that we set `imt` and `itetclr` to the value 7 for all nodes and elements that weren't captured by the surface-created element sets. We can use the command `rmmat / 7` to remove all nodes and elements with `imt` and `itetclr` values of 7: ``` rmmat / 7 rmpoint / compress resetpts / itp ``` Check the mesh that it has all positive element volumes and no bad aspect ratios. Use the `quality` command for a report on these mesh quantities. ``` quality epsilonl, epsilonaspect: 1.3230281E-09 2.3158330E-27 -------------------------------------------- elements with aspect ratio Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_09.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 10.2 Write ExodusII Files Write the tet mesh in Exodus II format. This format defines materials as blocks and is element based. The node properties will be ignored. The below image shows the Exodus mesh (read with GMV or ParaView) with material blocks shown in 'exploded' view. We can define the boundary faces for this mesh by extracting the 2D external surface and writing the element and face id for each. These can be written as sets based on element selection. In this example we use `settets/normal` to assign values 1-6 to the faces based on normal directions where `1=bot`, `2=top`, `3=right`, `4=back`, `5=left`, `6=front`. Define element sets for top, bottom, and lump sides all together for set 3. Write the faceset relation for each element set. ``` define / FILENAME / ss3_sides.faceset define / SS_ID / 3 cmo / copy / mo_tmp / mo_surf cmo / select / mo_tmp eltset / e_keep / itetclr / eq / SS_ID eltset / e_delete / not / e_keep rmpoint / element / eltset get e_delete rmpoint / compress dump / avs2 / FILENAME / mo_tmp / 0 0 0 2 cmo / delete / mo_tmp define / FILENAME / ss1_bottom.faceset define / SS_ID / 1 cmo / copy / mo_tmp / mo_surf cmo / select / mo_tmp eltset / e_keep / itetclr / eq / SS_ID eltset / e_delete / not / e_keep rmpoint / element / eltset get e_delete rmpoint / compress dump / avs2 / FILENAME / mo_tmp / 0 0 0 2 cmo / delete / mo_tmp define / FILENAME / ss2_top.faceset define / SS_ID / 2 cmo / copy / mo_tmp / mo_surf cmo / select / mo_tmp eltset / e_keep / itetclr / eq / SS_ID eltset / e_delete / not / e_keep rmpoint / element / eltset get e_delete rmpoint / compress dump / avs2 / FILENAME / mo_tmp / 0 0 0 2 cmo / delete / mo_tmp ``` Write the Exodus II mesh with the faceset files. This mesh and associated face sets can be viewed with GMV or ParaView. ``` dump/exo/ mesh_fs.exo / MO_MESH / / / facesets & ss1_bottom.faceset, ss2_top.faceset, ss3_sides.faceset ``` Check the summary report to see that mesh quantities are as expected. The report shows 6 element blocks (materials) and 3 side sets with appropriate face counts. ``` Title: LAGRIT TO EXODUSII number of dimension: 3 number of nodes: 115547 number of elements: 651950 number of edges: 0 number of edge blocks: 0 number of element blocks: 6 number of face blocks: 0 number of node sets: 0 number of edge sets: 0 number of element sets: 0 number of side sets: 3 number of face sets: 0 number of node maps: 0 number of edge maps: 0 number of face maps: 0 number of element maps: 0 ------------------------------------------ EXPSS loop: 1 Side Set tag: 1 Faces: 4098 2 Side Set tag: 2 Faces: 4640 3 Side Set tag: 3 Faces: 11812 ------------------------------------------ Done ExodusII Side Sets Total: 3 ``` Image show the Exodus face sets (side sets) with bottom (blue), top (red), and sides (light blue). Previous Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_10_exo.html"
  },{
    "title": "",
    "text": "Tutorials &amp; Examples Stratigraphic Hex Mesh Tutorial 10. Write FEHM Files Write out a series of files for the FEHM flow and transport code. FEHM uses the control volume finite element method (CVFE) with node materials and properties assigned to the mesh nodes. The image shows the tetrahedral mesh colored by the 6 node `imt` (materials) values and showing the voronoi cell edges. These two close-up images show the relationship between the Delaunay tet mesh edges and the voronoi volumes, the latter of which are used by FEHM. The mesh nodes are the vertices of the tetrahedral elements and are the center of each voronoi volume. We prepare the tet mesh for FEHM with the following commands. These ensure that there are no duplicate nodes and sets the elements to a single material. We also make sure nodes are not doubly defined and parent-child chains are removed. ``` cmo/select/motet resetpts/parent filter/1,0,0 rmpoint/compress ``` LaGriT can write a full set of FEHM model files with a single command. The `keepatt` option will save attributes tagging nodes on the outside boundaries. These can be used to define additional point sets and zones for FEHM. The following files are written: * `.fehm` - mesh coordinates and geometry * `_material.zone` - node imt (material) zone lists * `_outside.zone` - node external boundary zone lists * `_outside_vor.area` - node external boundary area lists * `_interface.zone` - zone lists for nodes along material interfaces * `_multi_mat.zone` - lists of node pairs connected across material interfaces * `.stor` - FEHM format file giving the voronoi (control volume) associated with each node and the sparce matrix structure ``` dump / fehm / mesh / motet / keepatt ``` Review the report written to the screen and the output file (`lagrit.out`) for mesh quantities. These are usful summaries and will help in finding problems in the mesh design. Check that material node counts are as expected. ``` *** Write FEHMN GEOM AND ZONE FILES *** *********dump_material_lists******** Minimum material ID value = 1 Maximum material ID value = 6 Total possible materials = 6 Material 1 has 23944 nodes. #nodes/nnodes is 0.207223027945 Material 2 has 6867 nodes. #nodes/nnodes is 0.594303607941E-01 Material 3 has 16072 nodes. #nodes/nnodes is 0.139094918966 Material 4 has 33192 nodes. #nodes/nnodes is 0.287259727716 Material 5 has 12871 nodes. #nodes/nnodes is 0.111391901970 Material 6 has 22601 nodes. #nodes/nnodes is 0.195600062609 ``` Check that the Sparse Matrix volumes are positive. Negative coefficient values can result from poorly formed tetrahedra. These usually occur on non-convex boundaries. FEHM will still run but accuracy may be impacted. ``` *** Construct and Compress Sparse Matrix:3D *** *** Compress Area Coefficient Values *** AMatbld3d_stor: Matrix compress_eps: 0.1000000E-07 AMatbld3d_stor: Local epsilon: 0.1000000E-14 AMatbld3d_stor: *****Zero Negative Coefficients ****** AMatbld3d_stor: Number of 'zero' ( Previous Next Index 1. Building a Hex Mesh 2. Define Boundaries Using Point Sets 3. Constructing Stratigraphy 4. Map Surfaces to Mesh 5. Constructing a Fault 6. Truncate with Polyline 7. Refine Fault 8. Insert Wells 9. Convert Hex Mesh to Tet 10.1 Write FEHM Files 10.2 Write ExodusII Files Image Gallery Report issue Get help",
    "tags": "",
    "url": "/pages/tutorial/stratigraphy/step_10_fehm.html"
  },{
    "title": "Add Node attribute voronoi volume",
    "text": "# Add Node attribute voronoi volume For a tet or tri mesh, an attribute can be added for each node giving the voronoi volume. This uses the same routine used to calculate voronoi volumes for the FEHM stor file. The commands for 3D tet and 2D tri are slightly different. ## 2D Voronoi area node attribute We do not have a voronoi area option for 2D except as represented each of the x y z components for the Voronoi areas formed by the nodes. As long your surface is planar, you will get the values you want. That is if your surface has normal in z direction, the z component will be your voronoi area. In this example we create the attributes xvarea, yvarea, zvarea and write a truncated AVS file which writes only node attributes. The file can be written for all nodes, or just a selected set. After reading the tri surface into a mesh object named *mo_tri*: ``` # add attribute to save node id as attribute # this is important if you subset or re-order nodes cmo/set_id/mo_tri/ node / id_node # create 3 attributes with voronoi areas cmo/addatt/mo_tri/ voronoi_varea / xvarea yvarea zvarea # display the min and max values of attributes cmo printatt mo_tri -all- minmax # turn off extra attributes for writing cmo/modatt/mo_tri/ itp / ioflag / l cmo/modatt/mo_tri/ isn / ioflag / l cmo/modatt/mo_tri/ icr / ioflag / l # write node attributes with avs flag dump/avs/node_values.dat/ mo_tri 0 0 1 0 # find nodes along well and subset to the well nodes # we copy nodes to new cmo to remove connectivity cmo/create/motmp copypts/motmp/mo_tri cmo/select/motmp pset/pwell/attribute imt/1,0,0/ eq 4 pset/pdel/ not pwell rmpoint/pset,get,pdel rmpoint compress dump/avs/node_well_values.dat/ motmp 0 0 1 0 finish ``` The output AVS attribute file will look similar to this with attribute names first, and the attribute values for rest of file. In this example the triangle surface is xz, so voronoi areas are in yvarea attribute. If you have a planar mesh, only one component of the xvarea, yvarea, zvarea will be non-zero. You can turn off all the attributes you don’t want so that when you write out the AVS attributes file it will just be a single column of floating point values, or perhaps more useful would be a file with two columns of output where column 1 would be the integer vertex id number and the second column would be the floating point area. node_well_values.dat 0 0 5 0 0 00005 1 1 1 1 1 imt1, integer id_node, integer xvarea, real yvarea, real zvarea, real 1 4 182 0.000000000000E+00 -0.100000000000E+05 0.000000000000E+00 2 4 210 0.000000000000E+00 -0.100000000000E+05 0.000000000000E+00 3 4 238 0.000000000000E+00 -0.100000000000E+05 0.000000000000E+00 4 4 266 0.000000000000E+00 -0.100000000000E+05 0.000000000000E+00 ## 3D Voronoi volume node attribute The following will create a node attribute with the voronoi volume for each tet node. The mesh object name is *cmotet* and the added attribute name is *vorvol*. ``` quality cmo/addatt/cmotet/vor_volume/vorvol cmo/printatt/cmotet/vovol/minmax # select set of points by imt and sum voronoi volume cmo setatt cmotet vol_tot 0. pset/p1/attribute imt/1,0,0/ eq MATNO math/sum/cmotet/vol_tot/pset,get,p1/cmotet/vorvol pset/p1/delete ```",
    "tags": "",
    "url": "/pages/tutorial/utility/cmo_addatt_vorvol.html"
  },{
    "title": "Convert Between Feet and Meters",
    "text": "# Convert Between Feet and Meters This is a short macro that can be used to convert a mesh's node coordinate space from feet to meters or vice-versa. ``` # Convert feet to meters. scale / 1 0 0 / relative / xyz / 0.3048 0.3048 0.3048 # Meters to Feet: *(1/.3048) = 3.280839895... math / divide / -def- / xic / 1 0 0 / -def- / xic / 0.3048 math / divide / -def- / yic / 1 0 0 / -def- / yic / 0.3048 math / divide / -def- / zic / 1 0 0 / -def- / zic / 0.3048 ```",
    "tags": "",
    "url": "/pages/tutorial/utility/convert_feet_to_meters.html"
  },{
    "title": "reset imt values of truncated mesh",
    "text": "# reset imt values of truncated mesh Source imt values are the truncated imt values minus the node values that need to be reset. This example removes materials greater than MAX_MAT. The removal can leave behind node values that need to be reset. We do not want to remove the nodes as we want to keep these cells. Main command file with the truncation calls: ``` # truncate top of mesh, remove materials gt 8 define CMO cmotet define MAX_MAT 8 eltset/edel/ itetclr / gt MAX_MAT rmpoint element eltset,get,edel rmpoint/compress resetpts/itp # FIX imt of nodes left behind after removal of cells infile reset_truncated_nodes_imt.mlgi ``` Macro File reset_truncated_nodes_imt.mlgi: ``` # macro to fix node imt values left over from truncation # must define CMO when calling this macro # must define MAX_MAT # create set of points with good values # fix using nearest interpolation from good set cmo/create/cmotmp copypts/cmotmp/CMO cmo/select/cmotmp pset/pbad/attribute imt/1,0,0/gt MAX_MAT rmpoint/pset,get,pbad rmpoint/compress cmo/select/CMO pset/pfix/attribute imt/1,0,0/gt MAX_MAT interpolate/voronoi/CMO imt/pset,get,pfix/ cmotmp imt cmo/delete/cmotmp cmo/printatt/CMO/imt minmax finish ```",
    "tags": "",
    "url": "/pages/tutorial/utility/reset_truncated_nodes_imt.html"
  },{
    "title": "Utility Subroutines",
    "text": "Utility Subroutines ------------------- 1. [Memory Manager](/pages/docs/memmang.html) (mmgetblk, mmrelblk, mmrelprt, mmincblk, mmfindbk, mmgettyp, mmgetlen, mmgetnam, mmprint, mmverify, mmggetbk) 2. [Mesh Objects](/pages/docs/meshob.html) (cmo\\_create, cmo\\_get\\_info, cmo\\_set\\_info, cmo\\_get\\_name, cmo\\_set\\_name, cmo\\_get\\_attribute\\_name, cmo\\_newlen, cmo\\_get\\_intinfo, cmo\\_release, cmo\\_get\\_attinfo, cmo\\_get\\_length, cmo\\_set\\_attinfo, cmo\\_get\\_attparam) 3. [Point Selection](/pages/docs/pointsel.html) (getptyp, unpackpc, unpacktp) 4. [Character Length](/pages/docs/charlen.html)   (icharln, icharlnf, icharlnb, nulltoblank\\_lg) 5. [Retrieving Point Sets and Element Sets ](/pages/docs/retpts.html) (eltlimc, pntlimc, pntlimn) 6. [Array Compression](/pages/docs/arrcomp.html) (kmprsm, kmprsn, kmprsnr, kmprsnrrr, kmprsp, kmprspr, kmprsz, kmprszr) 7. [Array Sorting](/pages/docs/arrsort.html) (hpsort, hpsort1, hpsorti, hpsortim, hpsortimp, hpsortip, hpsortrmp) 8. [Miscellaneous](/pages/docs/miscell.html) (setsize, set\\_user\\_bounds, inside, volume\\_element, user\\_interpolate) 9. [Geometry Information](/pages/docs/geom.html) (geom\\_lg.h, get\\_material\\_number)",
    "tags": "",
    "url": "/pages/util.html"
  },{
    "title": "",
    "text": "[**applications**](pages/applications) [~~commands~~](pages/commands) [~~commands_cat~~](pages/commands_cat) [~~denise~~](pages/denise) [~~development~~](pages/development) [~~DEFINEII~~](pages/docs/DEFINEII) [~~QUALITY_sliver_cap_needle_wedge~~](pages/docs/QUALITY_sliver_cap_needle_wedge) [~~REFINE1~~](pages/docs/REFINE1) [**References**](pages/docs/References) [~~STOR_Form~~](pages/docs/STOR_Form) [~~accessing~~](pages/docs/accessing) [~~arrcomp~~](pages/docs/arrcomp) [~~arrsort~~](pages/docs/arrsort) [~~assignmt~~](pages/docs/assignmt) [**build**](pages/docs/build) [~~charlen~~](pages/docs/charlen) [~~commandi~~](pages/docs/commandi) [~~.SMOOTH.md.~~](pages/docs/commands/.SMOOTH.md.) [~~.nfs00000000c046df2c00000_temp~~](pages/docs/commands/.nfs00000000c046df2c00000_temp) [**.nfs00000000c0ab90aa00000_temp**](pages/docs/commands/.nfs00000000c0ab90aa00000_temp) [~~.nfs00000000c12fd5bd00000_temp~~](pages/docs/commands/.nfs00000000c12fd5bd00000_temp) [~~ADDMESH~~](pages/docs/commands/ADDMESH) [**ASSIGN**](pages/docs/commands/ASSIGN) [~~BOUNDAR1~~](pages/docs/commands/BOUNDAR1) [**BOUNDARY_C**](pages/docs/commands/BOUNDARY_C) [~~CMO2~~](pages/docs/commands/CMO2) [~~COLORMAP~~](pages/docs/commands/COLORMAP) [**COMPUTE**](pages/docs/commands/COMPUTE) [**CONNECT1**](pages/docs/commands/CONNECT1) [~~COORDSY~~](pages/docs/commands/COORDSY) [~~COPYPTS~~](pages/docs/commands/COPYPTS) [~~DEFINE~~](pages/docs/commands/DEFINE) [~~DEREFINE~~](pages/docs/commands/DEREFINE) [~~DOPING1~~](pages/docs/commands/DOPING1) [**DUMP2**](pages/docs/commands/DUMP2) [~~DUMP_RECOLOR~~](pages/docs/commands/DUMP_RECOLOR) [~~EDIT2~~](pages/docs/commands/EDIT2) [~~ELTSET2~~](pages/docs/commands/ELTSET2) [**EXODUS**](pages/docs/commands/EXODUS) [~~EXTRACT1~~](pages/docs/commands/EXTRACT1) [~~FIELD~~](pages/docs/commands/FIELD) [~~FILTER~~](pages/docs/commands/FILTER) [**FILTER_element**](pages/docs/commands/FILTER_element) [~~FINISH~~](pages/docs/commands/FINISH) [~~FSET~~](pages/docs/commands/FSET) [**GENIEE**](pages/docs/commands/GENIEE) [~~GRID2GRID~~](pages/docs/commands/GRID2GRID) [~~HELP~~](pages/docs/commands/HELP) [~~HEXTOTE~~](pages/docs/commands/HEXTOTE) [~~INPUT~~](pages/docs/commands/INPUT) [~~INTERSECT~~](pages/docs/commands/INTERSECT) [~~LOG~~](pages/docs/commands/LOG) [~~MASSAGE~~](pages/docs/commands/MASSAGE) [~~MASSAGE2~~](pages/docs/commands/MASSAGE2) [~~MATH~~](pages/docs/commands/MATH) [~~MERGE~~](pages/docs/commands/MERGE) [~~MODE~~](pages/docs/commands/MODE) [~~MREGION~~](pages/docs/commands/MREGION) [~~NEGATIVE~~](pages/docs/commands/NEGATIVE) [~~OFFSETSURF~~](pages/docs/commands/OFFSETSURF) [~~PERTURB~~](pages/docs/commands/PERTURB) [~~PSET~~](pages/docs/commands/PSET) [~~PSTATUS~~](pages/docs/commands/PSTATUS) [~~QUADXY~~](pages/docs/commands/QUADXY) [~~QUADXYZ1~~](pages/docs/commands/QUADXYZ1) [~~QUALITY~~](pages/docs/commands/QUALITY) [~~RADAPT~~](pages/docs/commands/RADAPT) [**READ**](pages/docs/commands/READ) [**RECON**](pages/docs/commands/RECON) [**REFINE**](pages/docs/commands/REFINE) [~~REGION~~](pages/docs/commands/REGION) [~~REGNPTS~~](pages/docs/commands/REGNPTS) [~~REORDER~~](pages/docs/commands/REORDER) [~~RESETPT~~](pages/docs/commands/RESETPT) [~~RM~~](pages/docs/commands/RM) [~~RMMAT~~](pages/docs/commands/RMMAT) [~~RMPOINT~~](pages/docs/commands/RMPOINT) [~~RMREGION~~](pages/docs/commands/RMREGION) [~~RMSPHERE~~](pages/docs/commands/RMSPHERE) [~~RMSURF~~](pages/docs/commands/RMSURF) [~~ROTATELN~~](pages/docs/commands/ROTATELN) [~~ROTATEPT~~](pages/docs/commands/ROTATEPT) [~~RZ~~](pages/docs/commands/RZ) [~~RZAMR~~](pages/docs/commands/RZAMR) [~~RZBRICK~~](pages/docs/commands/RZBRICK) [~~RZRAN~~](pages/docs/commands/RZRAN) [~~RZS~~](pages/docs/commands/RZS) [~~RZV_LG~~](pages/docs/commands/RZV_LG) [~~SCALE~~](pages/docs/commands/SCALE) [~~SETPTS~~](pages/docs/commands/SETPTS) [**SETSIZE**](pages/docs/commands/SETSIZE) [~~SETTETS~~](pages/docs/commands/SETTETS) [~~SMOOTH~~](pages/docs/commands/SMOOTH) [~~SORT~~](pages/docs/commands/SORT) [**STACK**](pages/docs/commands/STACK) [~~SURFACE~~](pages/docs/commands/SURFACE) [~~SURFPTS~~](pages/docs/commands/SURFPTS) [~~TRANS~~](pages/docs/commands/TRANS) [~~TRIAGN~~](pages/docs/commands/TRIAGN) [~~UNG2AVS~~](pages/docs/commands/UNG2AVS) [**UPSCALE**](pages/docs/commands/UPSCALE) [~~ZQ~~](pages/docs/commands/ZQ) [~~bubble~~](pages/docs/commands/bubble) [~~calc_rdist~~](pages/docs/commands/calc_rdist) [~~cmo_addatt~~](pages/docs/commands/cmo/cmo_addatt) [**cmo_att_derive**](pages/docs/commands/cmo/cmo_att_derive) [~~cmo_compress~~](pages/docs/commands/cmo/cmo_compress) [~~cmo_constraint~~](pages/docs/commands/cmo/cmo_constraint) [~~cmo_copy~~](pages/docs/commands/cmo/cmo_copy) [~~cmo_copyatt~~](pages/docs/commands/cmo/cmo_copyatt) [~~cmo_create~~](pages/docs/commands/cmo/cmo_create) [~~cmo_delatt~~](pages/docs/commands/cmo/cmo_delatt) [~~cmo_derive~~](pages/docs/commands/cmo/cmo_derive) [~~cmo_geom~~](pages/docs/commands/cmo/cmo_geom) [~~cmo_length~~](pages/docs/commands/cmo/cmo_length) [~~cmo_list~~](pages/docs/commands/cmo/cmo_list) [~~cmo_memory~~](pages/docs/commands/cmo/cmo_memory) [~~cmo_modatt~~](pages/docs/commands/cmo/cmo_modatt) [~~cmo_move~~](pages/docs/commands/cmo/cmo_move) [~~cmo_newlen~~](pages/docs/commands/cmo/cmo_newlen) [~~cmo_printatt~~](pages/docs/commands/cmo/cmo_printatt) [**cmo_readatt**](pages/docs/commands/cmo/cmo_readatt) [~~cmo_release~~](pages/docs/commands/cmo/cmo_release) [~~cmo_select~~](pages/docs/commands/cmo/cmo_select) [~~cmo_setatt~~](pages/docs/commands/cmo/cmo_setatt) [~~cmo_setid~~](pages/docs/commands/cmo/cmo_setid) [~~cmo_status~~](pages/docs/commands/cmo/cmo_status) [~~cmo_verify~~](pages/docs/commands/cmo/cmo_verify) [~~create_graph~~](pages/docs/commands/create_graph) [~~createpts~~](pages/docs/commands/createpts) [~~CREATEPTSAMR~~](pages/docs/commands/createpts/CREATEPTSAMR) [~~CRTPTBRICK~~](pages/docs/commands/createpts/CRTPTBRICK) [~~CRTPTRZRAN~~](pages/docs/commands/createpts/CRTPTRZRAN) [~~CRTPTRZV_LG~~](pages/docs/commands/createpts/CRTPTRZV_LG) [~~CRTPTSRZ~~](pages/docs/commands/createpts/CRTPTSRZ) [~~createpts_interp~~](pages/docs/commands/createpts/createpts_interp) [~~createpts_median~~](pages/docs/commands/createpts/createpts_median) [~~createpts_voronoi~~](pages/docs/commands/createpts/createpts_voronoi) [~~cresphere~~](pages/docs/commands/createpts/cresphere) [**crush_thin_tets**](pages/docs/commands/crush_thin_tets) [**DUMP3**](pages/docs/commands/dump/DUMP3) [~~EXTRACT_SURFMESH~~](pages/docs/commands/dump/EXTRACT_SURFMESH) [~~elmtest~~](pages/docs/commands/elmtest) [~~extrude~~](pages/docs/commands/extrude) [~~geometry~~](pages/docs/commands/geometry) [~~intersectelements~~](pages/docs/commands/intersectelements) [~~kdtree~~](pages/docs/commands/kdtree) [**loop**](pages/docs/commands/loop) [~~lower_d~~](pages/docs/commands/lower_d) [**main_interpolate**](pages/docs/commands/main_interpolate) [**memory**](pages/docs/commands/memory) [~~metis~~](pages/docs/commands/metis) [**rankvolume**](pages/docs/commands/rankvolume) [~~refine2d~~](pages/docs/commands/refine2d) [**connect_notes**](pages/docs/connect_notes) [~~connecttet~~](pages/docs/connecttet) [~~conventions~~](pages/docs/conventions) [~~d~~](pages/docs/d) [~~defineev~~](pages/docs/defineev) [~~definemo~~](pages/docs/definemo) [~~description1_add~~](pages/docs/demos/description1_add) [~~description1_xyz~~](pages/docs/demos/description1_xyz) [~~description2_amr~~](pages/docs/demos/description2_amr) [~~description2_connect~~](pages/docs/demos/description2_connect) [~~description2_rtz~~](pages/docs/demos/description2_rtz) [~~description3_append~~](pages/docs/demos/description3_append) [~~description3_connect~~](pages/docs/demos/description3_connect) [~~description3_rtp~~](pages/docs/demos/description3_rtp) [~~description4_brick~~](pages/docs/demos/description4_brick) [~~description4_connect~~](pages/docs/demos/description4_connect) [~~description4_delete~~](pages/docs/demos/description4_delete) [~~description5_intersect~~](pages/docs/demos/description5_intersect) [~~description5_sphere~~](pages/docs/demos/description5_sphere) [~~description6_match~~](pages/docs/demos/description6_match) [~~description6_sphereB~~](pages/docs/demos/description6_sphereB) [~~description7_brickB~~](pages/docs/demos/description7_brickB) [~~description7_merge~~](pages/docs/demos/description7_merge) [~~description8_sphereC~~](pages/docs/demos/description8_sphereC) [~~description9_random~~](pages/docs/demos/description9_random) [~~description_2dconn~~](pages/docs/demos/description_2dconn) [~~description_2drecon~~](pages/docs/demos/description_2drecon) [~~description_brick_trunc~~](pages/docs/demos/description_brick_trunc) [~~description_connect~~](pages/docs/demos/description_connect) [~~description_dump~~](pages/docs/demos/description_dump) [~~description_hextet~~](pages/docs/demos/description_hextet) [~~description_pset~~](pages/docs/demos/description_pset) [~~description_qual~~](pages/docs/demos/description_qual) [~~description_regnpts~~](pages/docs/demos/description_regnpts) [~~description_rmmat~~](pages/docs/demos/description_rmmat) [~~description_rotatept~~](pages/docs/demos/description_rotatept) [~~description_sort~~](pages/docs/demos/description_sort) [~~description_trans~~](pages/docs/demos/description_trans) [~~description_tri~~](pages/docs/demos/description_tri) [~~extract_facesets~~](pages/docs/demos/extract_facesets) [~~index~~](pages/docs/demos/index) [~~lagrit_input_continuous.md.~~](pages/docs/demos/input/lagrit_input_continuous.md.) [**lagrit_input_map.md.**](pages/docs/demos/input/lagrit_input_map.md.) [~~lagrit_input_voronoi.md.~~](pages/docs/demos/input/lagrit_input_voronoi.md.) [~~main_2d_connect~~](pages/docs/demos/main_2d_connect) [~~main_2d_recon~~](pages/docs/demos/main_2d_recon) [~~main_addmesh~~](pages/docs/demos/main_addmesh) [~~main_connect~~](pages/docs/demos/main_connect) [~~main_createpts~~](pages/docs/demos/main_createpts) [~~main_createpts1~~](pages/docs/demos/main_createpts1) [~~main_dump~~](pages/docs/demos/main_dump) [~~main_extract_surfmesh~~](pages/docs/demos/main_extract_surfmesh) [~~main_hextet~~](pages/docs/demos/main_hextet) [~~main_hextet1~~](pages/docs/demos/main_hextet1) [~~main_pset~~](pages/docs/demos/main_pset) [~~main_pset1~~](pages/docs/demos/main_pset1) [~~main_qual~~](pages/docs/demos/main_qual) [~~main_regnpts~~](pages/docs/demos/main_regnpts) [~~main_rivara~~](pages/docs/demos/main_rivara) [~~main_rmmat~~](pages/docs/demos/main_rmmat) [~~main_rotateln~~](pages/docs/demos/main_rotateln) [~~main_rotatept~~](pages/docs/demos/main_rotatept) [~~main_sort~~](pages/docs/demos/main_sort) [~~main_trans~~](pages/docs/demos/main_trans) [~~main_tri~~](pages/docs/demos/main_tri) [~~main_tri1~~](pages/docs/demos/main_tri1) [~~test~~](pages/docs/demos/test) [~~distributep~~](pages/docs/distributep) [~~dividereg~~](pages/docs/dividereg) [~~edges~~](pages/docs/edges) [**errors**](pages/docs/errors) [~~fortran~~](pages/docs/fortran) [**geom**](pages/docs/geom) [~~geom_create~~](pages/docs/geom_create) [~~geometries~~](pages/docs/geometries) [~~issuing~~](pages/docs/issuing) [~~lagrit~~](pages/docs/lagrit) [~~memmang~~](pages/docs/memmang) [~~meshing~~](pages/docs/meshing) [~~meshob~~](pages/docs/meshob) [~~meshobjcon~~](pages/docs/meshobjcon) [~~meshobject~~](pages/docs/meshobject) [~~miscell~~](pages/docs/miscell) [*picturesweek*](pages/docs/picturesweek) [~~pointsel~~](pages/docs/pointsel) [~~read_avs~~](pages/docs/read_avs) [~~read_datex~~](pages/docs/read_datex) [**read_fehm_zone**](pages/docs/read_fehm_zone) [~~read_freeformat~~](pages/docs/read_freeformat) [~~read_gmv~~](pages/docs/read_gmv) [**read_gocad**](pages/docs/read_gocad) [~~read_iges_grid~~](pages/docs/read_iges_grid) [~~read_lagrit~~](pages/docs/read_lagrit) [~~read_ngp~~](pages/docs/read_ngp) [~~read_sheetij~~](pages/docs/read_sheetij) [~~read_vrml~~](pages/docs/read_vrml) [~~refine_faces~~](pages/docs/refine_faces) [~~refine_tets~~](pages/docs/refine_tets) [~~retpts~~](pages/docs/retpts) [~~stack_demo~~](pages/docs/stack_demo) [~~stack_demo2~~](pages/docs/stack_demo2) [~~supported~~](pages/docs/supported) [**writing**](pages/docs/writing) [~~features~~](pages/features) [~~finite~~](pages/finite) [~~github_pages_example~~](pages/github_pages_example) [~~grain~~](pages/grain) [~~graphics~~](pages/graphics) [~~hex~~](pages/hex) [~~hex1~~](pages/hex1) [~~hex2~~](pages/hex2) [~~hybrid~~](pages/hybrid) [~~hybrid1~~](pages/hybrid1) [~~hybrid2~~](pages/hybrid2) [~~lasetup~~](pages/lasetup) [~~lasetup_require~~](pages/lasetup_require) [~~licensing~~](pages/licensing) [~~manual~~](pages/manual) [~~GenRegion~~](pages/mstkla/GenRegion) [~~Geom~~](pages/mstkla/Geom) [~~GeomEdge~~](pages/mstkla/GeomEdge) [~~GeomEntity~~](pages/mstkla/GeomEntity) [~~GeomFace~~](pages/mstkla/GeomFace) [~~GeomRegion~~](pages/mstkla/GeomRegion) [~~GeomVertex~~](pages/mstkla/GeomVertex) [~~Mesh~~](pages/mstkla/Mesh) [~~MeshAttributes~~](pages/mstkla/MeshAttributes) [~~MeshEdge~~](pages/mstkla/MeshEdge) [~~MeshFace~~](pages/mstkla/MeshFace) [**MeshRegion**](pages/mstkla/MeshRegion) [~~MeshVertex~~](pages/mstkla/MeshVertex) [~~example~~](pages/mstkla/example) [~~index~~](pages/mstkla/index) [~~linking~~](pages/mstkla/linking) [~~mstkla~~](pages/mstkla/mstkla) [~~parent-child~~](pages/mstkla/parent-child) [~~prelim~~](pages/mstkla/prelim) [**trivia**](pages/mstkla/trivia) [~~utilities~~](pages/mstkla/utilities) [*pictures*](pages/pictures) [**publications**](pages/publications) [~~release~~](pages/release) [**lagrit_release_notes_081021**](pages/release_notes/lagrit_release_notes_081021) [**lagrit_release_notes_V1.0.2**](pages/release_notes/lagrit_release_notes_V1.0.2) [~~lagrit_release_notes_V1.0.3~~](pages/release_notes/lagrit_release_notes_V1.0.3) [~~lagrit_release_notes_V1.00~~](pages/release_notes/lagrit_release_notes_V1.00) [**lagrit_release_notes_V1.1.0**](pages/release_notes/lagrit_release_notes_V1.1.0) [~~lagrit_release_notes_V1.1.2~~](pages/release_notes/lagrit_release_notes_V1.1.2) [~~lagrit_release_notes_V1.1.4~~](pages/release_notes/lagrit_release_notes_V1.1.4) [**lagrit_release_notes_V2.002**](pages/release_notes/lagrit_release_notes_V2.002) [~~lagrit_release_notes_V3.00~~](pages/release_notes/lagrit_release_notes_V3.00) [**lagrit_release_notes_V3.100**](pages/release_notes/lagrit_release_notes_V3.100) [**lagrit_release_notes_V3.200**](pages/release_notes/lagrit_release_notes_V3.200) [~~search_page~~](pages/search_page) [~~semi~~](pages/semi) [~~semi2~~](pages/semi2) [~~semiexamples~~](pages/semiexamples) [~~tee~~](pages/tee) [~~tinkas~~](pages/tinkas) [~~index~~](pages/tutorial/index) [~~gallery~~](pages/tutorial/stratigraphy/images/gallery) [**index**](pages/tutorial/stratigraphy/index) [**step_01**](pages/tutorial/stratigraphy/step_01) [**step_02**](pages/tutorial/stratigraphy/step_02) [**step_03**](pages/tutorial/stratigraphy/step_03) [**step_04**](pages/tutorial/stratigraphy/step_04) [**step_05**](pages/tutorial/stratigraphy/step_05) [**step_06**](pages/tutorial/stratigraphy/step_06) [**step_07**](pages/tutorial/stratigraphy/step_07) [**step_08**](pages/tutorial/stratigraphy/step_08) [**step_09**](pages/tutorial/stratigraphy/step_09) [**step_10_exo**](pages/tutorial/stratigraphy/step_10_exo) [**step_10_fehm**](pages/tutorial/stratigraphy/step_10_fehm) [~~regions_points_to_tet~~](pages/tutorial/tutorials/regions_points_to_tet) [~~convert_feet_to_meters~~](pages/tutorial/utility/convert_feet_to_meters) [~~reset_truncated_nodes_imt~~](pages/tutorial/utility/reset_truncated_nodes_imt) [~~util~~](pages/util)",
    "tags": "",
    "url": "/site_list.html"
  },{
    "title": "",
    "text": "[**Home**](/) [***applications***](pages/applications) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~index~~](pages/docs/demos/index) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~createpts~~](pages/docs/commands/createpts) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~CREATEPTSAMR~~](pages/docs/commands/createpts/CREATEPTSAMR) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~CRTPTBRICK~~](pages/docs/commands/createpts/CRTPTBRICK) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~CRTPTRZRAN~~](pages/docs/commands/createpts/CRTPTRZRAN) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~CRTPTRZV_LG~~](pages/docs/commands/createpts/CRTPTRZV_LG) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~CRTPTSRZ~~](pages/docs/commands/createpts/CRTPTSRZ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RZ~~](pages/docs/commands/RZ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RZRAN~~](pages/docs/commands/RZRAN) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RZV_LG~~](pages/docs/commands/RZV_LG) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~createpts_interp~~](pages/docs/commands/createpts/createpts_interp) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**createpts_median**](pages/docs/commands/createpts/createpts_median) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**createpts_voronoi**](pages/docs/commands/createpts/createpts_voronoi) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~cresphere~~](pages/docs/commands/createpts/cresphere) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_createpts~~](pages/docs/demos/main_createpts) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_2d_connect~~](pages/docs/demos/main_2d_connect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_2dconn~~](pages/docs/demos/description_2dconn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_2d_recon~~](pages/docs/demos/main_2d_recon) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_2drecon~~](pages/docs/demos/description_2drecon) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_addmesh~~](pages/docs/demos/main_addmesh) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~d~~](pages/hybrid) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description1_add~~](pages/docs/demos/description1_add) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description2_amr~~](pages/docs/demos/description2_amr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description3_append~~](pages/docs/demos/description3_append) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description4_delete~~](pages/docs/demos/description4_delete) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description5_intersect~~](pages/docs/demos/description5_intersect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description6_match~~](pages/docs/demos/description6_match) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description7_merge~~](pages/docs/demos/description7_merge) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_connect~~](pages/docs/demos/main_connect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description2_connect~~](pages/docs/demos/description2_connect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description3_connect~~](pages/docs/demos/description3_connect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description4_connect~~](pages/docs/demos/description4_connect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_connect~~](pages/docs/demos/description_connect) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_hextet~~](pages/docs/demos/description_hextet) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_createpts~~](pages/docs/demos/main_createpts) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description1_xyz~~](pages/docs/demos/description1_xyz) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description2_rtz~~](pages/docs/demos/description2_rtz) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description3_rtp~~](pages/docs/demos/description3_rtp) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description4_brick~~](pages/docs/demos/description4_brick) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description5_sphere~~](pages/docs/demos/description5_sphere) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description6_sphereB~~](pages/docs/demos/description6_sphereB) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description7_brickB~~](pages/docs/demos/description7_brickB) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description8_sphereC~~](pages/docs/demos/description8_sphereC) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_dump~~](pages/docs/demos/main_dump) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_dump~~](pages/docs/demos/description_dump) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_hextet~~](pages/docs/demos/main_hextet) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_pset~~](pages/docs/demos/main_pset) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_pset~~](pages/docs/demos/description_pset) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_qual~~](pages/docs/demos/main_qual) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_qual~~](pages/docs/demos/description_qual) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_regnpts~~](pages/docs/demos/main_regnpts) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_rivara~~](pages/docs/demos/main_rivara) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_rmmat~~](pages/docs/demos/main_rmmat) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RMMAT~~](pages/docs/commands/RMMAT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_rotatept~~](pages/docs/demos/main_rotatept) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_rotatept~~](pages/docs/demos/description_rotatept) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_sort~~](pages/docs/demos/main_sort) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_sort~~](pages/docs/demos/description_sort) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_trans~~](pages/docs/demos/main_trans) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_trans~~](pages/docs/demos/description_trans) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_tri~~](pages/docs/demos/main_tri) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~description_tri~~](pages/docs/demos/description_tri) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~lasetup~~](pages/lasetup) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~lasetup_require~~](pages/lasetup_require) [~~development~~](pages/development) [**example**](pages/github_pages_example) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~ADDMESH~~](pages/docs/commands/ADDMESH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~FILTER~~](pages/docs/commands/FILTER) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***FILTER_element***](pages/docs/commands/FILTER_element) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RMPOINT~~](pages/docs/commands/RMPOINT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RESETPT~~](pages/docs/commands/RESETPT) [**github_pages_example**](pages/github_pages_example) [~~graphics~~](pages/graphics) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~denise~~](pages/denise) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~finite~~](pages/finite) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~grain~~](pages/grain) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~hex~~](pages/hex) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~hex1~~](pages/hex1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~hex2~~](pages/hex2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~hybrid~~](pages/hybrid) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~hybrid1~~](pages/hybrid1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~hybrid2~~](pages/hybrid2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~semiexamples~~](pages/semiexamples) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~semi~~](pages/semi) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~semi2~~](pages/semi2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~tee~~](pages/tee) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~tinkas~~](pages/tinkas) [~~licensing~~](pages/licensing) [~~manual~~](pages/manual) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***References***](pages/docs/References) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~accessing~~](pages/docs/accessing) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**build**](pages/docs/build) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***writing***](pages/docs/writing) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**commandi**](pages/docs/commandi) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~CMO2~~](pages/docs/commands/CMO2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~cmo_addatt~~](pages/docs/commands/cmo/cmo_addatt) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***DUMP2***](pages/docs/commands/DUMP2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~QUALITY~~](pages/docs/commands/QUALITY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~cmo_modatt~~](pages/docs/commands/cmo/cmo_modatt) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_create**](pages/docs/commands/cmo/cmo_create) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_select**](pages/docs/commands/cmo/cmo_select) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~commands~~](pages/commands) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***ASSIGN***](pages/docs/commands/ASSIGN) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~meshobject~~](pages/docs/meshobject) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~BOUNDAR1~~](pages/docs/commands/BOUNDAR1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~miscell~~](pages/docs/miscell) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***BOUNDARY_C***](pages/docs/commands/BOUNDARY_C) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~COLORMAP~~](pages/docs/commands/COLORMAP) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***COMPUTE***](pages/docs/commands/COMPUTE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MATH~~](pages/docs/commands/MATH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SURFACE~~](pages/docs/commands/SURFACE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~kdtree~~](pages/docs/commands/kdtree) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***CONNECT1***](pages/docs/commands/CONNECT1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~COORDSY~~](pages/docs/commands/COORDSY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~COPYPTS~~](pages/docs/commands/COPYPTS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~DEFINE~~](pages/docs/commands/DEFINE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~DEREFINE~~](pages/docs/commands/DEREFINE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~DOPING1~~](pages/docs/commands/DOPING1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***main_interpolate***](pages/docs/commands/main_interpolate) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~DUMP_RECOLOR~~](pages/docs/commands/DUMP_RECOLOR) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~EDIT2~~](pages/docs/commands/EDIT2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~ELTSET2~~](pages/docs/commands/ELTSET2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~EXTRACT1~~](pages/docs/commands/EXTRACT1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~EXTRACT_SURFMESH~~](pages/docs/commands/dump/EXTRACT_SURFMESH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~EXTRACT_SURFMESH~~](pages/docs/commands/dump/EXTRACT_SURFMESH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~GRID2GRID~~](pages/docs/commands/GRID2GRID) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**extract_facesets**](pages/docs/demos/extract_facesets) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_extract_surfmesh~~](pages/docs/demos/main_extract_surfmesh) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~FIELD~~](pages/docs/commands/FIELD) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~FINISH~~](pages/docs/commands/FINISH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~FSET~~](pages/docs/commands/FSET) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***GENIEE***](pages/docs/commands/GENIEE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~GRID2GRID~~](pages/docs/commands/GRID2GRID) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~HELP~~](pages/docs/commands/HELP) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~HEXTOTE~~](pages/docs/commands/HEXTOTE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~INPUT~~](pages/docs/commands/INPUT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~INTERSECT~~](pages/docs/commands/INTERSECT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SORT~~](pages/docs/commands/SORT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~LOG~~](pages/docs/commands/LOG) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MASSAGE~~](pages/docs/commands/MASSAGE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MASSAGE2~~](pages/docs/commands/MASSAGE2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MASSAGE2~~](pages/docs/commands/MASSAGE2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MATH~~](pages/docs/commands/MATH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MERGE~~](pages/docs/commands/MERGE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MODE~~](pages/docs/commands/MODE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***RECON***](pages/docs/commands/RECON) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~MREGION~~](pages/docs/commands/MREGION) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~REGION~~](pages/docs/commands/MREGION) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~geometries~~](pages/docs/geometries) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**geometry**](pages/docs/commands/geometry) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~NEGATIVE~~](pages/docs/commands/NEGATIVE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~OFFSETSURF~~](pages/docs/commands/OFFSETSURF) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~PERTURB~~](pages/docs/commands/PERTURB) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~PSET~~](pages/docs/commands/PSET) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~conventions~~](pages/docs/conventions) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~PSTATUS~~](pages/docs/commands/PSTATUS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~QUADXY~~](pages/docs/commands/QUADXY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~QUADXYZ1~~](pages/docs/commands/QUADXYZ1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RADAPT~~](pages/docs/commands/RADAPT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SMOOTH~~](pages/docs/commands/SMOOTH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***READ***](pages/docs/commands/READ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_readatt**](pages/docs/commands/cmo/cmo_readatt) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~lagrit~~](pages/docs/lagrit) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_avs~~](pages/docs/read_avs) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_datex~~](pages/docs/read_datex) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***read_fehm_zone***](pages/docs/read_fehm_zone) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_freeformat~~](pages/docs/read_freeformat) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_gmv~~](pages/docs/read_gmv) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***read_gocad***](pages/docs/read_gocad) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_iges_grid~~](pages/docs/read_iges_grid) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_lagrit~~](pages/docs/read_lagrit) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_ngp~~](pages/docs/read_ngp) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_sheetij~~](pages/docs/read_sheetij) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~read_vrml~~](pages/docs/read_vrml) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***RECON***](pages/docs/commands/RECON) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~REFINE~~](pages/docs/commands/DEREFINE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~REGION~~](pages/docs/commands/MREGION) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~REGNPTS~~](pages/docs/commands/REGNPTS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~REORDER~~](pages/docs/commands/REORDER) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RM~~](pages/docs/commands/RM) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RMREGION~~](pages/docs/commands/RMREGION) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RMSPHERE~~](pages/docs/commands/RMSPHERE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RMSURF~~](pages/docs/commands/RMSURF) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~ROTATELN~~](pages/docs/commands/ROTATELN) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~main_rotateln~~](pages/docs/demos/main_rotateln) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~ROTATEPT~~](pages/docs/commands/ROTATEPT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RZAMR~~](pages/docs/commands/RZAMR) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RZBRICK~~](pages/docs/commands/RZBRICK) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~RZS~~](pages/docs/commands/RZS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SCALE~~](pages/docs/commands/SCALE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SETPTS~~](pages/docs/commands/SETPTS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***SETSIZE***](pages/docs/commands/SETSIZE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~TRANS~~](pages/docs/commands/TRANS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_printatt**](pages/docs/commands/cmo/cmo_printatt) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_setatt**](pages/docs/commands/cmo/cmo_setatt) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SETTETS~~](pages/docs/commands/SETTETS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SMOOTH~~](pages/docs/commands/SMOOTH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SORT~~](pages/docs/commands/SORT) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***STACK***](pages/docs/commands/STACK) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~stack_demo~~](pages/docs/stack_demo) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~stack_demo2~~](pages/docs/stack_demo2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SURFACE~~](pages/docs/commands/SURFACE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~SURFPTS~~](pages/docs/commands/SURFPTS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~TRANS~~](pages/docs/commands/TRANS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~TRIAGN~~](pages/docs/commands/TRIAGN) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~UNG2AVS~~](pages/docs/commands/UNG2AVS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***UPSCALE***](pages/docs/commands/UPSCALE) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~ZQ~~](pages/docs/commands/ZQ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~bubble~~](pages/docs/commands/bubble) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~extrude~~](pages/docs/commands/extrude) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~calc_rdist~~](pages/docs/commands/calc_rdist) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~create_graph~~](pages/docs/commands/create_graph) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~metis~~](pages/docs/commands/metis) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***crush_thin_tets***](pages/docs/commands/crush_thin_tets) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~elmtest~~](pages/docs/commands/elmtest) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~extrude~~](pages/docs/commands/extrude) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**geometry**](pages/docs/commands/geometry) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_geom**](pages/docs/commands/cmo/cmo_geom) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***geom***](pages/docs/geom) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~intersectelements~~](pages/docs/commands/intersectelements) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~kdtree~~](pages/docs/commands/kdtree) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***loop***](pages/docs/commands/loop) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~lower_d~~](pages/docs/commands/lower_d) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***main_interpolate***](pages/docs/commands/main_interpolate) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***memory***](pages/docs/commands/memory) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~memmang~~](pages/docs/memmang) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~metis~~](pages/docs/commands/metis) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***rankvolume***](pages/docs/commands/rankvolume) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~refine2d~~](pages/docs/commands/refine2d) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~test~~](pages/docs/commands/elmtest) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~commands_cat~~](pages/commands_cat) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~conventions~~](pages/docs/conventions) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***errors***](pages/docs/errors) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~features~~](pages/features) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~fortran~~](pages/docs/fortran) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~meshob~~](pages/docs/meshob) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~geometries~~](pages/docs/geometries) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~cmo_constraint~~](pages/docs/commands/cmo/cmo_constraint) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~geom_create~~](pages/docs/geom_create) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~issuing~~](pages/docs/issuing) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~lagrit~~](pages/docs/lagrit) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~meshing~~](pages/docs/meshing) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~QUALITY_sliver_cap_needle_wedge~~](pages/docs/QUALITY_sliver_cap_needle_wedge) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~meshobjcon~~](pages/docs/meshobjcon) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~supported~~](pages/docs/supported) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~meshobject~~](pages/docs/meshobject) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_delatt**](pages/docs/commands/cmo/cmo_delatt) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [**cmo_status**](pages/docs/commands/cmo/cmo_status) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***publications***](pages/publications) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~supported~~](pages/docs/supported) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~util~~](pages/util) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~arrcomp~~](pages/docs/arrcomp) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~arrsort~~](pages/docs/arrsort) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~charlen~~](pages/docs/charlen) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~pointsel~~](pages/docs/pointsel) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [~~retpts~~](pages/docs/retpts) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [***writing***](pages/docs/writing) [***publications***](pages/publications) [~~release~~](pages/release)",
    "tags": "",
    "url": "/site_map.html"
  }]};
